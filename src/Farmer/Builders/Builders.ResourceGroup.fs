[<AutoOpen>]
module Farmer.Builders.ResourceGroup

open Farmer
open Farmer.Arm.ResourceGroup

type AutoGeneratable<'t> =
    private
    | FixedValue of 't
    | AutoGeneratedValue of 't option ref

    member this.GetValue generator =
        match this with
        | FixedValue v -> v
        | AutoGeneratedValue { contents = (Some v) } -> v
        | AutoGeneratedValue cell ->
            let v = generator ()
            cell := Some v
            v

module AutoGeneratable =
    let Manual value = FixedValue value

    let AutoGenerate<'t> () =
        AutoGeneratable<'t>.AutoGeneratedValue(ref None)


let deploymentIndex =
    let mutable index = 1000
    fun () -> System.Threading.Interlocked.Increment(&index)

type ResourceGroupConfig = {
    TargetResourceGroup: string Option
    DeploymentName: AutoGeneratable<string>
    Dependencies: ResourceId Set
    Parameters: string Set
    Outputs: Map<string, string>
    Location: Location
    Resources: IArmResource list
    ParameterValues: ParameterValue list
    SubscriptionId: System.Guid option
    Mode: DeploymentMode
    Tags: Map<string, string>
} with

    member private this.GenerateDeploymentName() =
        match this.TargetResourceGroup with
        | Some rg when rg.[0] = '[' ->
            // TargetResourceGroup can be an ARM expression when doing nested deployments such as when creating App-managed certificates in the WebApp builder.
            // Because the value is not known when we generate the template, we must use the ARM concat function to append a suffix to prevent deployment errors
            $"[concat({rg.Trim([| '['; ']' |])},'-deployment-{deploymentIndex ()}')]"
        | Some rg -> $"{rg}-deployment-{deploymentIndex ()}"
        | None -> $"deployment-{deploymentIndex ()}"

    member this.ResourceId = {
        resourceGroupDeployment.resourceId (this.DeploymentName.GetValue this.GenerateDeploymentName) with
            ResourceGroup = this.TargetResourceGroup
            Subscription = this.SubscriptionId |> Option.map string
    }

    member private this.ContentDeployment =
        if this.Parameters.IsEmpty && this.Outputs.IsEmpty && this.Resources.IsEmpty then
            None // this resource group has no content so there's nothing to deploy
        else
            let innerOutputs =
                this.Resources
                |> List.collect (function
                    | :? ResourceGroupDeployment as rg ->
                        Map.toList rg.Outputs
                        |> List.map fst
                        |> List.map (fun key ->
                            $"{rg.ResourceId.Name.Value}.{key}",
                            $"[reference('{rg.ResourceId.Name.Value}').outputs['{key}'].value]")
                    | _ -> [])
                |> Map.ofList

            {
                ResourceGroupDeployment.TargetResourceGroup =
                    this.TargetResourceGroup |> Option.defaultValue "farmer-deploy" |> ResourceName
                DeploymentName = this.ResourceId.Name
                Dependencies = this.Dependencies
                Outputs = Map.merge (Map.toList this.Outputs) innerOutputs // New values overwrite old values so supply this.Outputs as newValues
                Location = this.Location
                Resources = this.Resources
                ParameterValues = this.ParameterValues
                SubscriptionId = this.SubscriptionId
                Mode = this.Mode
                Tags = this.Tags
            }
            |> Some

    member this.Template =
        this.ContentDeployment
        |> Option.map (fun x -> x.Template)
        |> Option.defaultValue {
            Parameters = List.empty
            Outputs = List.empty
            Resources = List.empty
        }

    interface IDeploymentSource with
        member this.Deployment =
            let rec getPostDeployTasks (resources: IArmResource list) = [
                for resource in resources do
                    match resource with
                    | :? IPostDeploy as pd -> pd
                    | :? ResourceGroupDeployment as rgp -> yield! getPostDeployTasks rgp.Resources
                    | _ -> ()
            ]

            {
                Location = this.Location
                Template = this.Template
                PostDeployTasks = getPostDeployTasks this.Resources
                RequiredResourceGroups =
                    this.Resources
                    |> List.collect (function
                        | :? ResourceGroupDeployment as rg -> rg.RequiredResourceGroups
                        | _ -> [])
                Tags = this.Tags
            }

    interface IBuilder with
        member this.ResourceId = this.ResourceId

        member this.BuildResources loc = [
            match this.ContentDeployment with
            | Some x -> x
            | None -> ()
        ]

type DeploymentBuilder() =
    static member private EmptyState() = {
        TargetResourceGroup = None
        DeploymentName = AutoGeneratable.AutoGenerate()
        Dependencies = Set.empty
        Parameters = Set.empty
        Outputs = Map.empty
        Resources = List.empty
        ParameterValues = List.empty
        SubscriptionId = None
        Location = Location.ResourceGroup
        Mode = Incremental
        Tags = Map.empty
    }

    member _.Yield _ = DeploymentBuilder.EmptyState()

    /// Returns empty state for if-then expressions without else branches.
    /// Note: F# does not allow custom operations (like 'output', 'add_resource') inside control flow.
    /// Use Option type overloads instead: output "key" (someOption |> Option.map ...)
    member _.Zero() = DeploymentBuilder.EmptyState()

    /// Combines two deployment states together.
    /// Note: This enables control flow for non-custom operations only.
    /// Custom operations cannot be used inside if/match due to F# limitations (error FS3086).
    member _.Combine(state1: ResourceGroupConfig, state2: ResourceGroupConfig) = {
        TargetResourceGroup = state2.TargetResourceGroup |> Option.orElse state1.TargetResourceGroup
        DeploymentName =
            match state2.DeploymentName with
            | AutoGeneratedValue { contents = Some _ } -> state2.DeploymentName
            | AutoGeneratedValue { contents = None } -> state1.DeploymentName
            | FixedValue _ -> state2.DeploymentName
        Dependencies = state1.Dependencies + state2.Dependencies
        Parameters = state1.Parameters + state2.Parameters
        Outputs = Map.merge (Map.toList state1.Outputs) state2.Outputs
        Resources =
            state1.Resources @ state2.Resources
            |> List.distinctBy (fun r -> r.ResourceId, r.GetType().Name)
        ParameterValues = state1.ParameterValues @ state2.ParameterValues
        SubscriptionId = state2.SubscriptionId |> Option.orElse state1.SubscriptionId
        Location =
            match state2.Location with
            | LocationExpression _ when state2.Location = Location.ResourceGroup -> state1.Location
            | _ -> state2.Location
        Mode = state2.Mode
        Tags = Map.merge (Map.toList state1.Tags) state2.Tags
    }

    /// Delays computation for proper evaluation order.
    member _.Delay(f: unit -> ResourceGroupConfig) = f

    /// Runs the delayed computation.
    member _.Run(f: unit -> ResourceGroupConfig) = f ()

    /// Enables for loops over sequences.
    /// Note: Custom operations cannot be used inside the loop body due to F# limitations.
    member this.For(sequence: seq<'T>, body: 'T -> ResourceGroupConfig) =
        let mutable state = this.Zero()

        for item in sequence do
            state <- this.Combine(state, body item)

        state

    /// Creates an output value that will be returned by the ARM template.
    [<CustomOperation "output">]
    member _.Output(state, outputName, outputValue) : ResourceGroupConfig = {
        state with
            Outputs = state.Outputs.Add(outputName, outputValue)
    }

    member this.Output(state: ResourceGroupConfig, outputName: string, (ResourceName outputValue)) =
        this.Output(state, outputName, outputValue)

    member this.Output(state: ResourceGroupConfig, outputName: string, outputValue: ArmExpression) =
        this.Output(state, outputName, outputValue.Eval())

    member this.Output(state: ResourceGroupConfig, outputName: string, outputValue: string option) =
        match outputValue with
        | Some outputValue -> this.Output(state, outputName, outputValue)
        | None -> state

    member this.Output(state: ResourceGroupConfig, outputName: string, outputValue: ArmExpression option) =
        match outputValue with
        | Some outputValue -> this.Output(state, outputName, outputValue)
        | None -> state

    [<CustomOperation "outputs">]
    member __.Outputs(state, outputs) : ResourceGroupConfig = {
        state with
            Outputs = Map.merge outputs state.Outputs
    }

    member this.Outputs(state: ResourceGroupConfig, outputs) =
        this.Outputs(state, outputs |> List.map (fun (k: string, ResourceName r) -> k, r))

    member this.Outputs(state: ResourceGroupConfig, outputs) =
        this.Outputs(state, outputs |> List.map (fun (k, a: ArmExpression) -> k, a.Eval()))

    /// Sets the default location of all resources.
    [<CustomOperation "location">]
    member _.Location(state, location) : ResourceGroupConfig = { state with Location = location }

    static member private AddResources(state: ResourceGroupConfig, resources: IArmResource list) = {
        state with
            Resources =
                state.Resources @ resources
                |> List.distinctBy (fun r -> r.ResourceId, r.GetType().Name)
    }

    /// Adds a builder's ARM resources to the ARM template.
    [<CustomOperation "add_resource">]
    member _.AddResource(state: ResourceGroupConfig, input: IBuilder) =
        DeploymentBuilder.AddResources(state, input.BuildResources state.Location)

    member _.AddResource(state: ResourceGroupConfig, input: Builder) =
        DeploymentBuilder.AddResources(state, input state.Location)

    member _.AddResource(state: ResourceGroupConfig, input: IArmResource) =
        DeploymentBuilder.AddResources(state, [ input ])

    member _.AddResource(state: ResourceGroupConfig, input: IBuilder option) =
        match input with
        | Some inp -> DeploymentBuilder.AddResources(state, inp.BuildResources state.Location)
        | None -> state

    member _.AddResource(state: ResourceGroupConfig, input: Builder option) =
        match input with
        | Some inp -> DeploymentBuilder.AddResources(state, inp state.Location)
        | None -> state

    member _.AddResource(state: ResourceGroupConfig, input: IArmResource option) =
        match input with
        | Some inp -> DeploymentBuilder.AddResources(state, [ inp ])
        | None -> state

    [<CustomOperation "add_resources">]
    member this.AddResources(state: ResourceGroupConfig, input: IBuilder list) =
        let resources = input |> List.collect (fun i -> i.BuildResources state.Location)
        DeploymentBuilder.AddResources(state, resources)

    [<CustomOperation "add_arm_resources">]
    member this.AddArmResources(state: ResourceGroupConfig, input: IArmResource list) =
        DeploymentBuilder.AddResources(state, input)

    interface ITaggable<ResourceGroupConfig> with
        member _.Add state tags = {
            state with
                Tags = state.Tags |> Map.merge tags
        }

    interface IDependable<ResourceGroupConfig> with
        member _.Add state newDeps = {
            state with
                Dependencies = state.Dependencies + newDeps
        }

type ResourceGroupBuilder() =
    inherit DeploymentBuilder()

    /// Creates an output value that will be returned by the ARM template.
    [<CustomOperation "name">]
    member _.SetName(state: ResourceGroupConfig, name) = {
        state with
            TargetResourceGroup = Some name
    }

    /// Creates an output value that will be returned by the ARM template.
    [<CustomOperation "deployment_name">]
    member _.SetDeploymentName(state: ResourceGroupConfig, name) = {
        state with
            DeploymentName = FixedValue name
    }

    /// Sets the subscription ID for a nested deployment
    [<CustomOperation "subscription_id">]
    member this.SubscriptionId(state: ResourceGroupConfig, subscriptionId: System.Guid) = {
        state with
            SubscriptionId = Some subscriptionId
    }

    member this.SubscriptionId(state: ResourceGroupConfig, subscriptionId: string) = {
        state with
            SubscriptionId = Some(System.Guid subscriptionId)
    }

    [<CustomOperation "add_parameter_values">]
    member this.AddParameterValues(state: ResourceGroupConfig, parameters: (string * string) list) = {
        state with
            ParameterValues = state.ParameterValues @ (parameters |> List.map ParameterValue)
    }

    [<CustomOperation "add_secret_references">]
    member this.AddKeyVaultSecretReferences
        (state: ResourceGroupConfig, parameters: (string * ResourceId * string) list)
        =
        {
            state with
                ParameterValues = state.ParameterValues @ (parameters |> List.map KeyVaultReference)
        }

let resourceGroup = ResourceGroupBuilder()

/// Creates a resource group in a subscription level deployment.
let createResourceGroup (name: string) (location: Location) : ResourceGroup = {
    Name = ResourceName name
    Location = location
    Dependencies = Set.empty
    Tags = Map.empty
}