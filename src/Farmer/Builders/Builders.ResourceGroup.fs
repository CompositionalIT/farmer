[<AutoOpen>]
module Farmer.Builders.ResourceGroup

open Farmer
open Farmer.Arm.ResourceGroup

type AutoGeneratable<'t> = 
    private
    | FixedValue of 't
    | AutoGeneratedValue  of 't option ref
    member this.GetValue generator = 
        match this with
        | FixedValue v -> v
        | AutoGeneratedValue {contents = (Some v)} -> v
        | AutoGeneratedValue cell ->
            let v = generator()
            cell := Some v
            v
module AutoGeneratable = 
    let Manual value = FixedValue value
    let AutoGenerate<'t> () = AutoGeneratable<'t>.AutoGeneratedValue (ref None)


let deploymentIndex = 
    let mutable index = 1000
    fun () -> System.Threading.Interlocked.Increment(&index);

type ResourceGroupConfig =
    { TargetResourceGroup: string Option
      DeploymentName: AutoGeneratable<string>
      Dependencies: ResourceId Set
      Parameters : string Set
      Outputs : Map<string, string>
      Location : Location
      Resources : IArmResource list
      ParameterValues : ParameterValue list
      SubscriptionId : System.Guid option
      Mode: DeploymentMode
      Tags: Map<string,string> }
    member private this.GenerateDeploymentName () =
      match this.TargetResourceGroup with
      | Some rg when rg.[0]='[' -> 
        // TargetResourceGroup can be an ARM expression when doing nested deployments such as when creating App-managed certificates in the WebApp builder.
        // Because the value is not known when we generate the template, we must use the ARM concat function to append a suffix to prevent deployment errors
        $"[concat({rg},'deployment-{deploymentIndex()}]"
      | Some rg -> 
        $"{rg}-deployment-{deploymentIndex()}"
      | None -> 
        $"deployment-{deploymentIndex()}"

    member this.ResourceId = resourceGroupDeployment.resourceId (this.DeploymentName.GetValue this.GenerateDeploymentName)
    member private this.ContentDeployment =
        if this.Parameters.IsEmpty && this.Outputs.IsEmpty && this.Resources.IsEmpty then
            None // this resource group has no content so there's nothing to deploy
        else
            let innerOutputs =
                this.Resources
                |> List.collect
                    (function
                    | :? ResourceGroupDeployment as rg ->
                        Map.toList rg.Outputs
                        |> List.map fst
                        |> List.map (fun key -> $"{rg.ResourceId.Name.Value}.{key}",$"[reference('{rg.ResourceId.Name.Value}').outputs['{key}'].value]")
                    | _ ->
                        [] )
                |> Map.ofList

            { ResourceGroupDeployment.TargetResourceGroup = this.TargetResourceGroup |> Option.defaultValue "farmer-deploy" |> ResourceName
              DeploymentName = this.ResourceId.Name
              Dependencies = this.Dependencies
              Outputs = Map.merge (Map.toList this.Outputs) innerOutputs // New values overwrite old values so supply this.Outputs as newValues
              Location  = this.Location
              Resources = this.Resources
              ParameterValues = this.ParameterValues
              SubscriptionId = this.SubscriptionId
              Mode = this.Mode
              Tags = this.Tags }
            |> Some
    member this.Template =
        this.ContentDeployment
        |> Option.map (fun x -> x.Template)
        |> Option.defaultValue
            { Parameters = List.empty
              Outputs = List.empty
              Resources = List.empty }

    interface IDeploymentSource with
        member this.Deployment=
            { Location=this.Location
              Template = this.Template
              PostDeployTasks =
                    this.Resources
                    |> List.choose (function | :? IPostDeploy as pd -> Some pd |_ -> None)
              RequiredResourceGroups =
                    this.Resources
                    |> List.collect (function | :? ResourceGroupDeployment as rg -> rg.RequiredResourceGroups | _ -> [])
              Tags = this.Tags }
    interface IBuilder with
        member this.ResourceId = this.ResourceId
        member this.BuildResources loc =
            [ match this.ContentDeployment with
              | Some x -> x
              | None -> ()
            ]

type DeploymentBuilder() =
    member _.Yield _ =
        { TargetResourceGroup = None
          DeploymentName = AutoGeneratable.AutoGenerate()
          Dependencies = Set.empty
          Parameters = Set.empty
          Outputs = Map.empty
          Resources = List.empty
          ParameterValues = List.empty
          SubscriptionId = None
          Location = Location.WestEurope
          Mode = Incremental
          Tags = Map.empty }
    /// Creates an output value that will be returned by the ARM template.
    [<CustomOperation "output">]
    member _.Output (state, outputName, outputValue) : ResourceGroupConfig = { state with Outputs = state.Outputs.Add(outputName, outputValue) }
    member this.Output (state:ResourceGroupConfig, outputName:string, (ResourceName outputValue)) = this.Output(state, outputName, outputValue)
    member this.Output (state:ResourceGroupConfig, outputName:string, outputValue:ArmExpression) = this.Output(state, outputName, outputValue.Eval())
    member this.Output (state:ResourceGroupConfig, outputName:string, outputValue:string option) =
        match outputValue with
        | Some outputValue -> this.Output(state, outputName, outputValue)
        | None -> state
    member this.Output (state:ResourceGroupConfig, outputName:string, outputValue:ArmExpression option) =
        match outputValue with
        | Some outputValue -> this.Output(state, outputName, outputValue)
        | None -> state

    [<CustomOperation "outputs">]
    member __.Outputs (state, outputs) : ResourceGroupConfig =  { state with Outputs = Map.merge outputs state.Outputs }
    member this.Outputs (state:ResourceGroupConfig, outputs) = this.Outputs(state, outputs |> List.map(fun (k:string, ResourceName r) -> k,r))
    member this.Outputs (state:ResourceGroupConfig, outputs) = this.Outputs(state, outputs |> List.map(fun (k, a:ArmExpression) -> k,a.Eval()))

    /// Sets the default location of all resources.
    [<CustomOperation "location">]
    member _.Location (state, location) : ResourceGroupConfig = { state with Location = location }

    static member private AddResources(state:ResourceGroupConfig, resources:IArmResource list) =
        { state with
            Resources =
                state.Resources
                @ resources
                |> List.distinctBy(fun r -> r.ResourceId, r.GetType().Name) }

    /// Adds a builder's ARM resources to the ARM template.
    [<CustomOperation "add_resource">]
    member _.AddResource (state:ResourceGroupConfig, input:IBuilder) = DeploymentBuilder.AddResources(state, input.BuildResources state.Location)
    member _.AddResource (state:ResourceGroupConfig, input:Builder) = DeploymentBuilder.AddResources(state, input state.Location)
    member _.AddResource (state:ResourceGroupConfig, input:IArmResource) = DeploymentBuilder.AddResources(state, [ input ])
    member _.AddResource (state:ResourceGroupConfig, input:IBuilder option) = 
        match input with
        | Some inp -> DeploymentBuilder.AddResources(state, inp.BuildResources state.Location)
        | None -> state
    member _.AddResource (state:ResourceGroupConfig, input:Builder option) = 
        match input with
        | Some inp -> DeploymentBuilder.AddResources(state, inp state.Location)
        | None -> state
    member _.AddResource (state:ResourceGroupConfig, input:IArmResource option) = 
        match input with
        | Some inp -> DeploymentBuilder.AddResources(state, [ inp ])
        | None -> state

    [<CustomOperation "add_resources">]
    member this.AddResources(state:ResourceGroupConfig, input:IBuilder list) =
        let resources = input |> List.collect(fun i -> i.BuildResources state.Location)
        DeploymentBuilder.AddResources(state, resources)

    [<CustomOperation "add_arm_resources">]
    member this.AddArmResources(state:ResourceGroupConfig, input:IArmResource list) =
        DeploymentBuilder.AddResources(state, input)

    interface ITaggable<ResourceGroupConfig> with member _.Add state tags = {state with Tags = state.Tags |> Map.merge tags}
    interface IDependable<ResourceGroupConfig> with member _.Add state newDeps = { state with Dependencies = state.Dependencies + newDeps }

type ResourceGroupBuilder () =
    inherit DeploymentBuilder ()
    /// Creates an output value that will be returned by the ARM template.
    [<CustomOperation "name">]
    member _.SetName(state:ResourceGroupConfig, name) = { state with TargetResourceGroup = Some name }
    /// Creates an output value that will be returned by the ARM template.
    [<CustomOperation "deployment_name">]
    member _.SetDeploymentName(state:ResourceGroupConfig, name) = { state with DeploymentName = FixedValue name }
    /// Sets the subscription ID for a nested deployment
    [<CustomOperation "subscription_id">]
    member this.SubscriptionId(state:ResourceGroupConfig, subscriptionId:System.Guid) =
        { state with SubscriptionId = Some subscriptionId }
    member this.SubscriptionId(state:ResourceGroupConfig, subscriptionId:string) =
        { state with SubscriptionId = Some (System.Guid subscriptionId) }
    [<CustomOperation "add_parameter_values">]
    member this.AddParameterValues(state:ResourceGroupConfig, parameters:(string*string) list) =
        { state with ParameterValues = state.ParameterValues @ (parameters |> List.map ParameterValue) }
    [<CustomOperation "add_secret_references">]
    member this.AddKeyVaultSecretReferences(state:ResourceGroupConfig, parameters:(string*ResourceId*string) list) =
        { state with ParameterValues = state.ParameterValues @ (parameters |> List.map KeyVaultReference) }

let resourceGroup = ResourceGroupBuilder()

/// Creates a resource group in a subscription level deployment.
let createResourceGroup (name:string) (location:Location) : ResourceGroup =
    { Name = ResourceName name
      Location = location
      Dependencies = Set.empty
      Tags = Map.empty }
