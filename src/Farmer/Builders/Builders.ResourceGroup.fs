[<AutoOpen>]
module Farmer.Builders.ResourceGroup

open Farmer
open Farmer.Arm.ResourceGroup

type AutoGeneratable<'t> =
    private
    | FixedValue of 't
    | AutoGeneratedValue of 't option ref

    member this.GetValue generator =
        match this with
        | FixedValue v -> v
        | AutoGeneratedValue { contents = (Some v) } -> v
        | AutoGeneratedValue cell ->
            let v = generator ()
            cell := Some v
            v

module AutoGeneratable =
    let Manual value = FixedValue value

    let AutoGenerate<'t> () =
        AutoGeneratable<'t>.AutoGeneratedValue(ref None)


let deploymentIndex =
    let mutable index = 1000
    fun () -> System.Threading.Interlocked.Increment(&index)

type ResourceGroupConfig = {
    TargetResourceGroup: string Option
    DeploymentName: AutoGeneratable<string>
    Dependencies: ResourceId Set
    Parameters: string Set
    Outputs: Map<string, string>
    Location: Location
    Resources: IArmResource list
    ParameterValues: ParameterValue list
    SubscriptionId: System.Guid option
    Mode: DeploymentMode
    Tags: Map<string, string>
} with

    member private this.GenerateDeploymentName() =
        match this.TargetResourceGroup with
        | Some rg when rg.[0] = '[' ->
            // TargetResourceGroup can be an ARM expression when doing nested deployments such as when creating App-managed certificates in the WebApp builder.
            // Because the value is not known when we generate the template, we must use the ARM concat function to append a suffix to prevent deployment errors
            $"[concat({rg.Trim([| '['; ']' |])},'-deployment-{deploymentIndex ()}')]"
        | Some rg -> $"{rg}-deployment-{deploymentIndex ()}"
        | None -> $"deployment-{deploymentIndex ()}"

    member this.ResourceId = {
        resourceGroupDeployment.resourceId (this.DeploymentName.GetValue this.GenerateDeploymentName) with
            ResourceGroup = this.TargetResourceGroup
            Subscription = this.SubscriptionId |> Option.map string
    }

    member private this.ContentDeployment =
        if this.Parameters.IsEmpty && this.Outputs.IsEmpty && this.Resources.IsEmpty then
            None // this resource group has no content so there's nothing to deploy
        else
            let innerOutputs =
                this.Resources
                |> List.collect (function
                    | :? ResourceGroupDeployment as rg ->
                        Map.toList rg.Outputs
                        |> List.map fst
                        |> List.map (fun key ->
                            $"{rg.ResourceId.Name.Value}.{key}",
                            $"[reference('{rg.ResourceId.Name.Value}').outputs['{key}'].value]")
                    | _ -> [])
                |> Map.ofList

            {
                ResourceGroupDeployment.TargetResourceGroup =
                    this.TargetResourceGroup |> Option.defaultValue "farmer-deploy" |> ResourceName
                DeploymentName = this.ResourceId.Name
                Dependencies = this.Dependencies
                Outputs = Map.merge (Map.toList this.Outputs) innerOutputs // New values overwrite old values so supply this.Outputs as newValues
                Location = this.Location
                Resources = this.Resources
                ParameterValues = this.ParameterValues
                SubscriptionId = this.SubscriptionId
                Mode = this.Mode
                Tags = this.Tags
            }
            |> Some

    member this.Template =
        this.ContentDeployment
        |> Option.map (fun x -> x.Template)
        |> Option.defaultValue {
            Parameters = List.empty
            Outputs = List.empty
            Resources = List.empty
        }

    interface IDeploymentSource with
        member this.Deployment =
            let rec getPostDeployTasks (resources: IArmResource list) = [
                for resource in resources do
                    match resource with
                    | :? IPostDeploy as pd -> pd
                    | :? ResourceGroupDeployment as rgp -> yield! getPostDeployTasks rgp.Resources
                    | _ -> ()
            ]

            {
                Location = this.Location
                Template = this.Template
                PostDeployTasks = getPostDeployTasks this.Resources
                RequiredResourceGroups =
                    this.Resources
                    |> List.collect (function
                        | :? ResourceGroupDeployment as rg -> rg.RequiredResourceGroups
                        | _ -> [])
                Tags = this.Tags
            }

    interface IBuilder with
        member this.ResourceId = this.ResourceId

        member this.BuildResources loc = [
            match this.ContentDeployment with
            | Some x -> x
            | None -> ()
        ]

type DeploymentBuilder() =
    member _.Yield _ = {
        TargetResourceGroup = None
        DeploymentName = AutoGeneratable.AutoGenerate()
        Dependencies = Set.empty
        Parameters = Set.empty
        Outputs = Map.empty
        Resources = List.empty
        ParameterValues = List.empty
        SubscriptionId = None
        Location = Location.WestEurope
        Mode = Incremental
        Tags = Map.empty
    }

    /// Creates an output value that will be returned by the ARM template.
    [<CustomOperation "output">]
    member _.Output(state, outputName, outputValue) : ResourceGroupConfig = {
        state with
            Outputs = state.Outputs.Add(outputName, outputValue)
    }

    member this.Output(state: ResourceGroupConfig, outputName: string, (ResourceName outputValue)) =
        this.Output(state, outputName, outputValue)

    member this.Output(state: ResourceGroupConfig, outputName: string, outputValue: ArmExpression) =
        this.Output(state, outputName, outputValue.Eval())

    member this.Output(state: ResourceGroupConfig, outputName: string, outputValue: string option) =
        match outputValue with
        | Some outputValue -> this.Output(state, outputName, outputValue)
        | None -> state

    member this.Output(state: ResourceGroupConfig, outputName: string, outputValue: ArmExpression option) =
        match outputValue with
        | Some outputValue -> this.Output(state, outputName, outputValue)
        | None -> state

    [<CustomOperation "outputs">]
    member __.Outputs(state, outputs) : ResourceGroupConfig = {
        state with
            Outputs = Map.merge outputs state.Outputs
    }

    member this.Outputs(state: ResourceGroupConfig, outputs) =
        this.Outputs(state, outputs |> List.map (fun (k: string, ResourceName r) -> k, r))

    member this.Outputs(state: ResourceGroupConfig, outputs) =
        this.Outputs(state, outputs |> List.map (fun (k, a: ArmExpression) -> k, a.Eval()))

    /// Sets the default location of all resources.
    [<CustomOperation "location">]
    member _.Location(state, location) : ResourceGroupConfig = { state with Location = location }

    static member private AddResources(state: ResourceGroupConfig, resources: IArmResource list) = {
        state with
            Resources =
                state.Resources @ resources
                |> List.distinctBy (fun r -> r.ResourceId, r.GetType().Name)
    }

    /// Adds a builder's ARM resources to the ARM template.
    [<CustomOperation "add_resource">]
    member _.AddResource(state: ResourceGroupConfig, input: IBuilder) =
        DeploymentBuilder.AddResources(state, input.BuildResources state.Location)

    member _.AddResource(state: ResourceGroupConfig, input: Builder) =
        DeploymentBuilder.AddResources(state, input state.Location)

    member _.AddResource(state: ResourceGroupConfig, input: IArmResource) =
        DeploymentBuilder.AddResources(state, [ input ])

    member _.AddResource(state: ResourceGroupConfig, input: IBuilder option) =
        match input with
        | Some inp -> DeploymentBuilder.AddResources(state, inp.BuildResources state.Location)
        | None -> state

    member _.AddResource(state: ResourceGroupConfig, input: Builder option) =
        match input with
        | Some inp -> DeploymentBuilder.AddResources(state, inp state.Location)
        | None -> state

    member _.AddResource(state: ResourceGroupConfig, input: IArmResource option) =
        match input with
        | Some inp -> DeploymentBuilder.AddResources(state, [ inp ])
        | None -> state

    [<CustomOperation "add_resources">]
    member this.AddResources(state: ResourceGroupConfig, input: IBuilder list) =
        let resources = input |> List.collect (fun i -> i.BuildResources state.Location)
        DeploymentBuilder.AddResources(state, resources)

    [<CustomOperation "add_arm_resources">]
    member this.AddArmResources(state: ResourceGroupConfig, input: IArmResource list) =
        DeploymentBuilder.AddResources(state, input)

    interface ITaggable<ResourceGroupConfig> with
        member _.Add state tags = {
            state with
                Tags = state.Tags |> Map.merge tags
        }

    interface IDependable<ResourceGroupConfig> with
        member _.Add state newDeps = {
            state with
                Dependencies = state.Dependencies + newDeps
        }

type ResourceGroupBuilder() =
    inherit DeploymentBuilder()

    /// Creates an output value that will be returned by the ARM template.
    [<CustomOperation "name">]
    member _.SetName(state: ResourceGroupConfig, name) = {
        state with
            TargetResourceGroup = Some name
    }

    /// Creates an output value that will be returned by the ARM template.
    [<CustomOperation "deployment_name">]
    member _.SetDeploymentName(state: ResourceGroupConfig, name) = {
        state with
            DeploymentName = FixedValue name
    }

    /// Sets the subscription ID for a nested deployment
    [<CustomOperation "subscription_id">]
    member this.SubscriptionId(state: ResourceGroupConfig, subscriptionId: System.Guid) = {
        state with
            SubscriptionId = Some subscriptionId
    }

    member this.SubscriptionId(state: ResourceGroupConfig, subscriptionId: string) = {
        state with
            SubscriptionId = Some(System.Guid subscriptionId)
    }

    [<CustomOperation "add_parameter_values">]
    member this.AddParameterValues(state: ResourceGroupConfig, parameters: (string * string) list) = {
        state with
            ParameterValues = state.ParameterValues @ (parameters |> List.map ParameterValue)
    }

    [<CustomOperation "add_secret_references">]
    member this.AddKeyVaultSecretReferences
        (state: ResourceGroupConfig, parameters: (string * ResourceId * string) list)
        =
        {
            state with
                ParameterValues = state.ParameterValues @ (parameters |> List.map KeyVaultReference)
        }

let resourceGroup = ResourceGroupBuilder()

/// Creates a resource group in a subscription level deployment.
let createResourceGroup (name: string) (location: Location) : ResourceGroup = {
    Name = ResourceName name
    Location = location
    Dependencies = Set.empty
    Tags = Map.empty
}