[{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/aks-cluster/","title":"AKS Cluster","tags":[],"description":"","content":"Overview The AKS Cluster builder is used to create AKS clusters.\n Container Service (Microsoft.ContainerService/managedClusters)  AKS Builder Keywords The AKS Builder constructs AKS clusters.\n   Keyword Purpose     name Sets the name of the AKS cluster.   dns_prefix Sets the DNS prefix of the AKS cluster.   enable_rbac Enable Kubernetes Role-Based Access Control.   add_agent_pools Adds agent pools to the AKS cluster.   add_agent_pool Adds an agent pool to the AKS cluster.   add_identity Adds a managed identity to the the AKS cluster.   system_identity Activates the system identity of the AKS cluster.   network_profile Sets the network profile for the AKS cluster.   linux_profile Sets the linux profile for the AKS cluster.   service_principal_client_id Sets the client id of the service principal for the AKS cluster.   windows_username Sets the windows admin username for the AKS cluster.    Agent Pool Builder keywords The Agent Pool Builder constructs agent pools which are inserted into the AKS cluster.\n   Keyword Purpose     name Sets the name of the agent pool.   count Sets the count of VM\u0026rsquo;s in the agent pool.   user_mode Sets the agent pool to user mode.   disk_size Sets the disk size for the VM\u0026rsquo;s in the agent pool.   max_pods Sets the maximum number of pods in the agent pool.   os_type Sets the OS type of the VM\u0026rsquo;s in the agent pool.   subnet Sets the name of a virtual network subnet where this AKS cluster should be attached.   vm_size Sets the size of the VM\u0026rsquo;s in the agent pool.   vnet Sets the name of a virtual network in the same region where this AKS cluster should be attached.    CNI Builder The CNI builder helps create network profiles on the AKS cluster.\n   Keyword Purpose     docker_bridge Sets the docker bridge CIDR to a network other than the default 17.17.0.1/16.   dns_service Sets the DNS service IP - must be within the service CIDR, default is the second address in the service CIDR.   service_cidr Sets the service cidr to a network other than the default 10.224.0.0/16.    Example open Farmer open Farmer.Builders open Farmer.ContainerService let myAks = aks { name \u0026#34;k8s-cluster\u0026#34; dns_prefix \u0026#34;testaks\u0026#34; add_agent_pools [ agentPool { name \u0026#34;linuxPool\u0026#34; count 3 } ] linux_profile \u0026#34;aksuser\u0026#34; \u0026#34;public-key-here\u0026#34; service_principal_client_id \u0026#34;some-spn-client-id\u0026#34; network_profile ( azureCniNetworkProfile { service_cidr \u0026#34;10.250.0.0/16\u0026#34; } ) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/template-generation/","title":"Generating templates","tags":[],"description":"","content":"Farmer supports several ways to \u0026ldquo;output\u0026rdquo; ARM templates.\nGenerating JSON as a string You can generate an ARM template as a plain string:\nlet json = deployment.Template |\u0026gt; Writer.toJson // prints out the JSON  printfn \u0026#34;%s\u0026#34; json Writing to a file You can write out the ARM template directly to a file, from which you can then deploy to Azure using whichever mechanism you already use e.g. Azure CLI, Powershell, REST API etc.\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myTemplate\u0026#34; Notice how we use F#\u0026lsquo;s pipe operator to \u0026ldquo;pipe\u0026rdquo; data from the template configuration into json before writing to a file.\nIntegrated deployment to Azure You can also turn over deployment of the template directly to Farmer. In this case, it orchestrates commands to the Azure CLI as required.\nlet response = deployment |\u0026gt; Deploy.tryExecute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters match response with | Ok outputs -\u0026gt; printfn \u0026#34;Success! Outputs: %A\u0026#34; outputs | Error error -\u0026gt; printfn \u0026#34;Failed! %s\u0026#34; error As you can see, the response of calling tryExecute is a Result object which is either Ok, in which case any outputs returned from the template are made available as a Map\u0026lt;string, string\u0026gt;, or an Error, which is the error returned by the Azure CLI. Alternatively, you can call execute which will throw an exception rather than return a Result.\n You must have the Azure CLI installed on your machine in order for Farmer to perform deployments for you.\n Authenticating to Azure Azure CLI stores a login token on your machine, and Farmer will check for this. If you aren\u0026rsquo;t logged in, Farmer will automatically start the interactive Azure CLI login process for you.\nFor automated deployments e.g. continuous deployment or through scripts etc., you\u0026rsquo;ll want to use an unattended deployment mode. Some CI systems such as Azure Devops come with an pre-authenticated Azure CLI terminal from which you can run an application that uses Farmer. Alternatively, you can create a service principal, and supply them to the Deploy.authenticate function before calling Deploy.execute.\nYou should use a secure mechanism for storing and supplying the credentials to Farmer. Do not commit them into source control!\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/app-insights/","title":"App Insights","tags":[],"description":"","content":"Overview The App Insights builder is used to create Application Insights accounts. Use this if you need a standalone AI instance; if you need one for a web app, the web app will create one by default and configure the application settings automatically.\n Application Insights (Microsoft.Insights/components)  Builder Keywords    Keyword Purpose     name Sets the name of the App Insights instance.   disable_ip_masking Disable IP masking.   sampling_percentage Define sampling percentage (0-100)    Configuration Members    Member Purpose     InstrumentationKey Gets the ARM expression path to the instrumentation key of this App Insights instance.    Example open Farmer open Farmer.Builders let ai = appInsights { name \u0026#34;myAI\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/arm/","title":"ARM Deployment","tags":[],"description":"","content":"Overview The ARM deployment builder is always the top-level element of your deployment. It contains the manifest of all Farmer resources that you create.\nBuilder Keywords    Keyword Purpose     location Sets the default location of all resources.   add_resource Adds a resource to the template.   add_resources Adds a collection of resources to the template.   output Creates an output value that will be returned by the ARM template. Since Farmer does not require variables, and the only parameters supported are secure strings, these will typically be an ARM expressions that are generated at deployment-time, such as the publishing password of a web app or the fully-qualified domain name of a SQL instance etc.    Example let deployment = arm { // All resources will share this location  location Location.NorthEurope // Assume myStorageAccount and myWebApp have been defined...  add_resource myStorageAccount add_resource myWebApp output \u0026#34;webAppName\u0026#34; myWebApp.Name output \u0026#34;webAppPassword\u0026#34; myWebApp.PublishingPassword } "},{"uri":"https://compositionalit.github.io/farmer/about/","title":"About","tags":[],"description":"","content":"About Farmer Farmer is a .NET domain-specific-language (DSL) for rapidly generating Azure Resource Manager (ARM) templates. Farmer is commercially supported, open source and free-to-use.\nFor those of you working with Azure today, you may already be aware that one of the most useful features is the ability to generate entire infrastructure architectures as code via ARM Template files. These templates contain a declarative model that allows repeatable deployments and idempotent releases (among other things).\nWhat\u0026rsquo;s wrong with ARM? Unfortunately, ARM templates have some limitations caused by the fact that they must be authored in a verbose JSON dialect:\n They provide very limited type checking and support, which makes creating discovery and creation of template features difficult. Templates need a lot of boilerplate to be created for even relatively simple and common resources. It requires \u0026ldquo;embedded\u0026rdquo;, difficult-to-maintain stringly-typed code in order to achieve what might be trivial in a \u0026ldquo;proper\u0026rdquo; programming language, such as references, variables and parameters - or writing elements such as loops. The documentation for ARM templates is not always kept up-to-date, so understanding and learning how to properly use them can involve a lot of searching and trial-and-error.  In other words, whilst working with ARM templates that have already been created is relatively straightforward, the authoring of the templates themselves is time-consuming and error-prone.\nWhilst there have been some recent improvements to ARM - including tooling improvements in VS Code through an extension - we think that we can do much better than relying on tooling for a specific IDE, which means using something different than JSON when directly authoring ARM templates.\nWhat does Farmer do to fix this? Farmer templates are simple .NET Core applications which reference the Farmer NuGet package. This package contains a set of types that model Azure resources in a strongly-typed and succinct fashion, as well as functionality to create ARM templates from this model - and even deploy directly to Azure.\nWhat can I use Farmer for? Farmer currently has support for a large number of common resources including web apps, sql and storage, with more being added over time.\n"},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-1/","title":"Your first Farmer template","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll:\n create a web application with a fully-configured Application Insights instance create an ARM deployment object and assign the web app to it generate an ARM template  Creating a Farmer app Create an F# console application using the .NET SDK and add the Farmer package in an empty directory:\ndotnet new console -lang F# dotnet add package Farmer  Farmer also has a .NET template to get started even more quickly!\n Defining a Farmer web application Open Program.fs and delete all the contents.\n In Farmer, resources are defined using special code blocks that look somewhat json-esque, known as a \u0026ldquo;builder\u0026rdquo;. In these builders you can quickly and easily configure a resource using special keywords, but unlike json you also have edit-time safety.\n Create a Farmer web application using the webApp { } builder:\nopen Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } Create an ARM template deployment object, before setting the location for the overall resource group and adding the web app into it.\nlet deployment = arm { location Location.NorthEurope add_resource myWebApp } Generating the ARM template Now you need to generate the ARM template from the deployment object to an ARM json file.\nAdd the following code:\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; Run the application:\ndotnet run You should notice that the file myFirstTemplate.json has been created.\nThe generated ARM template contains the following resources:\n A web application A server farm An application insights instance  The resources will be correctly configured with the appropriate dependencies set.\nThe full application open Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } let deployment = arm { location Location.NorthEurope add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/1-the-farmer-pipline/","title":"1. The Farmer Pipeline","tags":[],"description":"","content":"This step will get you up and running by incorporate something quickly and easily into the Farmer pipeline that emits a valid Azure Container Registry.\nStep 1.1: Prototype and test using an fsx file Technically this step is not necessary but it is the quickest way to get a working deployment from which you can iterate upon.\nStart by looking at this sample and identifying the section of JSON that relates to the resource we want - in our case, the Microsoft.ContainerRegistry/registries resource.\n In VSCode, the use of #r \u0026quot;nuget:...\u0026quot; syntax can be enabled by going to Settings \u0026gt; F# \u0026gt; Fsi Extra Parameters and adding --langversion:preview to the FSharp.fsiExtraParameters list (.NET 5 only). VS2019 and Rider already support this feature natively. If you are not using .NET 5, manually build Farmer and reference the dll manually - see the samples folder for examples.\n // container-registry-prototype.fsx #r \u0026#34;nuget: farmer\u0026#34; open Farmer // A function called \u0026#34;registries\u0026#34; that takes in a name, sku and boolean flag for whether to enable the admin user. let registries name sku adminUserEnabled = $\u0026#34;\u0026#34;\u0026#34;{{ \u0026#34;name\u0026#34;: \u0026#34;{name}\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westeurope\u0026#34;, \u0026#34;tags\u0026#34;: {{ }}, \u0026#34;sku\u0026#34;: {{ \u0026#34;name\u0026#34;: \u0026#34;{sku}\u0026#34; }}, \u0026#34;properties\u0026#34;: {{ \u0026#34;adminUserEnabled\u0026#34;: %b{adminUserEnabled} }} }}\u0026#34;\u0026#34;\u0026#34; |\u0026gt; Resource.ofJson let deployment = arm { location Location.NorthEurope add_resource (registries \u0026#34;my-registry\u0026#34; \u0026#34;Basic\u0026#34; true) } deployment |\u0026gt; Writer.quickWrite \u0026#34;/test-output\u0026#34; // or push out for real to Azure!  // deployment // |\u0026gt; Deploy.execute \u0026#34;FarmerTest\u0026#34; Deploy.NoParameters // |\u0026gt; printfn \u0026#34;%A\u0026#34; Observe how we\u0026rsquo;ve pasted a minimal section of JSON and then tried to extract some of the candidates for parameterisation - in our case name, sku and adminUserEnabled, and how we\u0026rsquo;ve used the Resource.ofJson function to create an IArmResource for us to quickly allow us \u0026ldquo;into\u0026rdquo; the Farmer pipeline.\nTest out the JSON model you created and make sure it creates the resources in Azure you would expect. You can deploy with execute or you can use whatIf to see what the expected state would be.\nStep 1.2: Convert from JSON to an F# anonymous record For simple ARM resources, raw JSON may suffice, but normally you\u0026rsquo;ll want a little more control in order to programmatically choose whether to add / remove fields etc. during the export phase. The best way to do this is to replace the raw string export with an anonymous record:\nlet registries (name:string) (sku:string) (adminUserEnabled:bool) = {| name = name ``type`` = \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; apiVersion = \u0026#34;2019-05-01\u0026#34; location = \u0026#34;westeurope\u0026#34; tags = {| |} sku = {| name = sku |} properties = {| adminUserEnabled = adminUserEnabled |} |} |\u0026gt; Resource.ofObj Notice how the structure is the same, but is now implemented directly in F#.\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/arm-basics/","title":"ARM Basics","tags":[],"description":"","content":" Skip this section if you are already familiar with ARM Templates\n This won\u0026rsquo;t be an introduction to Azure Resource Manager or ARM templates. Instead let\u0026rsquo;s go through the main parts that are important for creating a new resource.\nThe main parts of ARM Templates can be broken into resources, outputs, variables, and parameters. Farmer has limited support for parameters and no support for variables, so we will not cover them.\nSo a generated ARM Template from Farmer will have the following structure.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#\u0026#34;, \u0026#34;contentVersion\u0026#34;: \u0026#34;1.0.0.0\u0026#34;, \u0026#34;outputs\u0026#34;: {}, \u0026#34;parameters\u0026#34;: {}, \u0026#34;resources\u0026#34;: [] } When building a new resource in Farmer you are providing the means for a user of Farmer to generate a new resource type, or configure a new property on an existing resource. These resources are added by Farmer to the resources array you can see above.\nWhen building up a resource it will have a schema that looks something like this.\n{ \u0026#34;name\u0026#34;: \u0026#34;my-example-resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westeurope\u0026#34;, \u0026#34;tags\u0026#34;: {}, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;S1\u0026#34; }, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: true, }, \u0026#34;resources\u0026#34;: [] } Your resource you create will have a type of service that it represents. Each service has many versions, represented by a date. Typically your builder will at first focus on adding properties to the properties field to configure a service to be deployed in a certain state.\nWhere can I find docs on ARM templates schemas themselves? There are three good sources to learning about specific ARM resources and what parts need to be used in creating an equivalent Farmer resource:\n Reference Docs: The reference documentation contains details on the schema for every resource and every version e.g. Container Registry reference. Sample Template: The Azure Quickstart Templates github repository contains many examples of real-world ARM templates e.g. Container Registry with Geo Replication sample. Reverse engineer: You can manually create a required resource in Azure, and then use Azure\u0026rsquo;s export ARM template functionality to create an ARM template. It\u0026rsquo;s important that you test out the exported template yourself before porting it to Farmer, because Azure sometimes exports invalid templates!  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/bing-search/","title":"Bing Search","tags":[],"description":"","content":"Overview The Bing Search builder is used to create Azure Bing Search instances.\n Bing Search (Microsoft.Bing/accounts, kind: Bing.Search.v7)  Builder Keywords    Keyword Purpose     name Sets the name of the Bing Search instance.   sku Sets the SKU of the instance. Defaults to F1 (free).   statistics Sets the statisticsEnabled property of the instance. Defaults to false    Configuration Members    Member Purpose     Key Gets the ARM expression path to the Key of this Bing Search instance.    Example open Farmer open Farmer.Builders let tags = [ \u0026#34;a\u0026#34;, \u0026#34;1\u0026#34;; \u0026#34;b\u0026#34;, \u0026#34;2\u0026#34; ] let translator = bingSearch { name \u0026#34;test\u0026#34; sku S0 add_tags tags statistics Enabled } let key : ArmExpression = translator.Key "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/bastion-host/","title":"Bastion Host","tags":[],"description":"","content":"Overview The Bastion Host builder creates a bastion host to access resources inside a virtual network. It also creates a static public IP for the bastion host.\n BastionHosts (Microsoft.Network/bastionHosts)  Builder Keywords    Applies To Keyword Purpose     BastionHost vnet Name of the virtual network the bastion host can access    Example #r @\u0026#34;./libs/Newtonsoft.Json.dll\u0026#34; #r @\u0026#34;../../src/Farmer/bin/Debug/netstandard2.0/Farmer.dll\u0026#34; open Farmer open Farmer.Builders arm { location Location.EastUS add_resources [ vnet { name \u0026#34;private-network\u0026#34; add_address_spaces [ \u0026#34;10.1.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;default\u0026#34; prefix \u0026#34;10.1.0.0/24\u0026#34; } subnet { name \u0026#34;AzureBastionSubnet\u0026#34; prefix \u0026#34;10.1.250.0/27\u0026#34; } ] } bastion { name \u0026#34;my-bastion-host\u0026#34; vnet \u0026#34;private-network\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/contributing/outputs-and-expressions/","title":"Outputs and ARM Expressions","tags":[],"description":"","content":"Outputs can be created in Farmer for any ARM Expression, Resource Name or any optional string. ARM Expressions are most useful in this case for referring to values that only exist at deployment time, such as connection strings.\n Creating ARM Expressions Farmer ARM expressions are in reality just wrapped strings, and are easy to create. For example, the code to create a Storage Key property is similar to this:\nlet buildKey accountName : ArmExpression = // Create the raw string of the expression  let rawValue = $\u0026#34;concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName={accountName};AccountKey=\u0026#39;, listKeys(\u0026#39;{accountName}\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)\u0026#34; // Wrap the raw value in an ARM Expression and return it  ArmExpression rawValue Notice that you do not wrap the expression in square brackets [ ]; Farmer will do this when writing out the ARM template.\nExtracting the value of an ARM Expression ARM expressions also have the following members on them:\n Map - standard map Bind - standard bind Value - Returns the raw string value Eval - Returns the string as a formatted ARM expression i.e. surround in []  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/expressions/","title":"ARM Expressions","tags":[],"description":"","content":"ARM template expressions are a way of safely storing string values which contain expressions that are evaluated at deployment time by the Azure. ARM expressions can also contain a set of predefined functions supported by the ARM runtime. They can be passed back as outputs and used further downstream\nFarmer understands how to use ARM expressions and provides functionality to correctly wrap and unwrap them as raw strings into a JSON template.\n For manipulation of literal values that are known in your Farmer applications, you will not need to use ARM expressions. To manipulate such values, you can use standard F# and .NET capabilities.\n How do I use ARM expressions? Many Farmer builders contain pre-defined ARM expression that can be used for common tasks, such as passing a connection string from a storage account as a KeyVault secret, or a web application setting.\nAs an example, a Storage Account config contains a Key member that you can supply this to a web app as a setting:\nlet storageConfig = storageAccount { name \u0026#34;myStorageAccount\u0026#34; } let webAppConfig = webApp { name \u0026#34;myWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; storageConfig.Key } This will be written to the ARM template file as follows:\n\u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=myStorageAccount;AccountKey=\u0026#39;, listKeys(\u0026#39;myStorageAccount\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } Using ARM expressions means that you can deploy an application which is automatically configured at deployment time. This means that you never need to store an application secret such as a storage account key in source control, or even e.g. as a secret variable in your build / deployment process.\nReturning the value of ARM Expressions as outputs. ARM Expressions can also be passed back as outputs and used further downstream once your deployment is complete:\nlet template = arm { location Location.WestEurope add_resource storageConfig // Mark the storage_key as an output in the ARM template.  output \u0026#34;storage_key\u0026#34; storageConfig.Key } // Deploy the template. let outputs = template |\u0026gt; Deploy.execute template [] // Get the value of the storage_key. let key = outputs.[\u0026#34;storage_key\u0026#34;] Be aware though, that the value of the storage_key is visible as a plain text value in the output - so anyone with access to, for example, the Azure portal will be able to see the values of the storage key if they look at the deployment history.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/parameters/","title":"Parameters and Variables","tags":[],"description":"","content":"ARM templates support the idea both of parameterisation of templates and of the use of variables within a template for e.g. placeholders and re-using values.\nFarmer, by design, has only limited support for parameters and no support for variables. We don\u0026rsquo;t plan on adding rich support for either of these for the following reasons:\n We want to keep the Farmer codebase simple for maintainers We want to keep the Farmer API simple for users We want to keep the generated ARM templates as readable as possible We feel that instead of trying to embed conditional logic and program flow directly inside ARM templates in JSON, if you wish to parameterise your template that you should use a real programming language to do that: in this case, F#.  You can read more on this issue here\nSecure Parameters Farmer does support securestring parameters for e.g. SQL and Virtual Machine passwords - these are automatically generated based on the contents of the template rather than explicitly by yourself.\nFor example, assume the following Farmer SQL resource:\nlet db = sql { server_name \u0026#34;myserver\u0026#34; db_name \u0026#34;mydatabase\u0026#34; admin_username \u0026#34;mradmin\u0026#34; } This will generate an ARM template which looks as follows (irrelevant content is elided for clarity):\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;password-for-myserver\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;securestring\u0026#34; } }, \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2014-04-01-preview\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;myserver\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;administratorLogin\u0026#34;: \u0026#34;mradmin\u0026#34;, \u0026#34;administratorLoginPassword\u0026#34;: \u0026#34;[parameters(\u0026#39;password-for-myserver\u0026#39;)]\u0026#34;, }, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Sql/servers\u0026#34; } ] } Working with variables ARM templates allow you to declare variables inside a template to reuse a value across a template. ARM templates also allow the use of a custom set of a commands which are embedded within strings to generate program logic, using expressions which contain template functions. For example, to concatenate a string inside a ARM template made up of two variables and put into a third variable, you might use something like the following:\n{ \u0026#34;variables\u0026#34;: { \u0026#34;first\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;second\u0026#34;: \u0026#34;World\u0026#34;, \u0026#34;serverName\u0026#34;: \u0026#34;[concat(variables(\u0026#39;first\u0026#39;), \u0026#39; \u0026#39;, variables(\u0026#39;second\u0026#39;), \u0026#39;!\u0026#39;)]\u0026#34; } } In F#, you have access to the full power of .NET, rather than a limited set of weakly-typed functions:\nlet first = \u0026#34;Hello\u0026#34; let second = \u0026#34;World\u0026#34; let serverName = first + \u0026#34; \u0026#34; + second + \u0026#34;!\u0026#34; let dbName = $\u0026#34;{first} {second}!\u0026#34; let db = sql { server_name serverName db_name dbName admin_username \u0026#34;mradmin\u0026#34; } Rapidly creating multiple resources You can also use F# list comprehensions to rapidly create several resources of the same type:\n// Create five SQL servers and databases let myDatabases = [ for i in 1 .. 5 -\u0026gt; sql { server_name $\u0026#34;server{i}\u0026#34; db_name $\u0026#34;database{i}\u0026#34; admin_username \u0026#34;mradmin\u0026#34; } ] // Add all five databases to the deployment let deployment = arm { location Location.NorthEurope add_resources myDatabases } "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-2/","title":"Working with multiple resources","tags":[],"description":"","content":"Introduction In this quickstart, you\u0026rsquo;ll expand on the deployment authored in the previous quickstart as follows:\n add an Azure storage account add an application setting to the web app that references the storage account\u0026rsquo;s key set a dependency between the two resources  Creating a storage account Create a storage account by using the storageAccount builder.\nlet myStorage = storageAccount { name \u0026#34;yourfirststorage\u0026#34; }  Azure Storage Account names must be globally unique and between 3-24 alphanumeric lower-case characters!\n Referencing the storage account in the web app In this section, we will add an app setting to the web app and set the value to the storage account\u0026rsquo;s connection string.\n In F#, you need to define a value before you reference it, so make sure that you define the storage account above the web app.\n Add the storage account\u0026rsquo;s connection key to the webapp as an app setting.\nlet myWebApp = webApp { ... setting \u0026#34;storageKey\u0026#34; myStorage.Key } If you\u0026rsquo;re coming from a raw ARM template background, don\u0026rsquo;t worry about the need to set dependencies between the Storage Account and Web App - Farmer will automatically do this for you!\n Settings can be strings or (as in this case) an ARM expression, which is evaluated at deployment time.\n Adding the storage account to the deployment Add the storage account to the deployment using the same add_resource keyword as you did with myWebApp.\nAnalysing the ARM template Run the application:\ndotnet run You should notice that the template now contains a storage account. Also observe the dependency that has been created:\n{ \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2020-06-01\u0026#34;, \u0026#34;dependsOn\u0026#34;: [ \u0026#34;[resourceId(\u0026#39;Microsoft.Storage/storageAccounts\u0026#39;, \u0026#39;yourfirststorage\u0026#39;)]\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Web/sites\u0026#34; } ] } Also observe the application setting that has been created:\n{ \u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=yourfirststorage;AccountKey=\u0026#39;, listKeys(\u0026#39;yourfirststorage\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } ] } The full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorage\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/","title":"Quickstarts","tags":[],"description":"","content":"This section contains quickstarts to performing common tasks.\n Creating your first Farmer template Creating multiple resources Deploying to Azure The Farmer .NET Template  "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/2-iarm-resource/","title":"2. The IArmResource","tags":[],"description":"","content":"In this exercise, we\u0026rsquo;ll migrate our code from the previous step directly into the Farmer codebase.\nStep 2.1: Migrating to IArmResource Now that you know that your resource model produces the correct Json value when passed into Farmer, we can now create a proper type that contains the \u0026ldquo;parameterised\u0026rdquo; parts of the above function, such as name, sku and adminUserEnabled, and properly takes part in the Farmer pipeline, by implementing the IArmResource interface. This type is normally a full Record and should use types as required to capture e.g. SKUs or other elements that would benefit from typing (in the example above, sku is a string, but we will shortly replace that with a union type).\n// src/Farmer/Arm/ContainerRegistry.fs [\u0026lt;AutoOpen\u0026gt;] module Farmer.Arm.ContainerRegistry open Farmer // Create a reference to the full ARM registries type and version. let registries = ResourceType (\u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;2019-05-01\u0026#34;) // Temporarily define the SKU and other types alongside the IArmResource. type Sku = | Basic | Standard | Premium type Registries = { Name : ResourceName Location : Location Sku : Sku AdminUserEnabled : bool } interface IArmResource with member this.ResourceId = registries.resourceId this.Name member this.JsonModel = {| name = this.Name.Value ``type`` = \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; apiVersion = \u0026#34;2019-05-01\u0026#34; sku = {| name = this.Sku.ToString() |} location = this.Location.ArmValue tags = {||} properties = {| adminUserEnabled = this.AdminUserEnabled |} |} :\u0026gt; _ // upcast to obj Notice how we perform simple \u0026ldquo;serialization\u0026rdquo; of elements such as the SKU, but otherwise most fields are just copied across.\nThe biggest difference is that we have now also introduced the notion of ResourceType and ResourceId. A ResourceType allows you to specify the versioned ARM type that your resource implements; a ResourceId represents the qualified path to a specific, named resource. It contains at least the resource\u0026rsquo;s type and its name, but can also optionally include e.g. the resource group that the resource belongs to.\nStep 2.2: Generating the ARM values more quickly Because most ARM resources have a set of fields that are commonly used e.g. name, location etc., Farmer comes with a helper factory function to construct ARM JSON objects quickly and easily. Here\u0026rsquo;s a shortened version of JsonModel above:\n{| registries.Create(this.Name, this.Location) with sku = {| name = this.Sku.ToString() |} properties = {| adminUserEnabled = this.AdminUserEnabled |} |} :\u0026gt; _ // upcast to obj Now, the common fields will be generated for us through the registies.Create function; any custom fields (such as sku and properties) are then applied on top.\nStep 2.3: Move domain types out of the IArmBuilder.  You can skip this step if you\u0026rsquo;re just experimenting in e.g. a script.\n For now, we\u0026rsquo;ve created any associated types such as Sku directly above the file, but you\u0026rsquo;ll want to migrate these to a Farmer.ContainerRegistry module in Common.fs afterwards e.g.\n// src/Farmer/Common.fs namespace Farmer module ContainerRegistry = type Sku = | Basic | Standard | Premium Step 2.4: Test out the new Registries record in Farmer. You can test this again easily by passing an instance into a Farmer deployment like we did in the previous step:\nopen Farmer.Arm.ContainerRegistry let registries = { Name = ResourceName \u0026#34;my-registry\u0026#34; Location = Location.WestEurope Sku = ContainerRegistry.Basic AdminUserEnabled = true } let deployment = arm { location Location.NorthEurope add_resource registries } deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34;  Note that F# records must be completely filled at creation, so you must provide values for all four fields.\n You could now write a test to assert the Json structure. Most tests in the project though tend to test from the Farmer builders, which we will get to soon. You can stop right here if you want - what you\u0026rsquo;ve done so far allows you to create IArmResource objects which can be added to the Farmer pipeline. However, we will go further in the next exericse and make it even easier to create Container Registries by creating an IBuilder.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/","title":"Tutorials","tags":[],"description":"","content":"This section contains tutorials for specific use-cases. Use these to help get ideas for how to model your Farmer resources!\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/dependencies/","title":"Dependencies","tags":[],"description":"","content":"ARM resources can depend on one another, and Farmer caters for this as well. Dependencies guarantee that when resources are created, Azure will provision them in the correct order so that e.g. a storage account is created before Azure tries to grab the storage account key / connection string for your web app setting.\nMuch of this work is done for you:\n Farmer creates multiple resources for you at the builder level, and will ensure that the appropriate dependencies are set for you - for example, when creating a SQL Azure instance, Farmer will automatically ensure that the database depends on the server. Farmer will generally identify dependencies correctly when you have a relationship between builders, such as setting the key of a storage account on a web app.  Automatic dependency detection In the sample below, the web app { } will automatically realise that it needs to depend on Storage Account based on the \u0026ldquo;owner\u0026rdquo; of Key expression that is supplied.\nlet myStorage = storageAccount { name \u0026#34;sampleaccount\u0026#34; } let myApp = webApp { name \u0026#34;myapp\u0026#34; setting \u0026#34;storage_key\u0026#34; myStorage.Key } Manually setting dependencies Normally, Farmer will do everything you need. However, there are some times when you may need to explicitly set a dependency:\n Farmer has not automatically detected the dependencies (please raise an issue if you notice this!). You\u0026rsquo;re setting a dependency on a resource that you\u0026rsquo;re creating yourself, outside of Farmer. You want to set a dependency even though there is no explicit coupling between two resources / builders.  Setting a dependency requires you to call the depends_on keyword on the target resource, providing a handle to the dependent resource.\nlet myStorage1 = storageAccount { name \u0026#34;sampleaccountFirst\u0026#34; } let myApp = webApp { name \u0026#34;myapp\u0026#34; depends_on myStorage1 } Here, we set up an explicit dependency on myApp for myStorage.\nAdding multiple dependencies at once You can also supply multiple dependencies at once as a list; this is useful if you are programmatically creating multiple resources.\n// Create five storage accounts let storageAccounts : IBuilder list = [ for letter in [ \u0026#39;a\u0026#39; .. \u0026#39;e\u0026#39; ] do storageAccount { name $\u0026#34;mystorage{letter}\u0026#34; } ] let myApp = webApp { name \u0026#34;myapp\u0026#34; depends_on storageAccounts // add them all to the web app as dependencies } Notice the extra type hint, : IBuilder list. This is required because F# does not, by default, allow you to implicitly treat a list of values as a supertype. In this case, a StorageAccountConfig list is not considered implicitly convertable to : IBuilder list (which is an interface that StorageAccountConfig implements). Therefore, we have to do it ourselves using the extra type declaration.\nYou can also use the :\u0026gt; (safe upcast) operator when declaring the StorageAccount:\nlet storageAccounts = [ // inferred as IBuilder list  for letter in [ \u0026#39;a\u0026#39; .. \u0026#39;e\u0026#39; ] do storageAccount { name $\u0026#34;mystorage%c\u0026#34; letter) } :\u0026gt; IBuilder ]  We\u0026rsquo;re looking at improving this situation in the future using F#\u0026lsquo;s \u0026ldquo;flexible types\u0026rdquo; feature.\n All builders that support dependencies support a number of depends_on overloads:\n A single, or a list of, Builders (as shown above) A single, or a list of, resources by their Name A single, or a list of, IArmResources  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/outputs/","title":"Outputs","tags":[],"description":"","content":"ARM templates also support the notion of outputs. Outputs can be used to provide your Farmer applications with values which were generated during the deployment process, to be used further downstream.\nFor example, you may wish to prime an Azure storage account with data post-creation. In this case, one way is to return back out the connection string of the storage account and use that to connect and upload your data.\nCreating and Consuming outputs Outputs are applied onto the arm { } builder using the output keyword.\nlet myStorage = storageAccount { name \u0026#34;sampleaccount\u0026#34; } let template = arm { add_resource myStorage output \u0026#34;storage_key\u0026#34; myStorage.Key } let outputs = template |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [] let connectionString = outputs.[\u0026#34;storage_key\u0026#34;] Outputs are returned back from the deployment as a simple Map\u0026lt;string, string\u0026gt;.\nAny ARM expression can be returned as an output, and you can create as many outputs as you wish.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-group/","title":"Container Group","tags":[],"description":"","content":"Overview The Container Group builder is used to create Azure Container Group instances.\n Container Group (Microsoft.ContainerInstance/containerGroups) Network Profile (Microsoft.Network/networkProfiles)  Builder Keywords    Applies To Keyword Purpose     containerInstance name Sets the name of the container instance.   containerInstance image Sets the container image.   containerInstance command Sets the commands to execute within the container instance in exec form.   containerInstance add_ports Sets the ports the container exposes.   containerInstance cpu_cores Sets the maximum CPU cores the container may use.   containerInstance memory Sets the maximum gigabytes of memory the container may use.   containerInstance env_vars Sets a list of environment variables for the container.   containerInstance add_volume_mount Adds a volume mount on a container from a volume in the container group.   containerInstance probes Adds liveliness and readiness probes to a container.   initContainer name Sets the name of the init container.   initContainer image Sets the init container image.   initContainer command Sets the commands to execute within the init container in exec form.   initContainer env_vars Sets a list of environment variables for the init container.   initContainer add_volume_mount Adds a volume mount on an init container from a volume in the container group.   containerGroup name Sets the name of the container group.   containerGroup add_instances Adds container instances to the group.   containerGroup operating_system Sets the OS type (default Linux).   containerGroup restart_policy Sets the restart policy (default Always)   containerGroup public_dns Sets the DNS host label when using a public IP.   containerGroup private_ip Indicates the container should use a system-assigned private IP address for use in a virtual network.   containerGroup network_profile Name of a network profile resource for the subnet in a virtual network where the container group will attach.   containerGroup add_identity Adds a managed identity to the the container group.   containerGroup system_identity Activates the system identity of the container group.   containerGroup add_registry_credentials Adds a container image registry credential with a secure parameter for the password.   containerGroup add_tcp_port Adds a TCP port to be externally accessible.   containerGroup add_udp_port Adds a UDP port to be externally accessible.   containerGroup add_volumes Adds volumes to a container group so they are accessible to containers.   liveliness http Sets the http GET URI on a container liveliness check.   liveliness exec Sets a command to execute on a container liveliness check.   liveliness initial_delay_seconds Sets a delay after container startup before the first check - default is 0 seconds.   liveliness period_seconds Sets the period between running checks - default is 10 seconds.   liveliness failure_threshold Sets the number of times a check can fail before the container is considered unhealthy and will be restarted - default is 3.   liveliness success_threshold Sets the number of times a check must succeed before the container is considered healthy - default is 1.   liveliness timeout_seconds Sets the number of seconds a check is allowed to run before considering the check a failure - default is 1 second.   readiness http Sets the http GET URI on a container readiness check.   readiness exec Sets a command to execute on a container readiness check.   readiness initial_delay_seconds Sets a delay after container startup before the readiness check - default is 0 seconds.   readiness period_seconds Sets the period between running checks - default is 10 seconds.   readiness failure_threshold Sets the number of times a check can fail before the container is considered unhealthy and will be restarted - default is 3.   readiness success_threshold Sets the number of times a check must succeed before the container is considered healthy - default is 1.   readiness timeout_seconds Sets the number of seconds a check is allowed to run before considering the check a failure - default is 1 second.   networkProfile name Name of the container network profile for connecting a container group to a virtual network.   networkProfile vnet Resource name of the virtual network to connect (if created in the same deployment).   networkProfile link_to_vnet Resource name of an existing virtual network to connect.   networkProfile subnet Name of the subnet in the virtual network where the container group should attach.    Example open Farmer open Farmer.Builders open Farmer.ContainerGroup let nginx = containerInstance { name \u0026#34;nginx\u0026#34; image \u0026#34;nginx:1.17.6-alpine\u0026#34; add_ports PublicPort [ 80us; 443us ] add_ports InternalPort [ 9090us; ] memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 1 env_vars [ env_var \u0026#34;CONTENT_PATH\u0026#34; \u0026#34;/www\u0026#34; secure_env_var \u0026#34;SECRET_PASSWORD\u0026#34; \u0026#34;shhhhhh!\u0026#34; ] add_volume_mount \u0026#34;secret-files\u0026#34; \u0026#34;/config/secrets\u0026#34; add_volume_mount \u0026#34;source-code\u0026#34; \u0026#34;/src/farmer\u0026#34; probes [ liveliness { http \u0026#34;http://localhost:80/\u0026#34; initial_delay_seconds 15 } ] } let containerGroupUser = userAssignedIdentity { name \u0026#34;aciUser\u0026#34; } let group = containerGroup { name \u0026#34;webApp\u0026#34; operating_system Linux restart_policy AlwaysRestart add_identity containerGroupUser add_udp_port 123us add_instances [ nginx ] add_registry_credentials [ registry \u0026#34;mygregistry.azurecr.io\u0026#34; \u0026#34;registryuser\u0026#34; ] add_volumes [ volume_mount.secret_string \u0026#34;secret-files\u0026#34; \u0026#34;secret1\u0026#34; \u0026#34;abcdefg\u0026#34; volume_mount.git_repo \u0026#34;source-code\u0026#34; (Uri \u0026#34;https://github.com/CompositionalIT/farmer\u0026#34;) ] } Private Virtual Network Example Attaching a container group to a virtual network requires adding a service delegation on a subnet indicating it is for container groups, adding a network profile to bind the container group interface to that subnet, and finally adding the container group itself with a private IP address.\nopen Farmer open Farmer.Builders let privateNetwork = vnet { name \u0026#34;private-vnet\u0026#34; add_address_spaces [ \u0026#34;10.30.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;ContainerSubnet\u0026#34; prefix \u0026#34;10.30.19.0/24\u0026#34; add_delegations [ SubnetDelegationService.ContainerGroups ] } ] } let aciProfile = networkProfile { name \u0026#34;vnet-aci-profile\u0026#34; vnet \u0026#34;private-vnet\u0026#34; subnet \u0026#34;ContainerSubnet\u0026#34; } let myContainer = container { name \u0026#34;helloworld\u0026#34; image \u0026#34;microsoft/aci-helloworld\u0026#34; add_ports PublicPort [ 80us ] } let group = containerGroup { name \u0026#34;webApp\u0026#34; operating_system Linux restart_policy AlwaysRestart add_instances [ myContainer ] network_profile \u0026#34;vnet-aci-profile\u0026#34; private_ip [TCP, 80us] } Execute container command example Modified from azure-cli example here: https://docs.microsoft.com/en-us/azure/container-instances/container-instances-start-command\nopen Farmer open Farmer.Builders open Farmer.ContainerGroup let wordcount = containerInstance { name \u0026#34;mycontainer1\u0026#34; image \u0026#34;mcr.microsoft.com/azuredocs/aci-wordcount:latest\u0026#34; memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 1 env_vars [ env_var \u0026#34;NumWords\u0026#34; \u0026#34;3\u0026#34; env_var \u0026#34;MinLength\u0026#34; \u0026#34;5\u0026#34; ] command_line [ \u0026#34;python\u0026#34;; \u0026#34;wordcount.py\u0026#34;; \u0026#34;http://shakespeare.mit.edu/romeo_juliet/full.html\u0026#34; ] } let group = containerGroup { name \u0026#34;wordcount\u0026#34; operating_system Linux restart_policy RestartOnFailure add_instances [ wordcount ] } Using an initContainer on startup An initContainer will run on container group startup before any of the containers are executed.\nIf there are any issues with the initContainer, it will remain in a \u0026lsquo;Creating\u0026rsquo; state indefinitely. Check for issues by viewing the logs for the init container(s):\naz container logs -g resource-group-name -n container-group-name --container-name init-container-name\nThe example below creates a volume mount that is shared between the initContainer and the container instances. It writes to a file so that the nginx container can serve that file once the group is running.\narm { location Location.WestEurope add_resources [ containerGroup { name \u0026#34;container-group-with-init\u0026#34; operating_system Linux restart_policy ContainerGroup.AlwaysRestart add_volumes [ volume_mount.empty_dir \u0026#34;html\u0026#34; ] add_init_containers [ initContainer { name \u0026#34;write-index-file\u0026#34; image \u0026#34;debian\u0026#34; add_volume_mount \u0026#34;html\u0026#34; \u0026#34;/usr/share/nginx/html\u0026#34; command_line [ \u0026#34;/bin/sh\u0026#34; \u0026#34;-c\u0026#34; \u0026#34;mkdir -p /usr/share/nginx/html \u0026amp;\u0026amp; echo \u0026#39;hello there\u0026#39; \u0026gt;\u0026gt; /usr/share/nginx/html/index.html\u0026#34; ] } ] add_instances [ containerInstance { name \u0026#34;nginx\u0026#34; image \u0026#34;nginx:alpine\u0026#34; add_volume_mount \u0026#34;html\u0026#34; \u0026#34;/usr/share/nginx/html\u0026#34; add_public_ports [ 80us; 443us ] memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 0.2 } ] } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-registry/","title":"Container Registry","tags":[],"description":"","content":"Overview The Container Registry builder is used to create Azure Container Registry (ACR) instances.\n Container Registry (Microsoft.ContainerRegistry/registries)  Builder Keywords    Keyword Purpose     name Sets the name of the Container Registry instance.   sku Sets the SKU of the instance. Defaults to Basic.   enable_admin_user The value that indicates whether the admin user is enabled.    Configuration Members    Member Purpose     Password Gets the ARM expression path to the first admin password of this container registry if admin user was enabled.   Password2 Gets the ARM expression path to the second admin password of this container registry if admin user was enabled.   Username Gets the ARM expression path to the admin username of this container registry if admin user was enabled.    Example open Farmer open Farmer.Builders let myRegistry = containerRegistry { name \u0026#34;myRegistry\u0026#34; sku ContainerRegistry.Basic enable_admin_user } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cognitive-services/","title":"Cognitive Services","tags":[],"description":"","content":"Overview The Cognitive Services builder is used to create Azure Cognitive Services instances.\n Cognitive Services (Microsoft.CognitiveServices/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Cognitive Services instance.   sku Sets the SKU of the instance. Defaults to F0 (free).   api Specifies the Kind of api to use for the service instance. Defaults to AllInOne.    Configuration Members    Member Purpose     Key Gets the ARM expression path to the Key of this Cognitive Services instance.    Example open Farmer open Farmer.Builders let translator = cognitiveServices { name \u0026#34;mytranslator\u0026#34; sku CognitiveServices.F0 api CognitiveServices.AnomalyDetector } let key : ArmExpression = translator.Key BingSearch (obsolete) Starting from 1.4.0 BingSearch api is available as a part of bingSearch builder instead of cognitiveServices.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/","title":"API Overview","tags":[],"description":"","content":"API aims The key guiding principles of the Farmer API are (in order):\n Simplicity: Make it as easy as possible to do the most common tasks. Type safety: Where possible, use F#\u0026lsquo;s type system to make it impossible to create invalid templates. Flexibility: Provide users with the ability to override the defaults where needed.  Farmer Resources Farmer works on a simple, consistent process:\n You create Farmer resources, such as Storage Accounts and Web Apps. Each Farmer resource can represent one or many ARM resources. For example, a Farmer webApp resource represents both the Microsoft.Web/sites and Microsoft.Web/serverfarms resources. In addition, it optionally also provides simplified access to an Microsoft.Insights/components. You configure each resource using simple, human-readable custom keywords in a strongly-typed environment. You link together resources as required. Once you have created all resources, you bundle them up together into an ARM deployment resource. You then generate (and optionally deploy) an ARM template. The rest of your deployment pipeline stays the same.  The diagram below illustrates how Farmer resources map to ARM ones:\ngraph TD subgraph ARM Template classDef danger fill:orange; C(Microsoft.Web/serverfarms) -. dependency .-F D(Microsoft.Insights/components) -. dependency .-F E(Microsoft.Storage/storageAccounts) -. dependency .-F E -. storage key .- F E -. storage key .- G F(Microsoft.Web/sites) G(blobServices/containers) class C danger class D danger class E danger class F danger class G danger end subgraph Farmer A(webApp)-. depends on .-B B(storageAccount)-. key .-A end  In this example, we create a storage account and web app in Farmer, which maps five different ARM template resources. As you can see, resources in Farmer are declared at a higher level of abstraction than ARM template resources. This makes things much simpler to reason about, and quicker to author.\nAn example Farmer Resource All Farmer resources follow the same approach:\n You define a resource using a special \u0026ldquo;builder\u0026rdquo; that allows the use of custom keywords. This is known as an F# computation expression. Each builder is designed for a specific type of Azure resource e.g. websites, functions, virtual machines etc., and each has defaults set for the most common scenario. This resource is validated and converted into a Farmer configuration object, which contains the configuration for that resource including any defaults. This configuration is then added to an overarching Farmer ARM deployment object. The ARM deployment object is converted into an ARM template json file.  graph LR subgraph JSON C(ARM Template) end subgraph .NET A(Farmer Builder)--validation and defaults --B B(Farmer Configuration) --emitted to -- C end  Here\u0026rsquo;s an example web application.\nlet myWebApp = webApp { name \u0026#34;mystorage\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku Sku.B1 always_on app_insights_off worker_size WorkerSize.Medium number_of_workers 3 run_from_package }  The webApp { } builder defines the start and end of the definition of the web application. Within this builder, you use custom keywords to configure the web app, such as name and setting. Some keywords take arguments, but others e.g. always_on are simple declarative markers.   You can view details of all farmer resources in the resource guide.\n Putting it all together The diagram above can be shown in code as follows:\n/// An Azure Storage account with a container. let storage = storageAccount { name \u0026#34;astorageaccount\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } /// An Azure App Service with built-in App Insights. let app = webApp { name \u0026#34;awebapp\u0026#34; setting \u0026#34;storageKey\u0026#34; storage.Key // pull in the storage key to an app setting  depends_on storage // state that this web app depends on the storage account } /// An ARM deployment with both of the above resources attached let deployment = arm { location Location.NorthEurope add_resource storage add_resource app } // Write the ARM template out to myTemplate.json let filename = deployment.Template |\u0026gt; Writer.toJson |\u0026gt; Writer.toFile \u0026#34;myTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cosmos-db/","title":"Cosmos DB","tags":[],"description":"","content":"Overview The CosmosDb package containers two builders, used to create databases and containers.\n CosmosDB Account (Microsoft.DocumentDb/databaseAccounts) CosmosDB SQL (Microsoft.DocumentDB/databaseAccounts/sqlDatabases) CosmosDB MongoDB (Microsoft.DocumentDB/databaseAccounts/mongodbDatabases) CosmosDB SQL Container (Microsoft.DocumentDb/databaseAccounts/sqlDatabases/containers)   There is currently only support for document databases (the so-called \u0026ldquo;SQL API\u0026rdquo;), with support for Gremlin, Table and Cassandra data models planned.\n Cosmos DB Builder The CosmosDB builder abstracts the idea of account and database into one. If you wish to \u0026ldquo;re-use\u0026rdquo; an already-created Cosmos DB account, use link_to_account keyword - no account will be created and the database will be attached to the existing one.\n   Applies To Keyword Purpose     Database name Sets the name of the database.   Database link_to_account Instructs Farmer to link this database to an existing Cosmos DB account rather than creating a new one.   Database throughput Sets the throughput of the account.   Database add_containers Adds a list of containers to the database.   Account account_name Sets the name of the CosmosDB account.   Account api (not yet implemented) Sets the API and data model to use \u0026ndash; currently defaults to \u0026ldquo;Core (SQL)\u0026quot;.   Account enable_public_network_access Enables public network access for the account.   Account disable_public_network_access Disables public network access for the account.   Account consistency_policy Sets the consistency policy of the database.   Account failover_policy Sets the failover policy of the database.   Account free_tier Registers this server with the free pricing tier, if supported and allowed by Azure.    Cosmos Container Builder The container builder allows you to create and configure a specific container that is attached to a cosmos database.\n   Keyword Purpose     name Sets the name of the container.   partition_key Sets the partition key of the container.   add_index Adds an index to the container.   exclude_path Excludes a path from the container index.    Example open Farmer open Farmer.Builders let myCosmosDb = cosmosDb { name \u0026#34;isaacsappdb\u0026#34; account_name \u0026#34;isaacscosmosdb\u0026#34; throughput 400\u0026lt;CosmosDb.RU\u0026gt; failover_policy CosmosDb.NoFailover consistency_policy (CosmosDb.BoundedStaleness(500, 1000)) add_containers [ cosmosContainer { name \u0026#34;myContainer\u0026#34; partition_key [ \u0026#34;/id\u0026#34; ] CosmosDb.Hash add_index \u0026#34;/path\u0026#34; [ CosmosDb.Number, CosmosDb.Hash ] exclude_path \u0026#34;/excluded/*\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-3/","title":"Deploying to Azure","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll update the application to deploy the generated ARM template to Azure directly from Farmer.\n Farmer generates normal ARM templates. You use all of the standard mechanisms for deploying ARM templates such as through the portal, Powershell, .NET or Azure CLI etc. This tutorial shows you a simple way to deploy templates from your development machine directly from within F#.\n Install the Azure CLI If you haven\u0026rsquo;t done so already, install the Azure CLI on your machine.\nDeploy the template As Farmer emits standard ARM templates, you can use all the standard ARM template deployment tools at your disposal - whether that\u0026rsquo;s Visual Studio, Powershell, or the Azure CLI. In our case, we can also use Farmer\u0026rsquo;s API which wraps around the Azure CLI.\nModify the application you created at the end of quickstart #2 so that instead of writing the template to a file, we deploy it directly:\ndeployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters  Note that the Web Application and Storage Account names should be globally unique; they must be unique across Azure i.e. someone else can\u0026rsquo;t have another web app or storage account with the same name!\n Farmer will now create the ARM template, and also generate a batch / shell script which calls the Azure CLI. You\u0026rsquo;ll be prompted to login to Azure by the CLI, after which point it will create the named resource group in the location specified in the arm { } builder.\nWait until the process is completed and log into the Azure Portal. Navigate to the newly-created resource group and inspect the overview record list e.g.\nCongratulations - you\u0026rsquo;ve now created and deployed an ARM template entirely from F#!\nThe full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorageaccount\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/3-ibuilder/","title":"3. The IBuilder interface","tags":[],"description":"","content":"Sometimes, ARM resources are captured at a level of abstraction that is too low for us to reason about. In such cases, we may wish to use the IBuilder interface. An IBuilder is not only even easier to consume by users than the F# record we looked at in the previous exercise, but can create multiple IArmResource objects at once. This is especially useful for more complex resources that tend to come in groups of two or three together - for example, Server Farm and Web Apps, or Cosmos DB Accounts, Databases and Containers. An IBuilder encapsulates the logic needed to create and configure all the resources together.\n In this example, the Container Registry builder only creates a single resource.\n Step 3.1: The Configuration Record The first step is to create a simple configuration record that contains any data that is required to be captured by the user. Often, this may map nearly 1:1 with the IArmResource - normally the main difference will be that you do not need to provide the Location here, as Farmer will automatically provide that for you.\n// src/Farmer/Arm/ContainerRegistry.fs let registries = ResourceType (\u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;2019-05-01\u0026#34;) // src/Farmer/Builders.ContainerRegistry.fs type ContainerRegistryConfig = { Name : ResourceName Sku : Sku AdminUserEnabled : bool } interface IBuilder with member this.ResourceId = registries.resourceId this.Name member this.BuildResources location = [ { Name = this.Name Location = location Sku = this.Sku AdminUserEnabled = this.AdminUserEnabled } ] The IBuilder interface has two members:\n ResourceId - a field that is the identifying path of the resource (including resource type, version, and name). It\u0026rsquo;s used by Farmer when setting dependencies between multiple resources and for emitting the appropriate JSON. If you builder has several ARM resources, it should return the \u0026ldquo;main\u0026rdquo; resource in the builder that others would depend upon. BuildResources - a function takes the location that the resources should be deployed to, and should return the list of IArmResource resources that must be created - this is normally a relatively simple mapping. For more complex builders e.g. one which represent multiple IArmResource objects, your BuildResources function will emit a list of IArmResources.   It\u0026rsquo;s tempting to suggest simply applying IBuilder directly onto the IArmResource. You could probably do this, but the separation and clarity provided here is an important step, and gives freedom in the future to diverge the shapes of the builder and the underlying resource.\n Step 3.2 Test out the IBuilder. You can finish this exercise by confirming that your IBuilder works correctly:\nopen Farmer.Builders.ContainerRegistry let registries = { Name = ResourceName \u0026#34;my-registry\u0026#34; Sku = ContainerRegistry.Basic AdminUserEnabled = true } let deployment = arm { location Location.WestCentralUS add_resource registries } deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34;  Ensure that the location of WestCentralUS has been correctly applied to the emitted ARM template json file!\n "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cdn/","title":"CDN","tags":[],"description":"","content":"Overview The CDN builder is used to create Azure Content Delivery Network instances.\n CDN Profile (Microsoft.Cdn/profiles) CDN Endpoint (Microsoft.Cdn/profiles/endpoints) CDN Custom Domain (Microsoft.Cdn/profiles/endpoints/customDomains)  There are two builders available:\n The CDN builder, which maps to a CDN profile. The Endpoint builder, which creates endpoints and custom domains. Endpoints are created within a CDN.  CDN Builder Keywords    Keyword Purpose     name Sets the name of the CDN instance.   sku Sets the SKU of the CDN instance. Defaults to Standard Akamai.   add_endpoints Adds several endpoints to the CDN.    Endpoint Builder Keywords    Keyword Purpose     name Sets the name of the endpoint instance. If you do not set this, a name is generated based on the origin.   origin Sets the address of the origin and is used to auto-generate the endpoint name if none if supplied.   depends_on Sets dependencies on this endpoint.   add_compressed_content Adds a set of content types to compress.   query_string_caching_behaviour Specifies the Query String Caching Behaviour.   enable_http Enables HTTP delivery on the endpoint.   disable_http Disables HTTP delivery on the endpoint.   enable_https Enables HTTPS delivery on the endpoint.   disable_https Disables HTTPS delivery on the endpoint.   custom_domain Sets the custom domain name to use on the endpoint.   optimise_for Optimises delivery for a specific type of content.     Storage Accounts and Web Apps have special support for CDN endpoints. You can supply a storage account or web app builders directly as the origin.\n Example let isaacWebApp = webApp { name \u0026#34;isaacsuperweb\u0026#34; app_insights_off } let isaacStorage = storageAccount { name \u0026#34;isaacsuperstore\u0026#34; } let isaacCdn = cdn { name \u0026#34;isaacsupercdn\u0026#34; add_endpoints [ endpoint { origin isaacStorage optimise_for Cdn.OptimizationType.LargeFileDownload } endpoint { origin isaacWebApp disable_http } endpoint { name \u0026#34;custom-endpoint-name\u0026#34; origin \u0026#34;mysite.com\u0026#34; add_compressed_content [ \u0026#34;text/plain\u0026#34;; \u0026#34;text/html\u0026#34;; \u0026#34;text/css\u0026#34; ] query_string_caching_behaviour Cdn.BypassCaching } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/databricks-workspace/","title":"Databricks Workspace","tags":[],"description":"","content":"Overview The Databricks Workspace builder is used to create Azure Databricks Workspaces.\n Workspace (Microsoft.Databricks/workspaces)  Builder Keywords    Keyword Purpose     name Sets the name of the workspace.   sku Sets the pricing tier of the workspace. Defaults to Standard Tier.   encrypt_with_key_vault Given a key vault builder / resourceid / vault name, and the name of a key, activates the use of Key Vault for the key store.   encrypt_with_databricks Specifies to use DataBricks itself for key encryption.   encrypt_with Allows you to programmatically specify whether to use key vault or data bricks encryption.   key_vault_key_version Specifies the version of the key vault key to use; if this is not specified, the latest version of the key is used.   allow_public_ip Whether to use public IP addresses for cluster virtual machines. Defaults to Enabled.   attach_to_vnet Given a Resource Id / Name / VNet Config, and Public \u0026amp; Private Subnets, attaches the workspace to the VNet specified.   managed_resource_group_id Sets the name of the resource group that will be created by the workspace. Optional.    Example open Farmer open Farmer.Builders let myVault = keyVault { name \u0026#34;my-vault\u0026#34; } let myWorkspace = databricksWorkspace { name \u0026#34;my-databricks-workspace\u0026#34; sku Databricks.Sku.Standard encrypt_with_key_vault myVault \u0026#34;workspace-encryption-key\u0026#34; attach_to_vnet \u0026#34;databricks-vnet\u0026#34; \u0026#34;databricks-pub-snet\u0026#34; \u0026#34;databricks-priv-snet\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/deployment-script/","title":"Deployment Script","tags":[],"description":"","content":"Overview The Deployment Script builder is used to execute Azure CLI scripts as part of an ARM deployment.\n Deployment Script (Microsoft.Resources/deploymentScripts)  Builder Keywords    Keyword Purpose     name Sets the name of the deployment script resource.   arguments List of arguments to pass to the script.   cleanup_on_success The script will only be cleaned up on success to allow for inspection of failures.   cli Specifies the CLI runtime, default is az cli.   content Sets script content for the resource.   env_vars Defines environment variables in the script environment.   force_update_tag A tag that cn be changed to force a resource update so the script is run again.   identity Sets the user assigned identity for the deployment script resource (must be a contributor in the resource group).   primary_script_uri Sets a URI to download script content.   retention_interval Sets the hours to retain the script runtime infrastructure to run again quickly.   script_content Sets script content for the resource.   supporting_script_uris Sets a URI to download additional content for the script.   timeout Sets the maximum amount of time to allow the script to run.   depends_on Specifies the resource or resource ID of resources that must exist before script execution.   add_tags Adds tags to the script runtime resource.   add_tag Adds a tag to the script runtime resource.    Example open Farmer open Farmer.Builders /// The deployment script must run under an identity with any necessary permissions /// to perform the commands in the script. Also must be a contributor in the /// resource group. let scriptIdentity = userAssignedIdentity { name \u0026#34;script-user\u0026#34; } /// The script identity must be a contributor over this resource group. let scriptRole = role_assignment (ArmExpression.create(\u0026#34;guid(resourceGroup().id)\u0026#34;).Eval()) Roles.Contributor scriptIdentity.PrincipalId /// Define the parameters, identity, and content for the script let getDateScript = deploymentScript { name \u0026#34;custom-script\u0026#34; identity scriptIdentity force_update_tag (System.DateTime.Now.ToString(\u0026#34;o\u0026#34;)) /// Format output as JSON and pipe to $AZ_SCRIPTS_OUTPUT_PATH to make it available as an output variable.  content \u0026#34;\u0026#34;\u0026#34;printf \u0026#34;{\u0026#39;date\u0026#39;:\u0026#39;%s\u0026#39;\u0026#34;} \u0026#34;`date`\u0026#34; \u0026gt; $AZ_SCRIPTS_OUTPUT_PATH \u0026#34;\u0026#34;\u0026#34; } /// The deployment runs the script and gets any output variables. let template = arm { location Location.EastUS add_resource scriptIdentity add_resource scriptRole add_resource getDateScript output \u0026#34;date\u0026#34; \u0026#34;[reference(\u0026#39;custom-script\u0026#39;).outputs.date]\u0026#34; } Example with dependent resource let storage = storageAccount { name \u0026#34;storagewithstuff\u0026#34; add_public_container \u0026#34;public\u0026#34; } /// The deployment script can run azure CLI commands against resources in the /// same deployment by using \u0026#39;run_after\u0026#39; and referencing those resources. let script = deploymentScript { name \u0026#34;write-files\u0026#34; script_content \u0026#34;echo \u0026#39;hello world\u0026#39; \u0026gt; hello \u0026amp;\u0026amp; az storage blob upload --account-name storagewithstuff -f hello -c public -n hello\u0026#34; run_after (ResourceId.create (storageAccounts, storage.Name.ResourceName)) } let template = arm { location Location.EastUS add_resource storage add_resource script } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/dns/","title":"DNS Zone","tags":[],"description":"","content":"Overview The DNS Zone module contains two types of builders - dnsZone, used to create DNS Zones, and ___Record (like cnameRecord, aRecord, ..), used to create DNS Records sets. It supports most record types (except SOA, SRV and CAA) and has specific builders for every record type.\n DNS Zone (Microsoft.Network/dnsZones) A Record (Microsoft.Network/dnsZones/A) AAAA Record (Microsoft.Network/dnsZones/AAAA) CNAME Record (Microsoft.Network/dnsZones/CNAME) TXT Record (Microsoft.Network/dnsZones/TXT) MX Record (Microsoft.Network/dnsZones/MX) NS Record (Microsoft.Network/dnsZones/NS) PTR Record (Microsoft.Network/dnsZones/PTR)  TODO The following items are currently unsupported:\n SOA records SRV records CAA records Private Zone (untested) Virtual network support for Private Zones Tags  DNS Zone Builder Keywords    Keyword Purpose     name Sets the name of the domain.   zone_type Sets the zone type.   add_records Adds DNS Zone records (see below).    Each Record type has its own custom builder. All builders share the following common keywords:\n   Keyword Purpose     name Sets the name of the record set (default to @).   ttl Sets the time-to-live of the record set.    In addition, each record builder has its own custom keywords:\nA Record Builder Keywords    Keyword Purpose     add_ipv4_addresses Add IPv4 addresses to this record set.   target_resource A reference to an azure resource from where the dns resource value is taken.    AAAA Record Builder Keywords    Keyword Purpose     add_ipv6_addresses Add IPv6 addresses to this record set.   target_resource A reference to an azure resource from where the dns resource value is taken.    CNAME Record Builder Keywords    Keyword Purpose     cname Sets the canonical name for this CNAME record.   target_resource A reference to an azure resource from where the dns resource value is taken.    TXT Record Builder Keywords    Keyword Purpose     add_values Add TXT values to this record set.    MX Record Builder Keywords    Keyword Purpose     add_values Add MX values to the record set.    NS Record Builder Keywords    Keyword Purpose     add_nsd_names Add NS values to this record set.    PTR Record Builder Keywords    Keyword Purpose     add_ptrd_names Add PTR names to this record set.    Example #r @\u0026#34;./libs/Newtonsoft.Json.dll\u0026#34; #r @\u0026#34;../../src/Farmer/bin/Debug/netstandard2.0/Farmer.dll\u0026#34; open Farmer open Farmer.Builders let dns = dnsZone { name \u0026#34;farmer.com\u0026#34; zone_type Dns.Public add_records [ cnameRecord { name \u0026#34;www2\u0026#34; ttl 3600 cname \u0026#34;farmer.github.com\u0026#34; } aRecord { ttl 7200 add_ipv4_addresses [ \u0026#34;192.168.0.1\u0026#34;; \u0026#34;192.168.0.2\u0026#34; ] } aaaaRecord { ttl 7200 add_ipv6_addresses [ \u0026#34;100:100:100:100\u0026#34; ] } txtRecord { ttl 3600 add_values [ \u0026#34;v=spf1 include:spf.protection.outlook.com -all\u0026#34; ] } mxRecord { ttl 7200 add_values [ 0, \u0026#34;farmer-com.mail.protection.outlook.com\u0026#34;; 1, \u0026#34;farmer2-com.mail.protection.outlook.com\u0026#34;; ] } ] } let deployment = arm { location Location.NorthEurope add_resource dns } deployment |\u0026gt; Writer.quickWrite \u0026#34;dns-example\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/data-lake/","title":"Data Lake","tags":[],"description":"","content":"Overview The Data Lake builder is used to create Azure Data Lake instances.\n Data Lake (Microsoft.DataLakeStore/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Cognitive Services instance.   sku Sets the SKU of the instance. Defaults to Consumption.   enable_encryption Turns on data lake encryption.    Example open Farmer open Farmer.Builders let myLake = dataLake { name \u0026#34;myDataLake\u0026#34; sku DataLake.Commitment_100TB enable_encryption } "},{"uri":"https://compositionalit.github.io/farmer/arm-vs-farmer/","title":"Farmer and ARM","tags":[],"description":"","content":"    Farmer ARM Template     Core ARM features     Repeatable deployments? Yes, Farmer runs on top of ARM Yes   ARM deployment mechanisms? All, plus easy-to-use F# deployment All   Variables support? Yes, native support in F# Yes   Parameters support? Yes, native support in F# or secure parameters Yes   Supported resources? All, including custom builders for ~50 popular resources All   Declarative model support? Yes Yes   Support for all ARM tools? Yes, Farmer runs on top of ARM Yes   Linked Template support? No - generally not required. Yes   Authoring     Easy to author? Yes No   Easy to read? Yes No   Documented? Yes, website and discoverable intellisense Limited, documented but often out-of-date   Editor support? Yes, any F# editor including VS Code, VS and Rider Limited, only VS Code has any support   Safety     Type-safe? Yes, full support from the F# compiler and type system Limited through VS Code extension and LSP   Validation support? Edit-time, run-time, deploy-time Deploy-time and limited edit-time   Flexibility     Link resources easily? Yes Not easily complex path expressions must be known   Compose resources together? Yes Not easily   Create multiple resources simultaneously? Yes No, each resource must be defined separately   Create resources in several ways? Yes, builders, records, functions or classes No, must use JSON   Full programming language? Yes, F# is a simple yet powerful programming language No, JSON with limited functions   Imperative model? Yes, F# supports imperative programming No, you must program in a declarative style   Interop and extensibility     Add your own ARM resources? Yes, plug-in model to add new ARM resources N/A   Create your own combinations of resources? Yes No, each resource must be defined separately   Use external libraries? Yes, use any NuGet packages during authoring and full .NET Core No, fixed set of functions   Use in .NET applications? Yes, Farmer is a .NET Core library and can be used in-proc No, JSON files    "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/template/","title":"The Farmer .NET Template","tags":[],"description":"","content":"Farmer comes with a .NET template that makes getting started easy.\nCreating a basic Farmer app The easiest way to create a Farmer app is to use the Farmer .NET Template.\ndotnet new -i Farmer.Template dotnet new Farmer  You only have to install the template once on your machine!\n This creates a new dotnet application solution and project that looks by default as follows:\nopen Farmer open Farmer.Builders let deployment = arm { location Location.NorthEurope } printf \u0026#34;Generating ARM template...\u0026#34; deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34; printfn \u0026#34;all done! Template written to output.json\u0026#34; From here, you can add resources in the normal manner.\nBasic configuration options You can configure the template using the following optional arguments.\nARM Template filename The name of the ARM template JSON file e.g. --armTemplate myTemplate\nLocation The location to create resources in e.g. --location WestUS\nDeploy Configuration You can also configure the Farmer template to deploy to Azure out of the box using the --ci option. This has two modes of operation:\nAzure DevOps deployment This comes with a ready-made devops YAML file designed for simple CI/CD, using Farmer to generate ARM templates and Azdo to deploy using its own ARM Template deployment process. You should supply the following arguments:\n \u0026ndash;ci: Tells the template to create a Farmer app for use with Azure Devops. \u0026ndash;azureSubscription: Set the full name of the Azure Subscription that has been already configured in Azdo that has permission to deploy templates to Azure. \u0026ndash;resourceGroup: Set the name of the resource group that you wish to deploy to.  Direct deployment If you prefer a deployment process that is not coupled to Azure Devops, you can create a service principle in Azure and use the generated credentials in Farmer. Farmer will use its own wrapper around the Azure REST API to deploy to Azure, reporting progress to the console.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/diagnosticsetting/","title":" Diagnostic Settings ","tags":[],"description":"","content":"Overview The Diagnostic Settings builder is used to create diagnostic settings instances to send platform logs and metrics to different destinations (storage, event hub and log analytics). Support for Farmer builders and external resources is supported.\n Diagnostic Settings (providers/diagnosticSettings)  Builder Keywords    Keyword Purpose     name Sets the name of the Diagnostic Settings resource.   metrics_source The resource that will be used for the source of logging and metrics information. Can be any Builder, or you can supply a ResourceId for an external resource.   capture_metrics Specifies the list of Metrics to capture from the source resource.   capture_logs Specifies the list of Log Categories to capture from the source resource.   add_destination Adds a destination for all logs and metrics, either a storage account, log analytics workspacce, event hub or a Resource ID pointing to any valid Resource for those three resource types.   event_hub_destination_name Allows you to override the event hub name to use.   loganalytics_output_type If a Log Analytics Workspace is specified as output, specifies whether to use the default Azure Diagnostics grouping or a dedicated grouping for logging and metrics.    Example The example below illustrates how to create a web application and set up a diagnostics setting against it, whilst setting up three destinations for the diagnostics (storage, event hub and log analytics). Also notice the using of the Logging. namespace, which contains all documented Logging categories.\nopen Farmer open Farmer.Builders open Farmer.DiagnosticSettings let data = storageAccount { name \u0026#34;isaacsuperdata\u0026#34; } let hub = eventHub { name \u0026#34;isaacsuperhub\u0026#34; } let logs = logAnalytics { name \u0026#34;isaacsuperlogs\u0026#34; } let web = webApp { name \u0026#34;isaacdiagsuperweb\u0026#34;; app_insights_off } let mydiagnosticSetting = diagnosticSettings { name \u0026#34;myDiagnosticSetting\u0026#34; metrics_source web add_destination data add_destination logs add_destination hub loganalytics_output_type Dedicated capture_metrics [ \u0026#34;AllMetrics\u0026#34; ] capture_logs [ Logging.Web.Sites.AppServicePlatformLogs Logging.Web.Sites.AppServiceAntivirusScanAuditLogs ] } let deployment = arm { add_resources [ data; web; hub; logs; mydiagnosticSetting ] } "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/4-creating-builder-syntax/","title":"4. Providing Builder syntax","tags":[],"description":"","content":"If you want to get the nice json-like syntax for your configuration record, you need to implement a separate class which contains a set of methods that act on the Configuration Record that you created previously - one for each keyword that you want.\n If you need have not built your own computation expression before, here are some background resources for you:\n Office microsoft docs The \u0026ldquo;Computation Expressions\u0026rdquo; series Workshop   Step 4.1: Creating basic keywords We will not cover the inner details of creating a Computation Expression (CE) here. For now, just know that a CE is a basic class (yes, like a C# class) that is very similar to an immutable fluent API you might see in C#, except that in F# you can expose each fluent method as what looks like a new keyword.\nTo get started the only member you need to implement is the Yield method, which returns the \u0026ldquo;default\u0026rdquo; value of your record (i.e. before any fluent methods or keywords have been called).\n// Builder.ContainerRegistry.fs type ContainerRegistryBuilder() = /// Required - creates default \u0026#34;starting\u0026#34; values  member _.Yield _ = { Name = ResourceName.Empty Sku = Basic AdminUserEnabled = false } [\u0026lt;CustomOperation \u0026#34;name\u0026#34;\u0026gt;] /// Sets the name of the Azure Container Registry instance.  member _.Name (state:ContainerRegistryConfig, name) = { state with Name = ResourceName name } [\u0026lt;CustomOperation \u0026#34;sku\u0026#34;\u0026gt;] /// Sets the name of the SKU/Tier for the Container Registry instance.  member _.Sku (state:ContainerRegistryConfig, sku) = { state with Sku = sku } [\u0026lt;CustomOperation \u0026#34;enable_admin_user\u0026#34;\u0026gt;] /// Enables the admin user on the Azure Container Registry.  member _.EnableAdminUser (state:ContainerRegistryConfig) = { state with AdminUserEnabled = true } Each keyword has a similar set of steps required:\n Create a member which takes in at least one argument - the current state object, which represents your configuration record. The implementation should perform some update to the state and return back the newly-updated state. Don\u0026rsquo;t worry about \u0026ldquo;where\u0026rdquo; the state goes - the F# CE will \u0026ldquo;thread\u0026rdquo; the state between calls for you. Decorate the method with the CustomOperation attribute; the string value passed to it will become the keyword. Use _ to separate words of the keyword e.g. enable_admin_user. Put a /// comment on the method for intellisense to guide users.  Now you can create members on the builder that appear as custom operators in your resource CE. In each member you build up the state of the resource configuration you created in the previous step.\nStep 4.2 Consuming builders Firstly, create a single static instance of the ContainerRegistryBuilder class that you just made:\nlet containerRegistry = ContainerRegistryBuilder() Now, you can create Container Registries anywhere using the keyword syntax:\n/// myRegistry is of type ContainerRegistryConfig let myRegistry = containerRegistry { name \u0026#34;my-registry\u0026#34; sku Basic enable_admin_user } Parameterless keywords You can create parameterless keywords by simply only taking in the state argument e.g. enable_admin_user above.\nKeywords with multiple arguments You can take in multiple arguments by simply putting a comma after each additional argument. They will be consumed by the user with spaces.\nOverloaded keywords You can provide multiple overloads for a keyword. However, each overload must take in the same number of arguments. Do not re-apply the CustomOperation attribute - simply provide multiple methods with the same name.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/webapp-deploy/","title":"Deploy an ASP.NET app","tags":[],"description":"","content":"Introduction This tutorial shows how to create the infrastructure required to host a ASP.NET web app, and how to automatically deploy that application with Farmer. We\u0026rsquo;ll cover the following steps:\n Creating and configuring a basic ASP.NET web application. Creating a web app in Farmer. Deploying the web app through Farmer.    Full code available here\n   Note: Your web application does can be a C# web application - it does not need to be written in F#!\n Creating the ASP.NET web application Create a brand new ASP.NET web application:\n Create a directory for your new application and enter it. Using the dotnet SDK, create a new application: dotnet new mvc. Notice that inside the project file (either csproj or fsproj), the Project SDK is already set to Microsoft.NET.Sdk.Web. This is more-or-less required for hosting in Azure. Locally publish the application to a directory called deploy: dotnet publish -c Release -o deploy.   dotnet publish puts all built files and outputs into a single folder, and adds a web.config as required for e.g. Azure, as long as your Project SDK is set correctly.\n Create the Web App Create a new Farmer application which contains a web app.\nopen Farmer open Farmer.Builders let webapplication = webApp { name \u0026#34;\u0026lt;web app name goes here\u0026gt;\u0026#34; } Configure Web App to deploy your ASP.NET application let webapplication = webApp { ... zip_deploy @\u0026#34;\u0026lt;path_to_your_deploy_folder\u0026gt;\u0026#34; } That\u0026rsquo;s it! Deploy the web app by adding it to an ARM builder and deploy it to a resource group of your choosing. During the deployment process, you will notice the following:\nRunning ZIP deploy for \u0026lt;path_to_your_deploy_folder\u0026gt;\n Farmer will automatically zip up the contents of the folder for you.\n "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/event-grid/","title":"Event Grid","tags":[],"description":"","content":"Overview The Event Grid is a simple but powerful builder that links events from Azure services such as Storage and App Service to one or many subscribers which can consume the events. The event grid builder supports a degree of type safety - all system events are provided from a strongly-typed list, and events are directly linked to specific builders - so, for example, you cannot accidentally subscribe to Storage Account events if the event publisher is a Web App. It supports the following ARM resources.\n Topics (Microsoft.EventGrid/systemTopics) Subscriptions (Microsoft.EventGrid/systemTopics/eventSubscriptions)  Builder Keywords    Keyword Purpose     topic_name The name of the topic that will be created.   source The source of the events. See below for the full list of builder configurations that are supported.   add_queue_subscriber Adds a new storage queue subscriber. Requires the storage account config that will receive the events, the queue name and the list of events to subscribe to.   add_webhook_subscriber Adds a new web hook (HTTP) subscriber. Requires the web app config that will receive the event, associated URI local path and the list of events to subscribe to. Also contains an overload that takes in a Web App name and the full Uri of the web hook.   add_eventhub_subscriber Adds a new event hub subscriber. Requiresthe event hub builder config that will receive the events and the list of events to subscribe to.    Supported Sources Farmer supports the following Event Grid sources using Farmer builders:\n   Builder Events namespace      StorageAccount SystemEvents.Storage    WebApp SystemEvents.AppServer    KeyVault SystemEvents.KeyVault    SignalR SystemEvents.SignalR    Maps SystemEvents.Maps    ContainerRegistry SystemEvents.ContainerRegistry    ServiceBus SystemEvents.ServiceBus    IotHub SystemEvents.IotHub    EventHub SystemEvents.EventHub     Suported Destinations  EventHub (add_eventhub_subscriber), StorageQueue (add_queue_subscriber), WebHook (add_webhook_subscriber), ServiceBus Queue (add_servicebus_queue_subscriber), ServiceBus Topic (add_servicebus_topic_subscriber).  Example The following sample creates a source storage account that emits events on the event grid topic, whilst two destinations are created: an event hub and a storage queue, each listening for different events.\nopen Farmer open Farmer.Builders let queueName = \u0026#34;events\u0026#34; let storageSource = storageAccount { name \u0026#34;isaacstorageacc\u0026#34;; add_private_container \u0026#34;data\u0026#34; } let destionationHub = eventHub { name \u0026#34;isaachub\u0026#34;; namespace_name \u0026#34;isaacns\u0026#34; } let destinationStorage = storageAccount { name \u0026#34;destinationstorage\u0026#34;; add_queue queueName; add_private_container \u0026#34;events\u0026#34; } let eventHubGrid = eventGrid { topic_name \u0026#34;isaacHubTopic\u0026#34; source storageSource add_eventhub_subscriber destionationHub [ SystemEvents.Storage.BlobCreated; SystemEvents.Storage.BlobDeleted ] add_queue_subscriber destinationStorage queueName [ SystemEvents.Storage.BlobCreated ] } let template = arm { add_resources [ storageSource eventHubGrid destinationStorage destionationHub ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/express-route/","title":"ExpressRoute","tags":[],"description":"","content":"Overview An ExpressRoute circuit is a dedicated link to Azure to provide communication with Azure services without traversing the Internet. It requires some coordination with a networking provider for these circuits, so some information, such as the service provider and peering location must be obtained from Azure reference documentation. The ExpressRoute builder creates an ExpressRoute circuit and enables Azure private peering and Microsoft peering.\n ExpressRoute Namespace (Microsoft.Network/expressRouteCircuits)  Builder Keywords    Applies To Keyword Purpose     ExpressRoute service_provider Connectivity service provider from Azure reference documentation   ExpressRoute peering_location Connectivity peering location from Azure reference documentation   ExpressRoute tier Standard or Premium   ExpressRoute family Metered or Unlimited data   ExpressRoute bandwidth Bandwidth in Mbps for the circuit   ExpressRoute add_peering Peering details for the circuit - can add Azure Private and Microsoft peerings   Peering peering_type A network CIDR block of 4 IP addresses (/30) for the ExpressRoute primary circuit   Peering peer_asn Peer Autonomous System Number - this is a uniquely assigned number for the peer network, typically provided by the service provider in agreement with Microsoft   Peering azure_asn Azure Autonomous System Number - Microsoft oftent uses AS 12076 for Azure public, Azure private and Microsoft peering   Peering primary_prefix A network CIDR block of 4 IP addresses (/30) for the ExpressRoute primary circuit   Peering secondary_prefix A network CIDR block of 4 IP addresses (/30) for the ExpressRoute secondary circuit   Peering vlan A unique VLAN ID for the peering   Peering shared_key An optional shared key the service provider may specify for the peering    Example open Farmer open Farmer.Builders open Farmer.ExpressRoute let circuit = expressRoute { name \u0026#34;my-express-route\u0026#34; service_provider \u0026#34;Equinix\u0026#34; peering_location \u0026#34;New York\u0026#34; tier Premium family MeteredData bandwidth 1000\u0026lt;Mbps\u0026gt; add_peering ( peering { peering_type AzurePrivatePeering peer_asn 55277L azure_asn 12076 primary_prefix (IPAddressCidr.parse \u0026#34;10.254.12.0/30\u0026#34;) secondary_prefix (IPAddressCidr.parse \u0026#34;10.254.12.4/30\u0026#34;) vlan 2406 } ) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/event-hub/","title":"Event Hub","tags":[],"description":"","content":"Overview The Event Hub builder creates event hub namespaces, event hubs, consumer groups and authorization rules in a single builder.\n Event Hub Namespace (Microsoft.EventHub/namespaces) Event Hub (Microsoft.EventHub/namespaces/eventhubs) Consumer Group (Microsoft.EventHub/namespaces/eventhubs/consumergroups) Authorization Rule (Microsoft.EventHub/namespaces/eventhubs/AuthorizationRules\u0026quot;)   The Event Hub builder works in a similar fashion to the web app builder in that it automatically creates the host (in this case, the event hub namespace) when creating the event hub. If you wish to create multiple hubs in the same namespace, configure the namespace-level properties in the first event hub; subsequent event hubs should link to the namespace of the hub created by the first hub.\n Builder Keywords    Applies To Keyword Purpose     Namespace namespace_name Sets the name of the event hub namespace, if you are creating the namespace along with the hub.   Namespace sku Sets the SKU of the event hub namespace.   Namespace capacity Sets the capacity of the event hub namespace (see here for more details)   Namespace enable_zone_redundant Enables zone redundancy on the event hub namespace.   Namespace enable_auto_inflate Enables auto inflate throughput; you must supply the maximum throughput level.   Namespace disable_auto_inflate Disables auto inflate throughput.   Event Hub name Sets the name of the event hub.   Event Hub message_retention_days Sets the number of days to retain messages for on the event hub.   Event Hub partitions Sets the number of partitions on the event hub.   Event Hub add_consumer_group Creates a consumer group for the event hub.   Event Hub add_authorization_rule Adds a named authorization rule on the event hub.   Event Hub link_to_namespace Sets the name of an existing or already-defined event hub namespace that this event hub should link to.   Event Hub capture_to_storage Activates Event Hub data capture to a Storage Account. Takes in a storage account or resource name, and the container to write events to.    Configuration Members    Member Purpose     DefaultKey Gets an ARM expression for the root namespace key of the Event Hub namespace.   GetKey Gets an ARM expression for a named key on this event hub.    Example open Farmer open Farmer.Builders let storage = storageAccount { name \u0026#34;isaacssuperstorage\u0026#34; } let primaryHub = eventHub { namespace_name \u0026#34;allmyevents\u0026#34; sku EventHub.Standard enable_zone_redundant enable_auto_inflate 3 add_authorization_rule \u0026#34;FirstRule\u0026#34; [ EventHub.Listen; EventHub.Send ] add_authorization_rule \u0026#34;SecondRule\u0026#34; AllAuthorizationRights name \u0026#34;first-hub\u0026#34; partitions 2 message_retention_days 3 add_consumer_group \u0026#34;myGroup\u0026#34; } let secondHub = eventHub { name \u0026#34;second-hub\u0026#34; link_to_namespace \u0026#34;allmyevents\u0026#34; partitions 1 message_retention_days 1 capture_to_storage myStorageAccount \u0026#34;mycontainer\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/5-unit-testing/","title":"5. Unit Testing","tags":[],"description":"","content":"Usually I would be pro writing the tests before you implement all this but it is important to get a feel for the moving parts. At this point you may want to write some tests so you can iterate quickly on getting the structure of your ARM template correct.\nThe tests you will find in the project are black-box style tests that focus on the input of a resource and the output of the ARM template. If you want to create tests for your mapping functions that is fine but remember between the strong type system and making it difficult to have null values, those kind of tests seldom yield much benefit in F#.\nOf course, unit tests can only tell you so much when dealing with something as complex as Azure. Create a fsx file to run to check that your resource is deploying as expected.\n// container-registry.fsx #r \u0026#34;Newtonsoft.Json.dll\u0026#34; #r @\u0026#34;../Farmer/bin/Debug/netstandard2.0/Farmer.dll\u0026#34; open Farmer open Farmer.Resources.ContainerRegistry let myRegistry = containerRegistry { name \u0026#34;devonRegistry\u0026#34; sku ContainerRegistrySku.Basic enable_admin_user } let deployment = arm { location NorthEurope add_resource myRegistry output \u0026#34;registry\u0026#34; myRegistry.Name output \u0026#34;loginServer\u0026#34; myRegistry.LoginServer } deployment |\u0026gt; Deploy.execute \u0026#34;FarmerTest\u0026#34; Deploy.NoParameters |\u0026gt; printfn \u0026#34;%A\u0026#34; Create a Resource Group to run it, here I called it \u0026ldquo;FarmerTest\u0026rdquo;.\nRun dotnet fsi container-registry.fsx\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/create-pull-requests/","title":"Creating Pull Requests","tags":[],"description":"","content":" This article is not a detailed guide on how to create a pull request (PR). See here to learn more about how to work with pull requests on GitHub.\n The purpose of this article is to illustrate the main checklists you must go through before a PR will be considered for inclusion in Farmer. If you are new to Farmer, F# or GitHub - don\u0026rsquo;t worry. The team will be happy to support you getting your feature over the line.\nThese are the following checks we\u0026rsquo;ll normally put in place:\n1. Create an issue first! Except for small pull requests, create an issue to discuss the feature. The last thing we want is for someone to spend hours of their time on a feature only for someone else to have started work on something similar, or for the admins of the project to reject it for whatever reason e.g. does not fit with the project etc. Creating an issue does not take long and will help save time for everyone.\n2. Create Documentation Every PR to Farmer must have some documentation with it. If you modify a resource and add a new keyword, it must be added to the appropriate docs page.\n3. Write Unit Tests Every PR to Farmer should have at least one test associated with it. If no tests are added, you can expect at least a request for one or explanation as to why one is not necessary.\n4. Write Release Notes Every PR to Farmer must include an entry to the RELEASE_NOTES.md file under the next release. Briefly explain the feature and ideally link to the PR number e.g.\n5. Adhere to Coding Standards Here are some (very basic!) standards for the project:\n Follow the coding style of the existing source. Use 4 spaces for indentation. As a last resort, adhere to official style guide as a basis.  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/functions/","title":"Functions","tags":[],"description":"","content":"Overview The Functions builder is used to create Azure Functions accounts. It abstracts the App Host and Service Plan into the same component, and will also create and configure a linked App Insights resource. In addition, it will automatically create a backing storage account required by the functions runtime.\n Web Site (Microsoft.Web/sites) Web Host (Microsoft.Web/serverfarms) Application Insights (Microsoft.Insights/components) Storage Accounts (Microsoft.Storage/storageAccounts)  Builder Keywords    Keyword Purpose     name Sets the name of the functions instance.   service_plan_name Sets the name of the service plan hosting the function instance.   link_to_service_plan Instructs Farmer to link this webapp to an existing service plan rather than creating a new one.   link_to_unmanaged_service_plan Instructs Farmer to link this Functions instance to an existing service plan that is externally managed, rather than creating a new one.   link_to_storage_account Do not create an automatic storage account; instead, link to a storage account that is created outside of this Functions instance but within this Farmer template.   link_to_unmanaged_storage_account Do not create an automatic storage account; instead, link to an existing storage account that was created external to Farmer.   https_only Disables http for this functions app so that only HTTPS is used.   app_insights_name Sets the name of the automatically-created app insights instance.   app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   link_to_app_insights Instead of creating a new AI instance, configure this webapp to point to another AI instance that you are managing yourself.   link_to_unmanaged_app_insights Instructs Farmer to link this functions instance to an existing app insights instance that is externally managed, rather than creating a new one.   use_runtime Sets the runtime of the Functions host.   use_extension_version Sets the extension version of the functions host.   operating_system Sets the operating system of the Functions host.   setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   secret_setting Sets a \u0026ldquo;secret\u0026rdquo; app setting of the function. You must supply the \u0026ldquo;key\u0026rdquo;, whilst the value will be supplied as a secure parameter or an ARM expression.   settings Sets a list of app setting of the web app as tuples in the form of (\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;).   depends_on Sets dependencies for the web app.   enable_cors Enables CORS support for the app. Either specify AllOrigins or a list of valid URIs.   enable_cors_credentials Allows CORS requests with credentials.   add_identity Adds a managed identity to the the Function App.   system_identity Activates the system identity of the Function App.   always_on Stops the app from sleeping if idle for a few minutes of inactivity.   worker_process Specifies whether to set the app to 32 or 64 Bitness.    Post-deployment Builder Keywords The Functions builder contains special commands that are executed after the ARM deployment is completed.\n   Keyword Purpose     zip_deploy Supplying a folder or zip file will instruct Farmer to upload the contents directly to the Azure Functions once the ARM deployment is complete.    Key Vault integration The Function builder comes with special integration into KeyVault. By activating KeyVault integration, the function builder can automatically link to, or even create, a full KeyVault instance. All Secret or ARM Expression-based Settings (e.g. a setting that links to the Key of a Storage Account) will automatically be redirected to KeyVault. The value will be stored in KeyVault and the system identity will be activated and provided into the KeyVault with GET permissions. Lastly, Function app settings will remain in place, using the Azure Functions built-in KeyVault redirection capabilities.\nThe following keywords exist on the function:\n   Member Purpose     use_keyvault Tells the function app to create a brand new KeyVault for this Function\u0026rsquo;s secrets.   link_to_keyvault Tells the function to use an existing Farmer-managed KeyVault which you have defined elsewhere. All secret settings will automatically be mapped into KeyVault.   link_to_unmanaged_keyvault Tells the web app to use an existing non-Farmer managed KeyVault which you have defined elsewhere. All secret settings will automatically be mapped into KeyVault.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this functions app.   StorageAccountKey Gets the ARM expression path to the storage account key of this functions app.   AppInsightsKey Gets the ARM expression path to the app insights key of this functions app, if it exists.   DefaultKey Gets the ARM expression path for the default key of this functions app.   MasterKey Gets the ARM expression path for the master key of this functions app.    Example open Farmer open Farmer.Builders let myFunctions = functions { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; app_insights_off } "},{"uri":"https://compositionalit.github.io/farmer/deployment-guidance/","title":"Deployment Guidance","tags":[],"description":"","content":"You can deploy Farmer templates in a number of ways, depending on how you would prefer to work with ARM templates and tooling.\nOption 1: \u0026ldquo;ARM templates are just a means to an end to me\u0026rdquo; If you don\u0026rsquo;t use ARM templates today, or don\u0026rsquo;t need to edit them directly, you can opt to do away with them completely. You\u0026rsquo;ll create Farmer applications which use a simple F# SDK to interact with Azure; Farmer will create ARM templates in the background for you transparently, so you\u0026rsquo;ll never see or interact with them.\nIn such a case, you can opt to deploy directly through Farmer. This mode provides an F# wrapper around the Azure CLI which captures your credentials during the deployment process.\nIf you\u0026rsquo;re looking to stay within F# and e.g. respond to outcomes from the deployment such as using deployment outputs, this is an excellent option because Farmer is just a dotnet application and the deployment call is a simple function call.\nAnother benefit of this is because Farmer is a simple .NET Standard library, you can use it natively within .NET build tools such as FAKE or CAKE.\nCombined Resource and Application Deployment Farmer can also optionally do more for you by handling the entire deployment process, including deployment of your application artifacts.\ngraph LR subgraph Azure Resource Group D(Azure App Service) end subgraph JSON C(ARM Template) -- REST API or Azure CLI -- D end subgraph .NET A(Farmer)-- resources emitted to -- C A -. your application deployed via ZIP Deploy.- D end  Watch this short video to see more!\n  Option 2: \u0026ldquo;I already have an ARM deployment strategy\u0026rdquo; If you already use ARM templates, you\u0026rsquo;ll probably already have a strategy for working with templates and deploying them to Azure, such as PowerShell, the Azure CLI or a build system such as Azure DevOps or Octopus Deploy. In such a case, you may want to use Farmer to generate, but not deploy, your ARM templates.\nOption 3: \u0026ldquo;I want to hand-craft my ARM templates\u0026rdquo; If you want to retain fine-grained control over ARM templates, you can use Farmer to create a one-off task to rapidly generate an ARM template which you then take ownership of. In this case, Farmer itself won\u0026rsquo;t be a part of your build / deploy chain, which will remain the same as today - you\u0026rsquo;ll use Farmer just as an edit-time task to create an ARM template itself which you will then manually modify.\nThe choice is yours.\nHow do I create a Service Principal? If you\u0026rsquo;re trying to deploy to Azure in an automated fashion, you may need to create a Service Principal account that has permissions in Azure to deploy ARM templates on your behalf.\nThe Azure CLI provides a simple way to create one using the az ad sp command:\naz ad sp create-for-rbac --name farmer-deploy This will provide output similar to the following:\n{ \u0026#34;appId\u0026#34;: \u0026#34;1181c21b-78f3-42b3-a26d-03ba75c7b674\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;farmer-deploy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;http://farmer-deploy\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;4aa3b120-f2b2-4ea9-941b-5891fef0ef11\u0026#34;, \u0026#34;tenant\u0026#34;: \u0026#34;aa7f7453-15af-4ab0-5d41-aeb4a25293bc\u0026#34; } The mapping from these fields to the credentials used in Farmer\u0026rsquo;s authenticate function are:\n   Azure CLI Farmer     appId appId   password secret   tenant tenantId    You should store these credentials in a secure store, such as your CI/CD service or e.g. Azure KeyVault and should avoid committing them into source control.\n"},{"uri":"https://compositionalit.github.io/farmer/support/","title":"Commercial Support","tags":[],"description":"","content":"The creators of Farmer, Compositional IT, offer a professional fully managed support package which we strongly recommend for any organisations using Farmer on a commercial basis. It includes:\n Prioritised resolution of any bugs. If you find a bug that\u0026rsquo;s blocking you, we\u0026rsquo;ll prioritise it and release a hot fix as soon as it\u0026rsquo;s ready. Prioritised resolution and escalation of issues. If there\u0026rsquo;s a possible issue or question, we\u0026rsquo;ll prioritise dealing with it. Prioritised feature requests: Get new features that are important to you added first. Personalised support and guidance via email, telephone or video. Speak to one of our team for advice and best practices on how to best manage deployments. Discounts on our F# and Azure training and coaching services  Please contact us to find out more! "},{"uri":"https://compositionalit.github.io/farmer/testimonials/","title":"Testimonials","tags":[],"description":"","content":"Please submit a pull request here with details of your success stories of using Farmer!  \u0026ldquo;We\u0026rsquo;ve been using Farmer to help rapidly onboard our customers onto Azure with repeatable processes, particularly with the SAFE Stack. It\u0026rsquo;s helping our team adopt best practices without passing on expense to our customers.\u0026rdquo;\nIsaac Abraham, Director, Compositional IT\n  \u0026ldquo;Farmer quickly became an essential tool for Continuous Deployment at our F# projects. Clean DSL, great documentation, growing support of various Azure services and PR-friendly approach made Farmer to be one of the best open source projects in these days.\u0026rdquo;\nRoman Provaznk, F# Lead Developer, CN Group\n  \u0026ldquo;Holy moly, this was a breeze!! I\u0026rsquo;m SO going to use this more often, even if it\u0026rsquo;s just to get a baseline for a customer. Saves tons of time!\nJan De Vries, Microsoft MVP\n  \u0026ldquo;Hey @isaac_abraham, #Farmer is kind of awesome. A few lines and my fav env is created. #ILike\u0026rdquo;\nJan(ek) Fellien, Microsoft MVP\n  \u0026ldquo;Finally took a look at farmer just now\u0026hellip;. I should have looked months ago. I mean, I can actually read a farmer template. And it makes sense?!\u0026rdquo;\nArjen Smits\n  \u0026ldquo;With Farmer we were finally able to organize our Azure infrastructure. No messy names of storageaccounts anymore. Thanks for this great tool!\u0026rdquo;\nTim Forkmann, Head of EnergyData at Danpower\n "},{"uri":"https://compositionalit.github.io/farmer/links/","title":"Links","tags":[],"description":"","content":"In this page, you can find blog posts, videos and tweets on Farmer that will give you a better sense of the scenery and the dialogue around it.\nBlog Posts  Compositional IT articles on Farmer Azure SQL Database deployment with Farmer, DbUp and GitHub Actions Introduction to Farmer - IaC with Azure Farmer: Simpler ARM deployments with Octopus Deploy  Videos  Learn how to deploy complete .NET Web Apps to Azure in less than 5 minutes! Working with raw JSON ARM resources with Farmer Authoring ARM templates the easy way with Farmer Making Infrastructure as Code Easier in Azure Introduction to Farmer and Stepping up the game with ARM templates  "},{"uri":"https://compositionalit.github.io/farmer/contributing/","title":"Contributing","tags":[],"description":"","content":"Thanks for thinking about contributing! Azure is a giant beast and help supporting more use-cases is always appreciated. To make it easier to contribute, we put together this little guide. Please take a few minutes to read through before starting work on a pull request (PR) to Farmer.\nThe process (don\u0026rsquo;t worry\u0026hellip; this is not waterfall)  Open an issue, or comment on an existing open issue covering the resource you would like to work on. Basically, a PR from you should not come as a surprise. Implement the 20% of features that cover 80% of the use cases. PR against the master branch from your fork. Add/update tests as required. Create a new *.md file with the name of your resource in the folder /content/api-overview/resources/. Eg. container-registry.md Add a description, keywords, and an example to the docs page. PRs need to pass build/test against both Linux \u0026amp; Windows build, and a review, before being merged in.  TODO There\u0026rsquo;s still more to document!\n Validation best practices Multiple resource builders Linking resources (one-to-many relationships) Post-deploy tasks  "},{"uri":"https://compositionalit.github.io/farmer/faq/","title":"FAQs","tags":[],"description":"","content":"How can I help? Try out Farmer and see what you think.\n Create as many issues as you can for both bugs, discussions and features Create suggestions for features and the most important elements you would like to see added  I have an Azure subscription, but I\u0026rsquo;m not an expert. I like the look of this - how do I \u0026ldquo;use\u0026rdquo; it?  Create an ARM template using the Farmer sample app. Follow the steps here to deploy the generated template into Azure. Log any issues or ideas that you find here.  How do I get Farmer to work from a continuous deployment (CD) process?  Look at some of the alternative strategies outlined here. Read up on ARM deployment strategies e.g. Azure Devops have guides here.  The Farmer .NET Template also has support for creating a Azure Devops-ready application from scratch.\nI don\u0026rsquo;t know F#. Would you consider writing a C# version of this? I\u0026rsquo;m afraid not. F# isn\u0026rsquo;t hard to learn (especially for simple DSLs such as this), and you can easily integrate F# applications as part of a dotnet solution, since F# is a first-class citizen of the dotnet core ecosystem. You can even create new resources in C# since the core abstractions of Farmer are two simple .NET interfaces.\nAre you trying to replace ARM templates? No, we\u0026rsquo;re not. Farmer generates ARM templates that can be used just as normal; Farmer can also be used simplify to make the process of getting started much simpler, or incorporated into your build pipeline as a way to avoid managing difficult-to-manage ARM templates and instead use them as the final part of your build / release pipeline.\nAre you trying to compete with Pulumi? No, we\u0026rsquo;re not. Farmer has (at least currently) a specific goal in mind, which is to lower the barrier to entry for creating and working with ARM templates. We\u0026rsquo;re not looking to create a cross-platform DSL to also support things like Terraform etc. or provide a stateful service store that Pulumi offers. Instead, Farmer is a simple way to continue to use ARM templates today but benefit from a more rapid authoring and maintenance process.\nThere\u0026rsquo;s no support for variables or parameters! Farmer intentionally has limited support for ARM parameters and variables. Read here to find out the alternatives.\nCan I add resources that are not supported by Farmer? Yes. You can use some adapters that Farmer provides to generate resources using basic .NET objects, or even paste ARM template JSON directly into Farmer and have that embedded inside. See the following links from the Contributing section:\n Using raw JSON with Resource.ofJSON Using anonymous records or objects with Resource.ofObj Using the IArmResource interface.  The resource I need isn\u0026rsquo;t included! Create an issue on our github repository, ideally with a sample ARM template and a link to the official Microsoft documentation on the resource. We can\u0026rsquo;t promise we\u0026rsquo;ll look at it immediately, but raising the issue is an important first step to getting more resources supported.\nBut our organisation really needs that resource enhancement today! Drop us an email explaining what you need; we\u0026rsquo;re happy to discuss a commercial support arrangement to provide you with features that you need in a more timely fashion.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/iot-hub/","title":"IOT Hub","tags":[],"description":"","content":"Overview The IOT Hub builder creates IOT Hub and linked Provision Services.\n IOT Hubs (Microsoft.Devices/IotHubs) Provisioning Services (Microsoft.Devices/provisioningServices)  Builder Keywords    Keyword Purpose     name Specifies the name of the IOT Hub   sku Sets the SKU of the IOT Hub   capacity Sets the name of the capacity for the IOT Hub instance   partition_count Sets the name of the SKU/Tier for the IOT Hub instance   retention_days Sets the name of the SKU/Tier for the IOT Hub instance   enable_device_provisioning Sets the name of the SKU/Tier for the IOT Hub instance    Configuration Members    Member Purpose     GetKey Returns an ARM expression to retrieve the IOT Hub key for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.   GetConnectionString Returns an ARM expression to generate an IOT Hub connection string for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let hub = iotHub { name \u0026#34;yourhubname\u0026#34; sku IotHub.B1 capacity 2 partition_count 2 retention_days 3 enable_device_provisioning } let deployment = arm { location Location.NorthEurope add_resource hub output \u0026#34;iot_key\u0026#34; (hub.GetKey IotHub.IotHubOwner) output \u0026#34;iot_connection\u0026#34; (hub.GetConnectionString IotHub.RegistryReadWrite) } "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/","title":"Supporting a new ARM Resource","tags":[],"description":"","content":"This set of guided exercises shows the different steps required to design new ARM resources that can be consumed in Farmer. This tutorial will show you the steps to take create a resource that can hook into the Farmer pipeline, by adding support to Farmer for the ContainerRegistry Azure resource. This will involve:\n Defining an type that implements IArmResource that maps directly to the ARM template output. Defining any domain types required to capture details on the resource. Defining a type that implements IBuilder and an associated computation expression that will be easier for users to consume than an F# record.  This will end up allowing us to define a resource that looks like this:\nlet myRegistry = containerRegistry { name \u0026#34;devonRegistry\u0026#34; sku ContainerRegistrySku.Basic enable_admin_user } let deployment = arm { location Location.WestCentralUS add_resource myRegistry } which generates JSON looking something like this:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#\u0026#34;, \u0026#34;contentVersion\u0026#34;: \u0026#34;1.0.0.0\u0026#34;, \u0026#34;outputs\u0026#34;: {}, \u0026#34;parameters\u0026#34;: {}, \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westcentralus\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;my-registry\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: true }, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Basic\u0026#34; }, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; } ] } Useful terminology  Resource: A resource is a single Azure service provided by ARM; in Farmer these resource models are created by implementing the IArmResource interface. Template: Represents an ARM template with parameters, outputs and zero, one or many resources. Location: An Azure Region where a service exists. Deployment: Represents the deployment of an ARM template to a specific Location and Resource Group name. Builder: In Farmer, an IBuilder represents provides the capability of creating a smart type that helps model a resource or a collection of resources into associated IArmResource objects required for constructing the ARM template. For example, Farmer\u0026rsquo;s WebApp builder provides a logical abstraction on top of several ARM resources: Web App, Server Farm and Application Insights.  Requirements  Minimum version is 2.5.0 of Azure CLI Azure account to test against  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/","title":"Resources","tags":[],"description":"","content":"Resources Farmer currently has support for the most popular resources in Azure, such as Storage, App Service and Functions. You can find out more about each resource in detail in the menu.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/keyvault/","title":"Key Vault","tags":[],"description":"","content":"Overview The KeyVault package contains three builders, for the different components used by KeyVault: One for access policies, one for secrets, and one for the overall keyvault container.\n KeyVault (Microsoft.KeyVault/vaults) Secrets (Microsoft.KeyVault/vaults/secrets)  Secret Builder The secret builder allows you to store secrets into key vault. Values for a secret are passed by Secure String parameters.\n   Keyword Purpose     name Sets the name of the secret.   value Sets the name of the secure string parameter that will contain the value of the secret.   content_type Sets the content type of the secret.   enable_secret Enables the secret.   disable_secret Disables the secret.   activation_date Sets the activation date of the secret.   expiration_date Sets the expiration date of the secret.   depends_on Sets the dependencies of the key vault.   add_tag Adds a tag to the secret.   add_tags Adds multiple tags to the secret.    Access Policy Builder The Access Policy builder allows you to create access policies for key vault.\n   Keyword Purpose     object_id Sets the Object ID of the permission set.   application_id Sets the Application ID of the permission set.   key_permissions Sets the Key permissions of the permission set.   storage_permissions Sets the Storage permissions of the permission set.   secret_permissions Sets the Secret permissions of the permission set.   certificate_permissions Sets the Certificate permissions of the permission set.    Key Vault Builder The Key Vault builder contains access policies, secrets, and configuration information to create a full key vault account.\n   Keyword Purpose     name Sets the name of the vault.   sku Sets the sku of the vault.   tenant_id Sets the Tenant ID of the vault.   enable_vm_access Allows VM access to the vault.   disable_vm_access Disallows VM access to the vault.   enable_resource_manager_access Allows Resource Manager access to the vault.   disable_resource_manager_access Disallows Resource Manager access to the vault.   enable_disk_encryption_access Allows Azure Disk Encyption service access to the vault.   disable_disk_encryption_access Disallows Azure Disk Encyption service access to the vault.   enable_rbac Enables Azure role based access control for data access.   disable_rbac Disables Azure role based access control for data access.   enable_soft_delete Enables VM access to the vault.   enable_soft_delete_with_purge_protection Disables VM access to the vault.   uri Sets the URI of the vault.   enable_recovery_mode Sets the Creation Mode to Recovery.   disable_recovery_mode Sets the Creation Mode to Default.   add_access_policy Adds an access policy to the vault.   add_access_policies Adds access policies to the vault.   enable_azure_services_bypass Allows Azure traffic can bypass network rules.   disable_azure_services_bypass Disallows Azure traffic can bypass network rules.   allow_default_traffic Allow traffic if no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   deny_default_traffic Deny traffic when no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   add_ip_rule Adds an IP address rule. This can be an IPv4 address range in CIDR notation, such as \u0026lsquo;124.56.78.91\u0026rsquo; (simple IP address) or \u0026lsquo;124.56.78.0/24\u0026rsquo; (all addresses that start with 124.56.78).   add_vnet_rule Adds a virtual network rule. This is the full resource id of a vnet subnet, such as \u0026lsquo;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026rsquo;.   add_secret Adds a secret to the vault. This can either be a \u0026ldquo;full\u0026rdquo; secret config created using the Secret Builder, a string literal value which represents the parameter name, or a string literal with a resource and an expression based on that resource e.g. a storage account and the Key member.   add_secrets Adds multiple secrets to the vault. This can either be \u0026ldquo;full\u0026rdquo; secret configs created using the Secret Builder, string literal values which represents the parameter name.   add_tag Adds a tag to the key vault.   add_tags Adds multiple tags to the key vault.    Utilities  The KeyVault module comes with a set of utility functions to quickly create access policies if you do not wish to use the AccessPolicy builder, in the Farmer.KeyVault.AccessPolicy module which enable creating an access policy for a PrincipalId or an ObjectId which will have the GET Secret permission. In addition, the AccessPolicy module also contains helpers to search for users or groups in active directory (requires Azure CLI installed), as well as their Object IDs. These can be used to rapidly create Access Policies for specific users.  Example open Farmer open Farmer.Builders open System let policy = accessPolicy { object_id Guid.Empty application_id Guid.Empty certificate_permissions [ KeyVault.Certificate.List ] secret_permissions KeyVault.Secret.All key_permissions [ KeyVault.Key.List ] } let complexSecret = secret { name \u0026#34;myComplexSecret\u0026#34; content_type \u0026#34;application/text\u0026#34; enable_secret activation_date (DateTime.Today.AddDays -1.) expiration_date (DateTime.Today.AddDays 1.) } let vault = keyVault { name \u0026#34;MyVault\u0026#34; sku KeyVault.Sku.Standard tenant_id Guid.Empty enable_disk_encryption_access enable_resource_manager_access enable_soft_delete_with_purge_protection disable_vm_access enable_recovery_mode add_access_policy policy enable_azure_services_bypass add_ip_rule \u0026#34;127.0.0.1\u0026#34; add_vnet_rule \u0026#34;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026#34; allow_default_traffic add_secret complexSecret add_secret \u0026#34;simpleSecret\u0026#34; add_secrets [ \u0026#34;firstSecret\u0026#34;; \u0026#34;secondSecret\u0026#34;] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/loganalytics/","title":"Log Analytics","tags":[],"description":"","content":"Overview The Log Analytics builder is used to create Work space instances.\n Log Analytics (Microsoft.OperationalInsights/workspaces)  Builder Keywords    Keyword Purpose     name Sets the name of the log analytics instance.   retention_period Sets the retention period for logs in days.   enable_ingestion Enables ingestion network traffic.   enable_query Enables query network traffic.   daily_cap Specifies an upper limit on the amount of data to ingest daily.   add_tags Adds a set of tags to the resource   add_tag Adds a tag to the resource    Example open Farmer open Farmer.Builders let myAnalytics = logAnalytics { name \u0026#34;myloganalytics\u0026#34; retention_period 30\u0026lt;Days\u0026gt; enable_ingestion enable_query daily_cap 5\u0026lt;Gb\u0026gt; add_tag \u0026#34;tag1\u0026#34; \u0026#34;myTestResourceFarmer\u0026#34; } let deployment = arm { location Location.WestEurope add_resource myRegistry } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/managed-identity/","title":"Managed Identity","tags":[],"description":"","content":"Overview Managed Identity is used to create an identity that resources can run under automatically. This is similar to a service principal except that there is no credential to manage and the authorization token is retrieved through a secure internal handshake between the resource and the identity service in Azure.\n User Assigned Identity (Microsoft.ManagedIdentity/userAssignedIdentities)  Using a managed identity as opposed to e.g. connection strings brings several benefits:\n There is no client secret or certificate to configure and rotate because this is handled implicitly by Azure infrastructure. The identity is tied to one or more specific resources, so cannot be used by anything else, like a user. Many services allow more granular permissions than e.g. a connection string. You can grant and revoke access completely independently of the application attempting to gain access to the resource.  Once created, the managed identity resource can be referenced by other resources both in order to:\n Enable a resource to run as that identity Enable a resource to grant permissions to that identity  For example, you may wish to run a Virtual Machine or an Web App under a identity that you create, and then to grant permissions to that identity to allow reading from a storage account. You can define the permissions completely independently of the Virtual Machine or Web App.\ngraph LR A(identity) B(virtual machine)-. runs as .-A D(web app)-. runs as .-A C(storage account)-. grants permissions .-A A -. request made in this identiy .-C   See here and here for the official documentation on the Microsoft Azure docs website.\n Identity Types in Azure Identities come in two flavours in Azure: System and User assigned.\n System Identities are available whenever you create a resource, such as a VM. Each resource has its own system identity, and they cannot be shared across resources. User Identities are created by you; they exist idependently of any resources and thus can be shared across them. In Farmer, the userAssignedIdentity builder can be used for this. You also need to \u0026ldquo;link\u0026rdquo; a user identity to the resource that you wish to be able to \u0026ldquo;run as\u0026rdquo; it.   User Assigned Identities are themselves ARM resources and need to be added to your Farmer arm {} blocks!\n graph LR A(user assigned identity) subgraph Web App B(system identity) end C(storage account) C -.grants permissions .- A C -.grants permissions .- B  User Assigned Identity Builder The userAssignedIdentity builder constructs user assigned managed identities which can be created and then assigned to one or more resources.\n   Keyword Purpose     name Sets the name of the user assigned identity.   add_tag Adds a tag to the user assigned identity resource.   add_tags Adds multiple tags to the user assigned identity resource.    Helper Methods Because the User Assigned Identity builder is so simple, we also provide a simple builder function to create identities as an alternative to using the standard builder syntax:\nopen Farmer.Builders let uai = createUserAssignedIdentity \u0026#34;mytestidentity\u0026#34; Example: System Identity In this example, a web app needs a secret from a key vault. By using the system identity on the web app, application code can be granted access to the key vault with no need to provide it a client secret.\nopen Farmer open Farmer.Builders let wa = webApp { name \u0026#34;myApp\u0026#34; system_identity // turn on the system identity of the web app } let vault = keyVault { name \u0026#34;my-vault\u0026#34; add_access_policies [ // grant access to the web app\u0026#39;s system identity to key vault.  // by default GET and LIST permissions are granted.  AccessPolicy.create wa.SystemIdentity ] } let template = arm { add_resources [ wa; vault ] } There is no need to add a specific identity resource to Farmer in this case because the System Identity is created along with the web app itself.\nExample: User Assigned Identity In this example, a web app needs access to a Storage Account with a specific role. By assigning an identity to the web app, the application code can be granted access to the storage account; we also provide the Client Id to the application as a public setting in order for the application to correctly impersonate as the identity within code.\nBy creating a user assigned identity, unlike a system identity, we can also apply this identity onto other resources so that they, too, can \u0026ldquo;share\u0026rdquo; the permissions and identity. In this example, we also apply the identity onto a container group.\n// Create a user assigned identity let sharedIdentity = userAssignedIdentity { name \u0026#34;container-group-identity\u0026#34; } // Apply it onto the web app let myWeb = webApp { name \u0026#34;myApp\u0026#34; // Add the identity to the web app  add_identity sharedIdentity // Provide the client id to the app for use in code  setting \u0026#34;ClientId\u0026#34; sharedIdentity.ClientId } let group = containerGroup { name \u0026#34;myapp-with-identity\u0026#34; add_instances [ containerInstance { name \u0026#34;my-app\u0026#34; image \u0026#34;myregistry.azurecr.io/myapp:latest\u0026#34; } ] // Also apply it here. All of the containers in this group share this managed identity.  add_identity sharedIdentity } let data = storageAccount { name \u0026#34;dataidentity\u0026#34; // Allow the shared identity blob data reader access to storage.  grant_access sharedIdentity Roles.StorageBlobDataReader } let deployment = arm { add_resources [ sharedIdentity myWeb group data ] } In this example, notice that we explicitly add the sharedIdentity resource to the arm {} block.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/maps/","title":"Maps","tags":[],"description":"","content":"Overview The Maps builder creates Azure Maps accounts.\n Maps (Microsoft.Maps/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Maps account.   sku Sets the sku of the Azure Maps account.    Example open Farmer open Farmer.Builders let myMaps = maps { name \u0026#34;mymaps\u0026#34; sku Maps.S0 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/nsg/","title":"Network Security Group","tags":[],"description":"","content":"Overview The Network Security Group builder creates network security groups with rules for securing network access to resources.\n Network Security Groups (Microsoft.Network/networkSecurityGroups) Security Rules (Microsoft.Network/networkSecurityGroups/securityRules)  Builder Keywords    Applies To Keyword Purpose     nsg name Specifies the name of the network security group   nsg add_rules Adds security rules to the network security group   securityRule name The name of the security rule   securityRule description The description of the security rule   securityRule services The services port(s) and protocol(s) protected by this security rule   securityRule add_source Specify access from any source protocol, address, and port   securityRule add_source_any Specify access from any address and any port   securityRule add_source_address Specify access from a specific address and any port   securityRule add_source_network Specify access from a specific network and any port   securityRule add_source_tag Specify access from a tagged source such as \u0026ldquo;Internet\u0026rdquo;, \u0026ldquo;VirtualNetwork\u0026rdquo;, or \u0026ldquo;AzureLoadBalancer\u0026rdquo;   securityRule add_destination Specify access to any source protocol, address, and port   securityRule add_destination_any Specify access to any address and any port   securityRule add_destination_address Specify access to a specific address and any port   securityRule add_destination_network Specify access from a specific network and any port   securityRule add_destination_tag Specify access to a tagged destination such as \u0026ldquo;Internet\u0026rdquo;, \u0026ldquo;VirtualNetwork\u0026rdquo;, or \u0026ldquo;AzureLoadBalancer\u0026rdquo;   securityRule allow Allows this traffic (the default)   securityRule deny Denies this traffic    Basic Example open Farmer open Farmer.Builders open Farmer.NetworkSecurity // Create a rule for https services accessible from the internet let httpsAccess = securityRule { name \u0026#34;web-servers\u0026#34; services [ NetworkService (\u0026#34;https\u0026#34;, Port 443us) ] add_source_tag TCP \u0026#34;Internet\u0026#34; add_destination_any } // Create an NSG and add the rule to it. let myNsg = nsg { name \u0026#34;my-nsg\u0026#34; add_rules [ httpsAccess ] } Multiple Tier Private Network Example open Farmer open Farmer.Builders open Farmer.NetworkSecurity // Many services have a few ports, such as web services that are often on 80 and 443. // Some services only have a single port // Different tiers may reside on different network segments let corporateNet = \u0026#34;172.24.0.0/20\u0026#34; let webNet = \u0026#34;10.100.30.0/24\u0026#34; let appNet = \u0026#34;10.100.31.0/24\u0026#34; let dbNet = \u0026#34;10.100.32.0/24\u0026#34; // Create a rule for web servers - the \u0026#39;web\u0026#39; service, accessible from the corporate network let webAccess = securityRule { name \u0026#34;web-servers\u0026#34; description \u0026#34;Public web server access\u0026#34; services [ NetworkService (\u0026#34;http\u0026#34;, Port 80us) NetworkService (\u0026#34;https\u0026#34;, Port 443us) ] add_source_network TCP corporateNet add_destination_network webNet } // Create another rule for app servers - accessible only from network with the web servers let appAccess= securityRule { name \u0026#34;app-servers\u0026#34; description \u0026#34;Internal app server access\u0026#34; services [ NetworkService (\u0026#34;http\u0026#34;, Port 8080us) ] add_source_network TCP webNet add_destination_network appNet } // Create another rule for DB servers - accessible only from network with the app servers let dbAccess = securityRule { name \u0026#34;db-servers\u0026#34; description \u0026#34;Internal database server access\u0026#34; services [ NetworkService (\u0026#34;postgres\u0026#34;, Port 5432us)] add_source_network TCP appNet add_destination_network dbNet } // Create an NSG and add all 3 rules to it. let myNsg = nsg { name \u0026#34;my-nsg\u0026#34; add_rules [ webAccess appAccess dbAccess ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/postgresql/","title":"PostgreSQL","tags":[],"description":"","content":"Overview The PostgreSQL module contains two builders - postgreSQL, used to create PostgreSQL Azure servers, and postgreSQLDb, used to create individual databases. It supports features such as firewall, autogrow and version selection. Every PostgreSQL Azure server you create will automatically create a SecureString parameter for the admin account password.\n PostgreSQL server (Microsoft.DBforPostgreSQL/servers)  PostgreSQL Builder keywords    Applies To Keyword Purpose     Server name (string) Sets the name of the PostgreSQL server.   Server admin_username (string) Sets the admin username of the server.   Server geo_redundant_backup (bool) Enables/disables geo-redundant backup   Server enable_geo_redundant_backup Enables geo-redundant backup   Server disable_geo_redundant_backup Disables geo-redundant backup   Server storage_autogrow (bool) Enables/disables auto-grow storage   Server enable_storage_autogrow Enables auto-grow storage   Server disable_storage_autogrow Disables auto-grow storage   Server storage_size (int\u0026lt;Gb\u0026gt;) Sets the initial size of the storage available   Server backup_retention (int\u0026lt;Days\u0026gt;) Sets the number of days to keep backups   Server server_version (Version) Selects the PostgreSQL version of the server   Server capacity (int\u0026lt;VCores\u0026gt;) Sets the number of cores for the server   Server tier (Sku) Sets the service tier of the server   Server add_database (database:Database) Adds a database from the result of a postgreSQLDb builder expression   Server add_database (name:string) Adds a database with name of name   Server enable_azure_firewall Enables firewall access to all Azure services   Server add_firewall_rule (name:string, start ip:string, end ip:string) Adds a firewall rule to the server    PostgreSQLDb Builder keywords    Applies To Keyword Purpose     Database name (string) Sets the name of the PostgreSQL database   Database collation (string) Sets the collation of the postgreSQL database   Database charset (string) Sets the charset of the postgreSQL database    Example open Farmer open Farmer.Builders open Farmer.PostgreSQL let myPostgres = postgreSQL { admin_username \u0026#34;adminallthethings\u0026#34; name \u0026#34;aserverformultitudes42\u0026#34; capacity 4\u0026lt;VCores\u0026gt; storage_size 50\u0026lt;Gb\u0026gt; tier GeneralPurpose add_database \u0026#34;my_db\u0026#34; enable_azure_firewall } let template = arm { location Location.NorthEurope add_resource myPostgres } // WARNING: // since there is currently no free tier for PostgreSQL, actually deploying this // *will* incur spending on your subscription. template |\u0026gt; Write.quickWrite \u0026#34;postgres-example\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/redis/","title":"Redis Cache","tags":[],"description":"","content":"Overview The Redis builder creates managed Redis Cache accounts.\n Redis (Microsoft.Cache/redis)  Builder Keywords    Keyword Purpose     name Sets the name of the Redis cache instance.   sku Sets the sku of the Redis cache instance.   capacity Sets the capacity level of the Redis cache instance, should be between 1-6 - see here.   enable_non_ssl_port Enabled access to the cache over the non-SSL port.   setting Allows you to set a Redis-cache specific setting at deployment-time    Configuration Members    Member Purpose     Key Gets an ARM expression for the primary key of the Redis cache instance.    Example open Farmer open Farmer.Builders.Redis let myCache = redis { name \u0026#34;myredis\u0026#34; sku Redis.Standard capacity 1 enable_non_ssl_port setting \u0026#34;maxclients\u0026#34; 256 setting \u0026#34;maxmemory-reserved\u0026#34; 2 setting \u0026#34;maxfragmentationmemory-reserved\u0026#34; 12 setting \u0026#34;maxmemory-delta\u0026#34; 2 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/signalr/","title":"SignalR","tags":[],"description":"","content":"Overview The SignalR builder creates SignalR services.\n SignalR Service (Microsoft.SignalRService/signalR)  Builder Keywords    Keyword Purpose     name Sets the name of the SignalR service.   sku Sets the sku of the SignalR service.   capacity Sets the capacity of the SignalR service. (optional)   allowed_origins Sets the allowed origins of the SignalR service. (optional)    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the primary connection string of the service. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let mySignalR = signalR { name \u0026#34;mysignalr\u0026#34; sku SignalR.Standard capacity 10 allowed_origins [ \u0026#34;https://github.com\u0026#34; ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/search/","title":"Search","tags":[],"description":"","content":"Overview The Search builder creates storage accounts and their associated containers.\n Search (Microsoft.Search/searchServices)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Search instance.   sku Sets the sku of the Azure Search instance.   replicas Sets the replica count of the Azure Search instance.   partitions Sets the number of partitions of the Azure Search instance.    Configuration Members    Member Purpose     AdminKey Gets an ARM expression for the admin key of the search instance.   QueryKey Gets an ARM expression for the query key of the search instance.    Example open Farmer open Farmer.Builders let mySearch = search { name \u0026#34;isaacsSearch\u0026#34; sku Search.Basic } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/service-bus/","title":"Service Bus","tags":[],"description":"","content":"Overview The Service Bus builder creates service bus namespaces and their associated queues.\n Service Bus Namespaces (Microsoft.ServiceBus/namespaces)  Builder Keywords    Applies To Keyword Purpose     Queue name The name of the queue.   Queue lock_duration_minutes The length of time that a lock can be held on a message.   Queue max_delivery_count The maximum number of times a message can be delivered before dead lettering.   Queue duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for.   Queue enable_session Enables session support.   Queue enable_dead_letter_on_message_expiration Enables dead lettering of messages that expire.   Queue enable_partition Enables partition support on the queue.   Queue link_to_namespace Link this queue to an existing namespace instead of creating a new one.   Queue message_ttl Time To Live (TTL) value for messages expressed as a TimeSpan string, such as \u0026lsquo;01:30:00\u0026rsquo; 1 hour, 30 minutes.   Queue message_ttl_days Time To Live (TTL) value for messages in days.   Subscription name The name of the subscription.   Subscription lock_duration_minutes The length of time that a lock can be held on a message.   Subscription max_delivery_count The maximum number of times a message can be delivered before dead lettering.   Subscription duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for.   Subscription enable_session Enables session support.   Subscription enable_dead_letter_on_message_expiration Enables dead lettering of messages that expire.   Subscription enable_partition Enables partition support on the queue.   Subscription link_to_namespace Link this queue to an existing namespace instead of creating a new one.   Subscription add_filters Adds multiple filters to a subscription   Subscription add_sql_filter Adds a filter to a subscription using SQL syntax.   Subscription add_correlation_filter Adds a filter to a subscription using header value correlation.   Topic name The name of the topic.   Topic duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for.   Topic enable_partition Enables partition support on the topic.   Topic message_ttl Time To Live (TTL) value for messages expressed as a TimeSpan string, such as \u0026lsquo;01:30:00\u0026rsquo; 1 hour, 30 minutes, or as an integer days e.g. 4\u0026lt;Days\u0026gt;.   Namespace sku The ServiceBusNamespaceSku e.g. Standard   Namespace namespace_name The name of the namespace that holds the queue.   Namespace depends_on Sets dependencies on the service bus namespace.    Configuration Members    Member Purpose     NamespaceDefaultConnectionString Returns an ARM expression to retrieve the Primary Connection String of the service bus.   DefaultSharedAccessPolicyPrimaryKey Returns an ARM expression to retrieve the Primary Key of the service bus.    Example open Farmer open Farmer.Builders open Farmer.ServiceBus let myServiceBus = serviceBus { name \u0026#34;my-namespace\u0026#34; sku Standard add_queues [ queue { name \u0026#34;queueA\u0026#34; } queue { name \u0026#34;queueB\u0026#34; } ] add_topics [ topic { name \u0026#34;topicA\u0026#34; } topic { name \u0026#34;topicB\u0026#34; } ] } let deployment = arm { location Location.NorthEurope add_resource myServiceBus output \u0026#34;connectionString\u0026#34; myServiceBus.NamespaceDefaultConnectionString output \u0026#34;defaultSharedAccessPolicyPrimaryKey\u0026#34; myServiceBus.DefaultSharedAccessPolicyPrimaryKey } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/sql/","title":"SQL Azure","tags":[],"description":"","content":"Overview The SQL Azure module contains two builders - sqlServer, used to create SQL Azure servers, and sqlDb, used to create individual databases. It supports features such as encryption, firewalls and automatic pool creation. Every SQL Azure server you create will automatically create a SecureString parameter for the admin account password.\n SQL Azure server (Microsoft.Sql/servers)  SQL Server Builder Keywords    Keyword Purpose     server_name Sets the name of the SQL server.   add_firewall_rule Adds a custom firewall rule given a name, start and end IP address range.   enable_azure_firewall Adds a firewall rule that enables access to other Azure services.   admin_username Sets the admin username of the server.   elastic_pool_name Sets the name of the elastic pool, if required. If not set, Farmer will generate a name for you.   elastic_pool_sku Sets the sku of the elastic pool, if required. If not set, Farmer will default to Basic 50.   elastic_pool_database_min_max Sets the optional minimum and maximum DTUs for the elastic pool for each database.   elastic_pool_capacity Sets the optional disk size in MB for the elastic pool for each database.    SQL Server Configuration Members    Member Purpose     ConnectionString Gets a literal .NET connection string using the administrator username / password, given a database or database name. The password will be evaluated based on the contents of the password parameter supplied to the template at deploy time.   PasswordParameter Gets a string that represents the parameter password required for deployment on the sql instance by Farmer e.g. \u0026ldquo;password-for-mysqlserver\u0026rdquo;.    SQL Database Builder Keywords    Keyword Purpose     name Sets the name of the database.   sku Sets the sku of the database. If not set, the database is assumed to be part of an elastic pool which will be automatically created.   hybrid_benefit If a VCore-style SKU is selected, this allows you to use Azure Hybrid Benefit licensing.   db_size Sets the maximum database size.   collation Sets the collation of the database.   use_encryption Enables transparent data encryption of the database.    Example open Farmer open Farmer.Builders open Sql let myDatabases = sqlServer { name \u0026#34;my_server\u0026#34; admin_username \u0026#34;admin_username\u0026#34; enable_azure_firewall elastic_pool_name \u0026#34;mypool\u0026#34; elastic_pool_sku PoolSku.Basic100 add_databases [ sqlDb { name \u0026#34;poolDb1\u0026#34; } sqlDb { name \u0026#34;poolDb2\u0026#34; } sqlDb { name \u0026#34;dtuDb\u0026#34;; sku Basic } sqlDb { name \u0026#34;memoryDb\u0026#34;; sku M_8 } sqlDb { name \u0026#34;cpuDb\u0026#34;; sku Fsv2_8 } sqlDb { name \u0026#34;businessCriticalDb\u0026#34;; sku (BusinessCritical Gen5_2) } sqlDb { name \u0026#34;hyperscaleDb\u0026#34;; sku (Hyperscale Gen5_2) } sqlDb { name \u0026#34;generalPurposeDb\u0026#34; sku (GeneralPurpose Gen5_8) db_size (1024\u0026lt;Mb\u0026gt; * 128) hybrid_benefit } ] } let template = arm { location Location.NorthEurope add_resource myDatabases } template |\u0026gt; Writer.quickWrite \u0026#34;sql-example\u0026#34; template |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ \u0026#34;password-for-my_server\u0026#34;, \u0026#34;*****\u0026#34; ] "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/static-web-app/","title":"Static Web Apps","tags":[],"description":"","content":"Overview The Static Web App builder is used to create Static Web Apps. The Static Web App service is modern web app service that offers streamlined full-stack development from source code to global high availability. You can use it to host static web applications and Azure Functions in a single resource, using GitHub native workflows to build and deploy your application.\n Static Site (Microsoft.Web/staticSites)   At the time of writing, Static Web Apps are in public preview. Not all Azure locations support them.\n Static Web App Builder Keywords    Keyword Purpose     name Sets the name of the static web app.   repository The URI of the github repository containing your static web app.   artifact_location The folder where the built web app is copied to e.g. build (optional)   api_location The path containing your Azure Functions (optional)   app_location The path containing your application code (optional)   branch The branch that you which to use for the static web app (optional, defaults to \u0026lsquo;master\u0026rsquo;)    Configuration Members    Name Purpose     RepositoryParameter Provides the generated name for the repository token parameter name.    Parameters    Name Purpose     repositorytoken-for-name Provides the Github Personal Access Token (PAT) required to authenticate and create the appropriate Github Action.    Example open Farmer open Farmer.Builders let myApp = staticWebApp { name \u0026#34;isaacsstatic\u0026#34; repository \u0026#34;https://github.com/isaacabraham/staticwebreact\u0026#34; artifact_location \u0026#34;build\u0026#34; api_location \u0026#34;api\u0026#34; } let deployment = arm { location Location.WestEurope add_resource myApp } deployment |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ myApp.RepositoryParameter, \u0026#34;Github personal access token goes here...\u0026#34; ] "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/storage-account/","title":"Storage Account","tags":[],"description":"","content":"Overview The Storage Account builder creates storage accounts and their associated containers.\n Storage Accounts (Microsoft.Storage/storageAccounts) Storage Containers (blobServices/containers) File Shares (fileServices/shares) Queues (Microsoft.Storage/storageAccounts/queueServices/queues) Tables (Microsoft.Storage/storageAccounts/tableServices/tables)  Builder Keywords    Keyword Purpose     name Specifies the name of the storage account   sku Sets the SKU of the storage account. A set of predefined SKU values are available as members in Storage.Sku, but you can create the full range of combinations of Kind and SKU as needed.   default_blob_access_tier Sets the default access tier for blob containers   add_public_container Adds a general-purpose public storage container   add_private_container Adds a general-purpose private storage container   add_blob_container Adds a general-purpose private blob container   add_file_share Adds a file share to storage account   add_file_share_with_quota Adds a file share to storage account with a share quota in Gb   add_queue Adds a queue to the storage account   add_queues Adds a list of queues to the storage account   add_table Adds a table to the storage account   add_tables Adds a list of tables to the storage account   use_static_website Activates static website host, and uploads the provided local content as a post-deployment task to the storage with the specified index page   static_website_error_page Specifies the 404 page to display for static website hosting   enable_data_lake Enables Azure Data Lake Gen2 support on the storage account   add_lifecycle_policy Given a rule name, a list of PolicyActions and a list of string filters, creates a lifecycle policy for the storage account   grant_access Given a managed identity (can be either user- or system- assigned), and a specific RoleId from the Roles module, grants access to the identity for the provided role.    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the storage account\u0026rsquo;s primary connection string. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.   WebsitePrimaryEndpoint Returns an ARM Expression for the Primary endpoint for static website (if enabled).   WebsitePrimaryEndpointHost Returns an ARM Expression for the Host of the Primary endpoint for static website (if enabled). Use this for e.g. Azure CDN integration.    Helpers The StorageAccount type contains helper methods to quickly create ARM expressions for Storage Account connection strings.\nExample open Farmer open Farmer.Builders let storage = storageAccount { name \u0026#34;isaacssuperstorage\u0026#34; sku Storage.Premium_LRS add_public_container \u0026#34;mypubliccontainer\u0026#34; add_private_container \u0026#34;myprivatecontainer\u0026#34; add_blob_container \u0026#34;myblobcontainer\u0026#34; add_file_share \u0026#34;share1\u0026#34; add_file_share_with_quota \u0026#34;share2\u0026#34; 1024\u0026lt;Gb\u0026gt; add_queue \u0026#34;myqueue\u0026#34; add_table \u0026#34;mytable\u0026#34; use_static_website \u0026#34;local/path/to/folder/content\u0026#34; \u0026#34;index.html\u0026#34; static_website_error_page \u0026#34;error.html\u0026#34; enable_data_lake true add_lifecycle_rule \u0026#34;moveToCool\u0026#34; [ Storage.CoolAfter 30\u0026lt;Days\u0026gt;; Storage.ArchiveAfter 90\u0026lt;Days\u0026gt; ] Storage.NoRuleFilters add_lifecycle_rule \u0026#34;cleanup\u0026#34; [ Storage.DeleteAfter 7\u0026lt;Days\u0026gt; ] [ \u0026#34;data/recyclebin\u0026#34; ] grant_access myWebApp.SystemIdentity Roles.StorageBlobDataReader } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/vnet/","title":"Virtual Network","tags":[],"description":"","content":"Overview The Virtual Network builder (vnet) is used to create Azure Virtual Network instances.\n Virtual Network (Microsoft.Network/virtualNetworks) Subnets (Microsoft.Network/virtualNetworks/subnets)  Builder Keywords    Resource Keyword Purpose     vnet name Sets the name of the virtual network.   vnet add_address_spaces Adds address spaces to the virtual network.   vnet add_subnets Adds subnets to the virtual network.   vnet build_address_spaces Automatically builds address spaces for subnet names and sizes.   vnet add_tags Adds a set of tags to the resource   vnet add_tag Adds a tag to the resource   subnet name Name of the subnet resource   subnet prefix Subnet prefix in CIDR notation (e.g. 192.168.100.0/24)   subnet add_delegations Adds one or more delegations to this subnet.   addressSpace space When using build_address_space this specifies the address space.   addressSpace subnets Specifies the subnets to build automatically.   addressSpace build_subnet Specifies the name, size, and service delegations for the subnet.    Example - Manual Subnets A virtual network is defined with the vnet builder. Address spaces and subnets should be added, taking care to ensure the subnets are contained within an address space on the virtual network.\nopen Farmer open Farmer.Builders let myVnet = vnet { name \u0026#34;my-vnet\u0026#34; add_address_spaces [ \u0026#34;192.168.200.0/22\u0026#34; ] add_subnets [ subnet { name \u0026#34;vms\u0026#34; prefix \u0026#34;192.168.200.0/24\u0026#34; } subnet { name \u0026#34;containers\u0026#34; prefix \u0026#34;192.168.201.0/24\u0026#34; add_delegations [ SubnetDelegationService.ContainerGroups ] } subnet { name \u0026#34;databases\u0026#34; prefix \u0026#34;192.168.202.0/24\u0026#34; add_delegations [ SubnetDelegationService.SqlManagedInstances ] } ] } let deployment = arm { location Location.NorthEurope add_resource myVnet } Example - Automatically Build Subnets Address spaces and subnets can be built out automatically to ensure the subnets are contained within the address spaces. This reduces the need for \u0026ldquo;IP math\u0026rdquo; to determine the start addresses for contiguous networks of different sizes.\nopen Farmer open Farmer.Builders let myVnet = vnet { name \u0026#34;my-vnet\u0026#34; build_address_spaces [ addressSpace { space \u0026#34;10.28.0.0/16\u0026#34; subnets [ buildSubnet \u0026#34;vms\u0026#34; 26 buildSubnet \u0026#34;services\u0026#34; 24 buildSubnet \u0026#34;corporate-west\u0026#34; 18 buildSubnet \u0026#34;corporate-east\u0026#34; 18 buildSubnet \u0026#34;GatewaySubnet\u0026#34; 28 buildSubnetDelegations \u0026#34;containers\u0026#34; 27 [ SubnetDelegationService.ContainerGroups ] ] } addressSpace { space \u0026#34;10.30.0.0/16\u0026#34; subnets [ buildSubnet \u0026#34;remote-office\u0026#34; 23 buildSubnet \u0026#34;reserved\u0026#34; 24 buildSubnet \u0026#34;GatewaySubnet\u0026#34; 28 ] } ] } let deployment = arm { location Location.NorthEurope add_resource myVnet } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/vnet-gateway/","title":"Virtual Network Gateway","tags":[],"description":"","content":"Overview The Virtual Network Gateway builder creates virtual network gateways for ExpressRoute or VPN connections to a virtual network.\n Virtual Network Gateways (Microsoft.Network/virtualNetworkGatways) Connections (Microsoft.Network/connections)  Builder Keywords    Applies To Keyword Purpose     Gateway name Specifies the name of the virtual network gateway   Gateway vnet The name of the virtual network to which the gateway connects   Gateway er_gateway_sku SKU for an ExpressRoute gateway   Gateway vpn_gateway_sku SKU for a VPN gateway   Gateway vpn_type Sets the VPN type to route-based (default) or policy-based.   Gateway gateway_ip_config Specifies the gateway public and private IP addresses   Gateway active_active_ip_config Specifies the second public and private IP configuration for a redundant gateway   Gateway disable_bgp BGP is enabled by default, but this can disable it   Gateway vpn_client Specifies the VPN client configuration using the vpnclient builder (optional)   VPNClient add_address_pool The reference of the address space resource which represents Address space for P2S VpnClient   VPNClient add_root_certificate Adds the name and the public data of a root certificate to validate client certificates used for VPN Client connexion. This can be either just the data of the base64 content of the certificate or a multiline string starting with \u0026mdash;\u0026ndash;BEGIN CERTIFICATE\u0026mdash;\u0026ndash; and ending with \u0026mdash;\u0026ndash;END CERTIFICATE\u0026mdash;\u0026ndash;   VPNClient add_revoked_certificate Adds the name and the thumbprint of a revoked client certificate   VPNClient protocols Sets the protocols for the VPN client. SSTP (default), IkeV2 or OpenVPN   Connection name Specifies the name of the connection   Connection vnet_gateway1 Name of the first vnet gateway this is connecting   Connection vnet_gateway2 Name of the second vnet gateway this is connecting, for use when connecting two vnets   Connection local_gateway Name of the local gateway connection for a VPN   Connection peer_id Id of the peer, typically an ExpressRoute circuit Id   Connection auth_key Authorization key used when peering across subscriptions    Example open Farmer open Farmer.Builders open Farmer.VirtualNetworkGateway let gw = gateway { name \u0026#34;er-gateway\u0026#34; vnet \u0026#34;my-vnet\u0026#34; // Must contain a subnet named \u0026#39;GatewaySubnet\u0026#39;  er_gateway_sku ErGatewaySku.Standard vpn_client (vpnclient { add_address_pool \u0026#34;10.31.0.0/16\u0026#34; add_root_certificate \u0026#34;rootcert\u0026#34; \u0026#34;\u0026#34; }) } let privateNet = vnet { name \u0026#34;my-vnet\u0026#34; add_address_spaces [ \u0026#34;10.30.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;GatewaySubnet\u0026#34; prefix \u0026#34;10.30.254.0/28\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/virtual-machine/","title":"Virtual Machine","tags":[],"description":"","content":"Overview The Virtual Machine builder creates a fully configured virtual machine and all its required child resources.\n Virtual Machines (Microsoft.Compute/virtualMachines) Virtual Networks (Microsoft.Network/virtualNetworks) IP Addresses (Microsoft.Network/publicIPAddresses) Network Interfaces (Microsoft.Network/networkInterfaces) Storage Accounts (Microsoft.Storage/storageAccounts)  In addition, every VM you create will add a SecureString parameter to the ARM template, whose name follows the pattern password-for-[virtual machine name].\nBuilder Keywords    Keyword Purpose     name Sets the name of the VM.   diagnostics_support Turns on diagnostics support using an automatically created created storage account.   diagnostics_support_external Turns on diagnostics support using an existing storage account.   vm_size Sets the size of the VM.   username Sets the admin username of the VM (note: the password is supplied as a securestring parameter to the generated ARM template).   operating_system Sets the operating system of the VM. A set of samples is provided in the CommonImages module.   os_disk Sets the size and type of the OS disk for the VM.   add_disk Adds a data disk to the VM with a specific size and type.   add_ssd_disk Adds a SSD data disk to the VM with a specific size.   add_slow_disk Adds a conventional (non-SSD) data disk to the VM with a specific size.   domain_name_prefix Sets the prefix for the domain name of the VM.   address_prefix Sets the IP address prefix of the VM.   subnet_prefix Sets the subnet prefix of the VM.   custom_script Executes the supplied inline custom script on the VM.   custom_script_files Uploads the supplied set of files, specified by URI, to the VM on creation.    Configuration Members    Member Purpose     NicName Provides the resource name of the Network Interface Card (NIC)   VnetName Provides the resource name of the Virtual Network (VNet)   SubnetName Provides the resource name of the subnet   IpName Provides the resource name of the IP Address   Hostname Returns an ARM expression to retrieve the fully-qualified domain name from the virtual machine\u0026rsquo;s DNS settings.\u0026rdquo;    Example open Farmer open Farmer.Builders let myVm = vm { name \u0026#34;myFarmerVm\u0026#34; username \u0026#34;yourUsername\u0026#34; vm_size Vm.Standard_A2 operating_system Vm.WindowsServer_2012Datacenter os_disk 128 Vm.StandardSSD_LRS add_ssd_disk 128 add_slow_disk 512 custom_script \u0026#34;powershell setup-vm.ps1\u0026#34; // you have to actually *call* the script  custom_script_files [ \u0026#34;https://foo.bar/foo/setup-vm.ps1\u0026#34; ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/web-app/","title":"Web App","tags":[],"description":"","content":"Overview The Web App builder is used to create Azure App Service accounts. It abstracts the Service Plan into the same component, and will also create and configure a linked App Insights resource. If you wish to create a website that connects to an existing service plan, use the link_to_service_plan keyword and provide the resource name of the service plan to connect to.\n Web Site (Microsoft.Web/sites) Server Farms (Microsoft.Web/serverfarms) Source Controls (Microsoft.Web/sites/sourcecontrols) Application Insights (Microsoft.Insights/components)  Web App Builder Keywords    Applies To Keyword Purpose     Web App name Sets the name of the web app.   Web App link_to_service_plan Instructs Farmer to link this webapp to a Farmer service plan configuration defined elsewhere in your application, rather than creating a new one.   Web App link_to_unmanaged_service_plan Instructs Farmer to link this webapp to an existing service plan that is externally managed, rather than creating a new one.   Web App app_insights_auto_name Sets the name of the automatically-created app insights instance.   Web App app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   Web App link_to_app_insights Instructs Farmer to link this webapp to a Farmer App Insights configuration defined elsewhere in your application, rather than creating a new one.   Web App link_to_unmanaged_app_insights Instructs Farmer to link this webapp to an existing app insights instance that is externally managed, rather than creating a new one.   Web App run_from_package Sets the web app to use \u0026ldquo;run from package\u0026rdquo; deployment capabilities.   Web App website_node_default_version Sets the node version of the web app.   Web App setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   Web App secret_setting Sets a \u0026ldquo;secret\u0026rdquo; app setting of the web app. You must supply the \u0026ldquo;key\u0026rdquo;, whilst the value will be supplied as a secure parameter.   Web App settings Sets a list of app setting of the web app as tuples in the form of (\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;).   Web App connection_string Creates a connection string whose value is supplied as secret parameter, or as an ARM expression in the tupled form of (\u0026ldquo;key\u0026rdquo;, expr).   Web App connection_strings Creates a set of connection strings of the web app whose values will be supplied as secret parameters.   Web App https_only Disables http for this webapp so that only HTTPS is used.   Web App enable_http2 Configures the webapp to allow clients to connect over http2.0.   Web App disable_client_affinity Stops the webapp from sending client affinity cookies.   Web App enable_websockets Configures the webapp to allow clients to connect via websockets.   Web App depends_on Sets dependencies for the web app.   Web App docker_image Sets the docker image to be pulled down from Docker Hub, and the command to execute as a second argument. Automatically sets the OS to Linux.   Web App docker_ci Turns on continuous integration of the web app from the Docker source repository using a webhook.   Web App docker_use_azure_registry Uses the supplied Azure Container Registry name as the source of the Docker image, instead of Docker Hub. You do not need to specify the full url, but just the name of the registry itself.   Web App add_identity Adds a managed identity to the the Web App. Farmer will automatically set the AZURE_CLIENT_ID application setting to the Client Id of the supplied identity.   Web App system_identity Activates the system identity of the Web App.   Web App enable_cors Enables CORS support for the app. Either specify WebApp.AllOrigins or a list of valid URIs as strings.   Web App enable_cors_credentials Allows CORS requests with credentials.   Web App source_control Given a github repository URI and branch name, configures the web app to automatically deploy those files to the web app   Web App disable_source_control_ci Disables continuous integration from source control on push   Web App enable_source_control_ci Enables continuous integration from source control on push   Web App add_extension Adds the named extension to the Web App   Web App automatic_logging_extension Enables or disables automatically adding the ASP .NET logging extension for netcore apps (defaults to on unless docker_image is set).   Web App worker_process Specifies whether to set the web app to 32 or 64 Bitness.   Web App always_on Sets the \u0026ldquo;Always On\u0026rdquo; flag.   Service Plan service_plan_name Sets the name of the service plan. If not set, uses the name of the web app postfixed with \u0026ldquo;-plan\u0026rdquo;.   Service Plan runtime_stack Sets the runtime stack.   Service Plan operating_system Sets the operating system. If Linux, App Insights configuration settings will be omitted as they are not supported by Azure App Service.   Service Plan sku Sets the sku of the service plan.   Service Plan worker_size Sets the size of the service plan worker.   Service Plan number_of_workers Sets the number of instances on the service plan.     Farmer also comes with a dedicated Service Plan builder that contains all of the above keywords that apply to a Service Plan.\nUse this builder if you wish to have an explicit and clear separation between your web app and service plan. Otherwise, it is recommended to use the service plan keywords that exist directly in the web app builder, and let Farmer handle the connections between them.\n Post-deployment Builder Keywords The Web App builder contains special commands that are executed after the ARM deployment is completed.\n   Keyword Purpose     zip_deploy Supplying a folder or zip file will instruct Farmer to upload the contents directly to the App Service once the ARM deployment is complete.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this web app.   ServicePlan Gets the Resource Name of the service plan for this web app.   AppInsights Gets the Resource Name of the service plan for the AI resource linked to this web app.   SystemIdentity Gets the system-created managed principal for the web app. It must have been enabled using the system_identity keyword.    Key Vault integration The Web App builder comes with special integration into KeyVault. By activating KeyVault integration, the web app builder can automatically link to, or even create, a full KeyVault instance. All Secret or ARM Expression-based Settings (e.g. a setting that links to the Key of a Storage Account) will automatically be redirected to KeyVault. The value will be stored in KeyVault and the system identity will be activated and provided into the KeyVault with GET permissions. Lastly, Web App app settings will remain in place, using the Azure App Service built-in KeyVault redirection capabilities.\nThe following keywords exist on the web app:\n   Member Purpose     use_keyvault Tells the web app to create a brand new KeyVault for this App Service\u0026rsquo;s secrets.   link_to_keyvault Tells the web app to use an existing Farmer-managed KeyVault which you have defined elsewhere. All secret settings will automatically be mapped into KeyVault.   link_to_unmanaged_keyvault Tells the web app to use an existing non-Farmer managed KeyVault which you have defined elsewhere. All secret settings will automatically be mapped into KeyVault.    Examples A basic web application.\nopen Farmer open Farmer.Builders open Farmer.WebApp let myWebApp = webApp { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku WebApp.Sku.B1 always_on app_insights_off worker_size Medium number_of_workers 3 run_from_package system_identity } Using a managed Key Vault instance with automatic secret mapping.\nopen Farmer open Farmer.Builders // Create a basic storage account let data = storageAccount { name \u0026#34;mystorage\u0026#34; } // Create a web application with a sensitive setting of storage key and an explicit \u0026#34;secret\u0026#34; setting // which will be passed through by ARM parameter. let wa = webApp { name \u0026#34;isaac\u0026#34; setting \u0026#34;key\u0026#34; \u0026#34;value\u0026#34; setting \u0026#34;storagekey\u0026#34; data.Key link_to_keyvault (ResourceName \u0026#34;isaacvault\u0026#34;) } // Create a key vault instance and explicitly grant the web application access to it. let v = keyVault { name \u0026#34;isaacvault\u0026#34; add_access_policy (AccessPolicy.create (wa.SystemIdentity.PrincipalId, [ KeyVault.Secret.Get; KeyVault.Secret.List ])) } "},{"uri":"https://compositionalit.github.io/farmer/tutorials/keyvault-certs/","title":"Declarative Steps in an ARM Deployment","tags":[],"description":"","content":"Introduction An ARM deployment typically represents the infrastructure you want deployed as a result of it, referred to as the \u0026ldquo;goal state\u0026rdquo;. For instance, you may want to have a web application with a database, so you\u0026rsquo;ll define your goal state that includes database and web application resources. However, it\u0026rsquo;s not always that simple - there are various reasons that some of the steps of a deployment cannot be represented by the goal state resource model.\n Creating a backup of a database before a deployment. Interacting with API\u0026rsquo;s that aren\u0026rsquo;t represented in ARM itself (Kubernetes control plane, networking devices, or the API\u0026rsquo;s of the application you\u0026rsquo;re deploying). Performing ARM operations such as creating a certificate.  In any of these scenarios, there is some imperative logic that needs to be included in the ARM deployment. To keep the ARM deployment itself repeatable, it\u0026rsquo;s often best to ensure this imperative logic is idempotent - that is, it can run repeatedly without incurring side effects.\nIn this tutorial, we will handle the third case, running an ARM operation to create a certificate in a key vault. We\u0026rsquo;ll create a deploymentScript resource for this, which creates a temporary ARM resource for the purposes of executing this imperative logic.\n Create a user assigned identity. Create a storage account for making the certificate available to the web app. Create a key vault for generating the certificate. Run an imperative script to create a certificate in the key vault and copy it to the storage account. Create a web application in a container group that attaches to the storage account to uses the certificate.    Full code available here\n  Create a user assigned identity A deployment script runs in a temporary container group and needs an identity, as does the container group. This identity will be a contributor over the resources in the resource group where this deployment runs so that it has permissions to upload the certificate to the storage account.\nlet appIdentity = userAssignedIdentity { name \u0026#34;my-app-user\u0026#34; } Create the Certificate Storage Account Depending on the type of compute resource used, you may be able to retrieve the certificate directly from the key vault on startup. However, for a container group, a good solution is to have a file share on a storage account. After creating the certificate, we will download it from the key vault and upload it to this storage account file share to make it available to the container group.\nlet certStorage = storageAccount { name \u0026#34;myappcertstorage123\u0026#34; sku Storage.Sku.Standard_LRS add_file_share \u0026#34;certs\u0026#34; } Create the Key Vault We need to create a key vault to generate the certificate. When a certificate is created in a key vault, the public key is stored as a certificate and the full certificate with private and public key is stored as a secret of the same name. To enable this access, we will need to define an accessPolicy on the key vault that allows our appIdentity to create and retrieve certificates and secrets.\nlet kv = keyVault { name \u0026#34;myappcertificates\u0026#34; add_access_policies [ accessPolicy { object_id appIdentity.PrincipalId secret_permissions [ KeyVault.Secret.Set; KeyVault.Secret.Get ] certificate_permissions [ KeyVault.Certificate.Create; KeyVault.Certificate.Get ] } ] } The Imperative Part: Creating the Certificate Creating a certificate is an imperative operation because this is a multiple step process where a key pair is created, then a certificate signing request is created from the key pair and signed by a certificate authority. Certificates can also be \u0026ldquo;self-signed\u0026rdquo;, meaning they have no certificate authority and must be individually trusted. This whole process means you cannot simply repeat it without side effects, so it is represented in ARM as an operation rather than a resource.\nCreating a certificate in an Azure key vault requires that you provide a policy for the certificate which defines the various settings such as the key size, issuer, and subject name (what identifies the host when presenting the certificate).\nYou can use the default policy directly, but this doesn\u0026rsquo;t let you set the subject name, so instead, we will build our own policy. To get a reference on what a valid policy contains, use the following Azure CLI command to \u0026ldquo;scaffold\u0026rdquo; a policy:\naz keyvault certificate get-default-policy --scaffold\nWe want a policy.json that roughly matches this, with a few adjustments for our scenario. F# anonymous records are very handy for creating JSON directly, so we\u0026rsquo;ll use one here to create a policy JSON string similar to the scaffold. Because we need to embed this in our ARM template so it can run in the deployment script, we\u0026rsquo;ll convert it to base64 and avoid any issues with trying to embed JSON in another JSON file.\nlet policy = {| keyProperties = {| exportable = true keyType = \u0026#34;RSA\u0026#34; keySize = 2048 reuseKey = false |} secretProperties = {| contentType = \u0026#34;application/x-pkcs12\u0026#34; |} x509CertificateProperties = {| subject = \u0026#34;CN=my-web-app.eastus.azurecontainer.io\u0026#34; subjectAlternativeNames = {| dnsNames = [ \u0026#34;my-web-app.eastus.azurecontainer.io\u0026#34; ] |} |} issuerParameters = {| name = \u0026#34;Self\u0026#34; |} |} let policyJsonB64 = policy |\u0026gt; System.Text.Json.JsonSerializer.Serialize // serialize to JSON  |\u0026gt; System.Text.Encoding.UTF8.GetBytes // and then encode it for easy embedding  |\u0026gt; System.Convert.ToBase64String Now for the deployment script itself. This will run the Azure CLI within a temporary container. It needs to perform the following steps:\n Take the embedded base64 policy.json string and write it to the file system where the deployment script runs. Create a certificate, using that policy.json file. Download the secret containing the public and private key pair in a .pfx file. Upload the .pfx file to the storage account file share to make it available to the container group.  The string interpolation in F# 5.0 is very handy for embedding F# values in the bash script statements.\nlet script = [ \u0026#34;set -e\u0026#34; // Write the encoded policy to a file in the deployment script resource.  $\u0026#34;echo {policyJsonB64} | base64 -d \u0026gt; policy.json\u0026#34; // Run imperative az CLI commands to create the certificate.  $\u0026#34;az keyvault certificate create --vault-name {kv.Name.Value} -n my-app-cert -p @policy.json\u0026#34; // Download the cert  $\u0026#34;az keyvault certificate download --file cert.pem --vault-name {kv.Name.Value} -n my-app-cert\u0026#34; // Download the pfx with cert and private key  $\u0026#34;az keyvault secret show --vault-name {kv.Name.Value} -n my-app-cert | jq .value -r | base64 -d \u0026gt; key.pfx\u0026#34; // Upload to storage file  $\u0026#34;az storage file upload --account-name {certStorage.Name.ResourceName.Value} --share-name certs --source key.pfx\u0026#34; ] |\u0026gt; String.concat \u0026#34;;\\n\u0026#34; With the hard part out of the way, we can define the deploymentScript resource, which is a temporary ARM resource that represents running these imperative steps. Because we don\u0026rsquo;t want this to run until the key vault and storage account are available, we need to use depends_on and reference these two resources. Also, notice this uses the appIdentity that was granted access to the key vault secrets and certificates.\ndeploymentScript { name \u0026#34;create-certificate\u0026#34; identity appIdentity depends_on kv depends_on certStorage force_update cleanup_on_success retention_interval 1\u0026lt;Hours\u0026gt; script_content script } Creating the Web Application Our web application will be a simple \u0026ldquo;hello world\u0026rdquo; service, as the interesting part is that it listens on HTTPS. Doing this requires the key pair be loaded by the service when it creates the binding to an HTTPS port. Here is the script content. Notice we need to add the certificate to the X509Store. This avoids some SSL warnings within the service itself due to using a self-signed certificate. If you are using a trusted third party CA, this may not be necessary.\n#r \u0026#34;nuget: Suave, Version=2.6.0\u0026#34; open Suave open System.Security.Cryptography.X509Certificates let certWithKey = new X509Certificate2(\u0026#34;/certs/key.pfx\u0026#34;, \u0026#34;\u0026#34;) let store = new X509Store(StoreName.Root, StoreLocation.CurrentUser) store.Open(OpenFlags.ReadWrite) store.Add(certWithKey) store.Close() let config = { defaultConfig with bindings = [ HttpBinding.createSimple (HTTPS certWithKey) \u0026#34;0.0.0.0\u0026#34; 443 ] } startWebServer config (Successful.OK \u0026#34;Hello Secure Farmers!\u0026#34;) We will read this short script into a string that we can pass to our container group. In real life, you probably have a full application published in a container image, but for illustrative purposes, we are just embedding the script.\nlet webAppMain = System.IO.File.ReadAllText \u0026#34;keyvault-certs-app.fsx\u0026#34; Now we create the container group. It uses a .NET 5.0 SDK image to run the script and has two volume mounts. One is for the embedded script itself, and the other is for the volume mount from the Azure storage account file share where the certificate itself is stored.\nlet webApp = containerGroup { name \u0026#34;my-web-app\u0026#34; add_identity appIdentity add_instances [ containerInstance { name \u0026#34;fsi\u0026#34; image \u0026#34;mcr.microsoft.com/dotnet/sdk:5.0\u0026#34; command_line (\u0026#34;dotnet fsi /src/main.fsx\u0026#34;.Split null |\u0026gt; List.ofArray) add_volume_mount \u0026#34;script-source\u0026#34; \u0026#34;/src\u0026#34; add_volume_mount \u0026#34;cert-volume\u0026#34; \u0026#34;/certs\u0026#34; add_public_ports [ 443us ] cpu_cores 0.2 memory 0.5\u0026lt;Gb\u0026gt; } ] public_dns \u0026#34;my-web-app\u0026#34; [ TCP, 443us ] add_volumes [ volume_mount.secret_string \u0026#34;script-source\u0026#34; \u0026#34;main.fsx\u0026#34; webAppMain volume_mount.azureFile \u0026#34;cert-volume\u0026#34; \u0026#34;certs\u0026#34; certStorage.Name.ResourceName.Value ] } The ARM Template With all of these resources, we can create an ARM template. It contains four declarative resources: the user assigned identity, a key vault, a storage account, and a container group. It also contains a deployment script resource for the imperative logic.\narm { location Location.EastUS add_resources [ appIdentity kv certStorage createCertificate webApp ] } |\u0026gt; Writer.quickWrite \u0026#34;keyvault-certs\u0026#34; Deploying the resulting template through ARM will result in ARM attempting to reach the goal state with as much concurrency as dependencies allow. It will deploy the user assigned identity first, then both the key vault and the storage account at the same time, and then finally it will run the deployment script and deploy the container group.\nThe end result is a container group running an HTTPS service using a certificate that was created in the newly provisioned key vault.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/minecraft-server-aci/","title":"Create your own Minecraft Server","tags":[],"description":"","content":"Introduction In this tutorial, you\u0026rsquo;ll use dotnet framework features and F# language techniques when building a template to create a fully functional Minecraft Server running on an Azure Container Instance with its world data stored in an Azure Storage Account. Because Farmer is a domain specific language embedded within F#, you are able to utilize the rich dotnet ecosystem and a static type system to \u0026ldquo;craft\u0026rdquo; an advanced deployment.\n Programmatically build our Minecraft configuration files. Create a storage account for the world data. Define a deployment script that will download the Minecraft Server .jar file and upload it to the storage account, along with the configuration files. Create a container group for running the service;.  A few dependencies We will need a few dependencies here, so first let\u0026rsquo;s reference the packages and open the namespaces:\n Farmer - for building that Azure resources and deployment template. MinecraftConfig - for building the server configuration files. FSharp.Data - for scraping the server download page for the current version of the server .jar file.  #r \u0026#34;nuget: Farmer\u0026#34; #r \u0026#34;nuget: MinecraftConfig\u0026#34; #r \u0026#34;nuget: FSharp.Data\u0026#34; open System open Farmer open Farmer.Builders open FSharp.Data open MinecraftConfig Building the Minecraft server configuration files Deploying infrastructure often also means building configuration files, and Minecraft is no different. There are four critical files for a server:\n ops.json - this includes the list of operators that can manage the server. whitelist.json - this includes a list of gamers who are allowed to use the server. eula.txt - this indicates that you\u0026rsquo;ve accepted the End User License Agreement for running a Minecraft Server, and you should read this since downloading and using the game implies you agree with it. server.properties - the server is a Java application, and this is the configuration for the application itself.  First we build a list of users that we will allow on our server. We\u0026rsquo;ll use this list to build both the ops.json (operators) and whitelist.json (allowed gamers), so we will indicate which ones are operators.\nlet operator = true /// Our list of minecraft users - their username, uuid, and whether or not they are an operator. let minecrafters = [ \u0026#34;McUser1\u0026#34;, \u0026#34;a6a66bfb-6ff7-46e3-981e-518e6a3f0e71\u0026#34;, operator \u0026#34;McUser2\u0026#34;, \u0026#34;d3f2e456-d6a4-47ac-a7f0-41a4dc8ed156\u0026#34;, not operator \u0026#34;McUser3\u0026#34;, \u0026#34;ceb50330-681a-4d9d-8e84-f76133d0fd28\u0026#34;, not operator ] Now we build the whitelist.json and ops.json files - the MinecraftConfig application handles formatting the configuration file, we just need to map from our list of minecrafters to the lists of the records for the whitelist and the operator. whitelist holds the contents of our whitelist.json file, and ops hosts the contents of the ops.json file. We will write use those later.\n/// Let\u0026#39;s allow our list of minecrafters on the whitelist. let whitelist = minecrafters |\u0026gt; List.map (fun (name, uuid, _) -\u0026gt; { Name=name; Uuid=uuid }) |\u0026gt; Whitelist.format /// Filter the minecrafters that aren\u0026#39;t operators. let ops = minecrafters |\u0026gt; List.filter (fun (_, _, op) -\u0026gt; op) // Filter anyone that isn\u0026#39;t an operator  |\u0026gt; List.map (fun (name, uuid, _) -\u0026gt; { Name=name; Level=OperatorLevel.Level4; Uuid=uuid }) |\u0026gt; Ops.format And we can generate an accepted EULA, storing this content in eula.\n/// And accept the EULA. let eula = Eula.format true Now we need a few properties that are used both for the server.properties and for the resulting infrastructure. The worldName tells Minecraft where to store the world data. Since this will be mounted to an Azure Storage File share, we create a binding for it to make sure the name we use in the server.properties file matches what we use in the storage account.\nSame for the serverPort, which is both used in the server.properties file and must be exposed publicly on the Azure Container Group.\nThe name of the storage account is used in three places: the storage account itself, in the deployment script that will upload files to the storage account, and in the container group that will mount a volume from it. The storageAccountName can be referenced in all three uses.\n/// Add bindings for fields that are referenced in a few places /// Name of the share for the world. let worldName = \u0026#34;world1\u0026#34; /// Port for this world let serverPort = 25565 /// Storage account name let storageAccountName = \u0026#34;mcworlddata\u0026#34; And now we create the server.properties file, storing it in serverProperties. With that, we completed generating all of the configuration files for the server and can move on to defining and deploying the infrastructure.\n/// Write the customized server properties. let serverProperties = [ ServerPort serverPort RconPort (serverPort + 10) EnforceWhitelist true WhiteList true Motd \u0026#34;Azure Minecraft Server\u0026#34; LevelName worldName Gamemode \u0026#34;survival\u0026#34; ] |\u0026gt; ServerProperties.format Creating the Storage Account A Minecraft server stores some data for the world that is generated and people play in. That data, along with the configuration files, is stored in a directory that must be accessible to the server. Azure Container Groups are able to attach an Azure Storage Account File share as a volume, so we will create a storage account with a file share.\n/// A storage account, with a file share for the server config and world data. let serverStorage = storageAccount { name storageAccountName sku Storage.Sku.Standard_LRS add_file_share_with_quota worldName 5\u0026lt;Gb\u0026gt; } Defining the Deployment Script There are some deployment orchestration tasks that cannot be fully represented by Azure resources, but we need ARM to carry them out for us. We can use deploymentScripts as an Azure resource to represent script execution. This allows us to specify orchestration properties, such as that ARM should execute this deployment script after the storage account is deployed.\nThe script itself runs in a temporary container that has the Azure CLI ready and authenticated with a user that has the \u0026ldquo;Contributor\u0026rdquo; role over everything in this deployment. This is helpful because it means our script runs as a user that can access the storage account to upload content.\nWe need this deployment script to do three things:\n Copy the configuration files to the storage account. Download the current server.jar to the script container\u0026rsquo;s temporary storage. Upload the server.jar to the storage account.  Embedding Configuration Files First we will tackle the configuration files. We are going use F# to generate the CLI script, so we can actually embed these in the deployment script itself. To avoid any trouble with escaping characters for our script, we will encode all of the configuration files as base64 strings when we build the script and then the script will decode the base64 data and write files out to the container file system where the Azure CLI can upload them.\n Convert each configuration file to base64. Embed in shell script run by deployment. When the deployment script runs, it will decode and save as files. And then it will use az storage file upload to transfer them to the storage account.  /// A deployment script to create the config in the file share. let deployConfig = // Helper function to base64 encode the files for embedding them in the  // deployment script.  let b64 (s:string) = s |\u0026gt; System.Text.Encoding.UTF8.GetBytes |\u0026gt; Convert.ToBase64String // Build a script that embeds the content of these files, writes to the  // deploymentScript instance and then copies  // to the storageAccount file share. We will include the contents of these  // files as base64 encoded strings so there is no need to worry about  // special characters in the embedded script.  let uploadConfig = [ whitelist, Whitelist.Filename ops, Ops.Filename eula, Eula.Filename serverProperties, ServerProperties.Filename ] |\u0026gt; List.map (fun (content, filename) -\u0026gt; $\u0026#34;echo {b64 content} | base64 -d \u0026gt; {filename} \u0026amp;\u0026amp; az storage file upload --account-name {storageAccountName} --share-name {worldName} --source {filename}\u0026#34;) That seemed a bit complicated, but using the best of both F# and the Azure CLI, the actual code to do this is minimal. The b64 function converts any string you give it to bytes and then base64 encodes those bytes into a string we can embed in the script.\nNext we have a list that contains the contents of each configuration file paired with the filename we need to write. We map each of those items to an interpolated string, which is where F# can execute little bits of code when building the string. Within the interpolated string, we call the b64 function to encode the contents of each file, which is what $\u0026quot;echo {b64 content}\u0026quot; does. When the script executes, it will pass that string into base64 -d which decides the base64 back into bytes that are written to a file. After each file is written, it\u0026rsquo;s uploaded with az storage file upload which again uses interpolated string values to get the storageAccountName, worldName, and filename values.\nDeploying the Server Software Having embedded the configuration files, now we need to add a line to the script to download the Minecraft server.jar and upload it as well. Whenever a new Minecraft Server is released, they update this page with a link that is named for the server version.\nWithout F#, we would probably stop here and just use the link for whatever version is out today. But F# has nice toys for reading and exploring data, like FSharp.Data which can parse HTML files, so we\u0026rsquo;re only a few lines away from scraping the download page for the link to the current version.\nWhen this F# code is executed to build the ARM template, it will load the Download page, find the link starting with minecraft_server, and copy the URL from the href on that link. We will embed that URL into our deployment script as a parameter to a curl call which will download the file before calling az storage file upload to copy the file to the storage account.\n/// The script will also need to download the server.jar and upload it.  let uploadServerJar = let results = HtmlDocument.Load \u0026#34;https://www.minecraft.net/en-us/download/server\u0026#34; // Scrape for anchor tags from this download page.  results.Descendants [\u0026#34;a\u0026#34;] // where the inner text contains \u0026#34;minecraft_server\u0026#34; since that\u0026#39;s what is  // displayed on that link  |\u0026gt; Seq.filter (fun (x:HtmlNode) -\u0026gt; x.InnerText().StartsWith \u0026#34;minecraft_server\u0026#34;) // And choose the \u0026#34;href\u0026#34; attribute if present  |\u0026gt; Seq.choose(fun (x:HtmlNode) -\u0026gt; x.TryGetAttribute(\u0026#34;href\u0026#34;) |\u0026gt; Option.map(fun (a:HtmlAttribute) -\u0026gt; a.Value())) |\u0026gt; Seq.head // If it wasn\u0026#39;t found, we\u0026#39;ll get an error here.  |\u0026gt; (fun url -\u0026gt; $\u0026#34;curl -O {url} \u0026amp;\u0026amp; az storage file upload --account-name {storageAccountName} --share-name {worldName} --source server.jar\u0026#34;) Now we have two lists:\n uploadConfig is a list of the four lines of bash that will decode and then upload the configuration files to the storage account. uploadServerJar is a line of bash to download the server software and upload it to the storage account.  We concat those lines together with a semicolon ;  to break up our commands, and we have a full script we can run. The deploymentScript resource itself is fairly simple, and we use depends_on serverStorage to make sure this only runs after our storage account is deployed.\nlet scriptSource = uploadServerJar :: uploadConfig |\u0026gt; List.rev // do the server upload last so it won\u0026#39;t start until the configs are in place.  |\u0026gt; String.concat \u0026#34;; \u0026#34; deploymentScript { name \u0026#34;deployMinecraftConfig\u0026#34; // Depend on the storage account so this won\u0026#39;t run until it\u0026#39;s there.  depends_on serverStorage script_content scriptSource force_update } Creating the Container Instance The container instance runs a Java Runtime Environmennt, giving it enough CPU and memory for a small server with a few players. It has a volume mounted to the Azure Storage Account File share where the configuration files and server.jar are uploaded.\nThe containerGroup has a dependency on the storageAccount so it won\u0026rsquo;t be deployed until the storageAccount is deployed. There is a bit of a race condition since the container group could be deployed and start before the deploymentScript uploads the server.jar and configuration files. To prevent this issue the container runs a while loop in bash until the server starts successfully.\nlet serverContainer = containerGroup { name \u0026#34;minecraft-server\u0026#34; public_dns \u0026#34;azmcworld1\u0026#34; [ TCP, uint16 serverPort ] add_instances [ containerInstance { name \u0026#34;minecraftserver\u0026#34; image \u0026#34;mcr.microsoft.com/java/jre-headless:8-zulu-alpine\u0026#34; // The command line needs to change to the directory for the file share  // and then start the server.  // It needs a little more memory than the defaults, -Xmx3G gives it 3 GiB  // of memory.  command_line [ \u0026#34;/bin/sh\u0026#34; \u0026#34;-c\u0026#34; // We will need to do a retry loop since we can\u0026#39;t have a depends_on  // for the deploymentScript to finish.  $\u0026#34;cd /data/{worldName}; while true; do java -Djava.net.preferIPv4Stack=true -Xms1G -Xmx3G -jar server.jar nogui \u0026amp;\u0026amp; break; sleep 30; done\u0026#34; ] // If we chose a custom port in the settings, it should go here.  add_public_ports [ uint16 serverPort ] // It needs a couple cores or the world may lag with a few players  cpu_cores 2 // Give it enough memory for the JVM  memory 3.5\u0026lt;Gb\u0026gt; // Mount the path to the Azure Storage File share in the container  add_volume_mount worldName $\u0026#34;/data/{worldName}\u0026#34; } ] // Add the file share for the world data and server configuration.  add_volumes [ volume_mount.azureFile worldName worldName serverStorage.Name.ResourceName.Value ] } Here we will build the template. The deployConfig deployment script is especially interesting as it contains the embedded configuration files and the curl command with the link to the current server.jar from scraping the download page.\n/// Build the deployment with storage, deployment script, and container group. let deployment = arm { location Location.EastUS add_resources [ serverStorage deployConfig serverContainer ] } deployment |\u0026gt; Writer.quickWrite \u0026#34;minecraft-server\u0026#34; After running this deployment, view the container group in the Azure Portal or with az container logs to watch the server start up and generate a world. Once the world is generated, it\u0026rsquo;s ready to connect from your Minecraft Java Edition client by entering the DNS name for the container group!\nIf you need to change the configuration you could connect to the terminal of the container instance. But in the spirit of mature configuration management and immutable infrastructure, you should rebuild the config, stop the container group, and redeploy. The existing state - the minecraft world data - is left intact in the storage account and the configuration is replaced with your updates. Once the update is deployed, you can restart the container group.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/aci-fsx/","title":"F# Script in a Container Group","tags":[],"description":"","content":"Introduction In this tutorial, you will deploy an F# script directly to an Azure Container Group. This is useful when you need to fill a gap in your solution with some quick application logic or to test scenarios on Azure before building a more complex application. We\u0026rsquo;ll cover the following steps:\n Create a brief F# script. Create a container instance. Include the script on a volume that will be attached to the container when started.  Create the F# Script Scripts are often useful for quick automation or very simple application logic. Our goal here is to create a small HTTP service - this could be used for a health check service or to bootstrap a larger application, but we\u0026rsquo;ll keep it very simple for illustrative purposes. Let\u0026rsquo;s name it main.fsx.\n#r \u0026#34;nuget: Suave, Version=2.6.0\u0026#34; open Suave let config = { defaultConfig with bindings = [ HttpBinding.createSimple HTTP \u0026#34;0.0.0.0\u0026#34; 8080 ] } startWebServer config (Successful.OK \u0026#34;Hello Farmers!\u0026#34;) Create the Container Group A container group consists of one or more containers that will run together. The container instances in the group can communicate with each other and share files over volume mounts.\nOur script relies on the dotnet 5 SDK to run the script with the dotnet fsi command, so we will run it on the dotnet/sdk:5.0 docker image which includes this SDK. Since our script creates a web listener on port 8080, we will add that as a public port and give it a DNS name so we can reach it.\nopen Farmer open Farmer.Builders let containers = containerGroup { name \u0026#34;my-app\u0026#34; add_instances [ containerInstance { name \u0026#34;fsi\u0026#34; image \u0026#34;mcr.microsoft.com/dotnet/sdk:5.0\u0026#34; add_public_ports [ 8080us ] } ] public_dns \u0026#34;my-fsi-app\u0026#34; [ TCP, 8080us ] } Include the script in the deployment The F# script will be embedded in the template as a secret_string. This creates a file in the container group that can be mounted into the file system on any of the container instances in the group. In our case, we will mount the F# script as a file named main.fsx in the container group and mount the directory containing that file as /src. With this in place we can also set the dotnet fsi command to run on container start, executing the script.\nlet containers = containerGroup { name \u0026#34;my-app\u0026#34; add_instances [ containerInstance { name \u0026#34;fsi\u0026#34; image \u0026#34;mcr.microsoft.com/dotnet/sdk:5.0\u0026#34; add_public_ports [ 8080us ] // Add a volume mount with the script source.  add_volume_mount \u0026#34;script-source\u0026#34; \u0026#34;/src\u0026#34; // Set the command line to run \u0026#39;dotnet fsi /src/main.fsx\u0026#39; on startup  command_line (\u0026#34;dotnet fsi /src/main.fsx\u0026#34;.Split null |\u0026gt; List.ofArray) } ] public_dns \u0026#34;my-fsi-app\u0026#34; [ TCP, 8080us ] // Read our script source when building the ARM template and embed it into the template as a secret string volume mount to attach to the container group.  add_volumes [ volume_mount.secret_string \u0026#34;script-source\u0026#34; \u0026#34;main.fsx\u0026#34; (System.IO.File.ReadAllText \u0026#34;main.fsx\u0026#34;) ] } The resulting template contains the contents of the F# script embedded as base64 so we have a standalone template that can be deployed to ARM.\narm { location Location.EastUS add_resources [ containers ] } When the container group starts, it will execute the F# script, starting the service. This is very useful for gathering source and configuration from your local or internal environment and including it in a deployment. We are able to use this technique due to two unique features:\n Farmer is an \u0026ldquo;embedded\u0026rdquo; DSL - rather than simply a friendly version of the ARM template language, it brings the full feature set of .NET when building a template. This makes reading a script from the file system, converting to base64, and embedding in the template a simple process. ARM templates are not executed locally like Azure CLI scripts - they are a specification for ARM to deploy the infrastructure on your behalf. Once the F# script on your local machine is embedded into the template, ARM is able to pass it to your infrastructure securely over Azure\u0026rsquo;s control plane.  "},{"uri":"https://compositionalit.github.io/farmer/tutorials/cosmos-backed-webapp/","title":"Cosmos-backed Web App","tags":[],"description":"","content":"Introduction This tutorial walks you through creating a web application which is backed by a Cosmos DB database, and is fully configured with connection string settings for you to start developing against. We\u0026rsquo;ll cover the following steps:\n Creating a Cosmos DB account with a single database. Creating a web application with an automatically configured app insights instance. Configuring the web application to have the connection settings required to connect to the Cosmos DB instance.    Full code available here\n  Create the CosmosDB instance Create a CosmosDB instance using the cosmosDb builder:\nopen Farmer open Farmer.Builders open Farmer.CosmosDb let theDatabase = cosmosDb { name \u0026#34;Tasks\u0026#34; account_name \u0026#34;isaac-to-do-app-cosmos\u0026#34; consistency_policy Session } Create and configure a web app Create a web application, and provide settings that are derived from the Cosmos DB instance that you just created.\n The API of the functions builder is virtually identical to that of the Web App builder. You can replace webApp with functions below, removing the sku keyword, and you will get a working Azure Functions instance instead.\n let theApp = webApp { name \u0026#34;isaac-to-do-app\u0026#34; sku WebApp.Sku.B1 setting \u0026#34;CosmosDb:Account\u0026#34; theDatabase.Endpoint setting \u0026#34;CosmosDb:Key\u0026#34; theDatabase.PrimaryKey setting \u0026#34;CosmosDb:DatabaseName\u0026#34; theDatabase.DbName setting \u0026#34;CosmosDb:ContainerName\u0026#34; \u0026#34;Items\u0026#34; }  You don\u0026rsquo;t have to explicitly set a dependency between the two. Farmer will \u0026ldquo;pull out\u0026rdquo; the Cosmos DB details itself.\n You don\u0026rsquo;t have to be concerned about secrets of the CosmosDB instance leaking in your ARM template, because no secrets are supplied. Instead, your template will be populated with ARM expressions which will only be evaluated at runtime:\n{ \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:Account\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[reference(resourceId(\u0026#39;Microsoft.DocumentDb/databaseAccounts\u0026#39;, \u0026#39;isaac-to-do-app-cosmos\u0026#39;), \u0026#39;2020-03-01\u0026#39;).documentEndpoint]\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:ContainerName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Items\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:DatabaseName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Tasks\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:Key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[listKeys(resourceId(\u0026#39;Microsoft.DocumentDb/databaseAccounts\u0026#39;, \u0026#39;isaac-to-do-app-cosmos\u0026#39;), providers(\u0026#39;Microsoft.DocumentDb\u0026#39;,\u0026#39;databaseAccounts\u0026#39;).apiVersions[0]).primaryMasterKey]\u0026#34; } Add both resources to your ARM template let template = arm { location Location.WestEurope add_resources [ theDatabase theApp ] } You can now deploy the template and you\u0026rsquo;ll have a web application which has all required secrets to communicate with the Cosmos DB instance.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/multiple-web-apps/","title":"Multiple web apps","tags":[],"description":"","content":"Introduction This tutorial walks you through creating multiple web applications that will share a common web server. We\u0026rsquo;ll cover the following steps:\n Creating a web app. Creating multiple web apps and \u0026ldquo;sharing\u0026rdquo; the first web app\u0026rsquo;s service plan and Application Insights instances. How to use F#\u0026lsquo;s list comprehensions to rapidly creating multiple websites.    Full code available here\n  Creating a single web app Create a standard web app as normal:\nlet primaryWebApp = webApp { name \u0026#34;primarywebapp\u0026#34; sku WebApp.Sku.F1 } Creating secondary web apps Create a second web app, but this time link to the service plan that is part of the first web app:\nlet secondaryWebApp = webApp { name \u0026#34;secondarywebapp\u0026#34; link_to_service_plan primaryWebApp.ServicePlanName link_to_app_insights primaryWebApp.AppInsightsName } You can now add both web apps to the arm { } block for deployment:\nlet template = arm { location Location.NorthEurope add_resource primaryWebApp add_resource secondaryWebApp } Creating dedicated Service Plan and App Insights instances Rather than \u0026ldquo;piggy back\u0026rdquo; on a \u0026ldquo;primary\u0026rdquo; web app, you can also opt to create dedicated service plan and app insights instances and configure all web apps to use them. This is a slightly more verbose option, but you may find it clearer, and as we\u0026rsquo;ll see shortly, it can sometimes be useful to declare these instances outside of the web app:\nlet plan = servicePlan { name \u0026#34;theFarm\u0026#34; sku WebApp.Sku.F1 } let ai = appInsights { name \u0026#34;insights\u0026#34; } let aWebApp = webApp { name \u0026#34;primarywebapp\u0026#34; link_to_service_plan plan link_to_app_insights ai } let anotherWebApp = webApp { name \u0026#34;secondarywebapp\u0026#34; link_to_service_plan plan link_to_app_insights ai }  As you are creating the plan and AI instances yourself, you also need to remember to add them to the arm { } block!\n Rapidly creating multiple web apps F# has excellent support for working with collections of data, including creating data. Let\u0026rsquo;s assume we wanted to create four web apps, each with a name \u0026ldquo;mywebapp-{index}\u0026rdquo; e.g. \u0026ldquo;mywebapp-1\u0026rdquo; etc. We can use F#\u0026lsquo;s list comprehensions to create four web apps quickly and easily.\nlet webApps : IBuilder list = [ for i in 1 .. 4 do webApp { name (\u0026#34;mywebapp-\u0026#34; + string i) link_to_service_plan plan link_to_app_insights ai } ] The key parts to note are:\n Use of [ ], which in F# signify a list of some data. Use of for .. in .. do syntax to iterate over numbers 1 to 4, assigning each value to i. Creating unique names for each web app using simple string concatentation. An explicit type annotation (: IBuilder list). Without getting into too much detail, this is needed because F# is somewhat stricter about implicit type conversions than other languages, particularly around list contra/covariance.  List comprehensions in F# are very powerful. You can use this approach with a specific set of names that are themselves a list as well e.g.\nlet planets = [ \u0026#34;jupiter\u0026#34;; \u0026#34;mars\u0026#34;; \u0026#34;pluto\u0026#34;; \u0026#34;venus\u0026#34; ] let webApps = [ for planet in planets do ... ] Adding multiple resources to the template Once you have created a list of web apps, you can add them all at once to the ARM builder using the add_resources keyword:\nlet template = arm { ... add_resources webApps } "},{"uri":"https://compositionalit.github.io/farmer/tutorials/serverless-etl/","title":"Serverless ETL","tags":[],"description":"","content":"Introduction This tutorial shows how to create the infrastructure required to implement a common pattern for code-first \u0026ldquo;extract-transform-load\u0026rdquo; (ETL) processes. In this tutorial, imagine you wish to react to data being created in a blob in Storage, then parse it, and finally insert the \u0026ldquo;parsed\u0026rdquo; data into SQL in a relational database for use by e.g. a web application. We\u0026rsquo;ll cover the following steps:\n Creating an Azure Functions instance, with automatically configured storage and app insights instances. Creating a SQL Azure database and server. Configuring the Functions instance to have connection settings required to connect to both Storage and SQL instances. Safely providing a SQL Server password to Farmer at deployment time.    Full code available here\n  Create the SQL instance Create a SQL Server and database using the sqlServer builder. This server would be used for processed data at the end of the ETL pipeline.\nopen Farmer open Farmer.Builders let transactionalDb = sqlServer { name \u0026#34;etlserver\u0026#34; admin_username \u0026#34;theadministrator\u0026#34; add_databases [ sqlDb { name \u0026#34;parseddata\u0026#34;; sku Sql.DtuSku.S1 } ] }  We explicitly set the SKU of the database. You don\u0026rsquo;t have to do this; if you elect not to, Farmer will create an elastic pool and assign the database into that.\n Create and configure a Functions instance Create a functions instance which would contain the application that monitors the storage account for blobs, process each blob and then insert data into SQL. Also, provide the connection string that is derived from the SQL instance that you just created.\nlet etlProcessor = functions { name \u0026#34;etlprocessor\u0026#34; storage_account_name \u0026#34;mydata\u0026#34; setting \u0026#34;sql-conn\u0026#34; (transactionalDb.ConnectionString \u0026#34;parseddata\u0026#34;) }  Functions instances require a storage account to operate, and will automatically create one for you. In this sample, we have explicitly provided the storage account name; you don\u0026rsquo;t have to do this - Farmer will derive one based on the function instance name. If you prefer to manage the storage account yourself, you can create a storage account and use the link_to_storage_account keyword instead.\nFarmer will also automatically configure the functions instance with connection string settings for both the AzureWebJobsStorage and AzureWebJobsDashboard settings. You can use these to also configure your functions app to read from.\n Adding extra type safety for sharing resources If the mistype the database name for the connection string, Farmer will automatically fail and let you know at runtime. However, a better approach is to use F# to enforce sharing the same database name across the Function instance and SQL server by referencing the database instance directly, instead of a raw string:\nlet database = sqlDb { name \u0026#34;isaacparseddata\u0026#34; sku Sql.DtuSku.S1 } let transactionalDb = sqlServer { ... add_databases [ database ] } let etlProcessor = functions { ... setting \u0026#34;sql-conn\u0026#34; (transactionalDb.ConnectionString database) }  In this case, you don\u0026rsquo;t need to add the database as a resource to the arm { } block; Farmer will do it automatically as part of the sqlServer builder.\n Add both resources to your ARM template let template = arm { location Location.WestEurope add_resource transactionalDb add_resource etlProcessor } Deploy the template When deploying the template, you\u0026rsquo;ll need to provide the password for the SQL Server instance. This is captured as a secure parameter to the template; this guarantees that the password will not be stored in the ARM template as plain text.\n{ \u0026#34;parameters\u0026#34;: { \u0026#34;password-for-isaacetlserver\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;securestring\u0026#34; } } } The parameter name is automatically generated based on the server name. A member on the sql configuration value can be used to quickly get to this and to set the password at deployment time:\ntemplate |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ transactionalDb.PasswordParameter, \u0026#34;SQL PASSWORD GOES HERE\u0026#34; ] |\u0026gt; printfn \u0026#34;%A\u0026#34;  You should never commit secrets into source control. Instead, set environment variables or command line parameters to your Farmer program to read in the password and pass it into the execute function. For CI/CD tools such as Octopus or Azure DevOps, you can set secrets that appear as environment variables.\n "},{"uri":"https://compositionalit.github.io/farmer/tutorials/web-storage-keyvault/","title":"Web App Secrets with KeyVault","tags":[],"description":"","content":"Introduction This tutorial shows how to create the infrastructure required to host a web app which can retrieve secrets from a secure store (Keyvault) using Azure identity. In this tutorial, we\u0026rsquo;ll store the key for a storage account in Keyvault, but it could be anything. We\u0026rsquo;ll cover the following steps:\n Creating a Web App, Storage Account and a KeyVault instance. Safely adding the Storage Account key into KeyVault. Granting a read-only trust between KeyVault and the Web App. Referencing the KeyVault setting from the Web App.    Full code available here\n  Create basic resources Start by creating the three main resources we need: a web app, storage account and key vault in the following ordwer:\nopen Farmer open Farmer.Builders let datastore = storageAccount { name \u0026#34;\u0026lt;storage name goes here\u0026gt;\u0026#34; } let webapplication = webApp { name \u0026#34;\u0026lt;web app name goes here\u0026gt;\u0026#34; } let secretsvault = keyVault { name \u0026#34;\u0026lt;key vault name goes here\u0026gt;\u0026#34; } Configure KeyVault with the Storage Key Let\u0026rsquo;s now add the storage account key to the key vault:\nlet secretsvault = keyVault { name \u0026#34;isaacsupersecret\u0026#34; add_secret (\u0026#34;storagekey\u0026#34;, datastore.Key) } Grant secret access to the web app Now we have KeyVault grant permission to the web app:\nlet webapplication = webApp { ... system_identity } let secretsvault = keyVault { ... add_access_policy (AccessPolicy.create webapplication.SystemIdentity) } The AccessPolicy.create builder method has several overloads; this one grants basic GET and LIST permissions to the web application\u0026rsquo;s built-in system identity, which we have just activated above. You can also supply other permissions as a secondary argument to the create method.\nConnect secret to the web app Now, we use Farmer\u0026rsquo;s Web App / Keyvault integration to seamlessly provide access to key vault secrets:\nlet webapplication = webApp { ... link_to_keyvault (ResourceName \u0026#34;\u0026lt;key vault name goes here\u0026gt;\u0026#34;) secret_setting \u0026#34;storagekey\u0026#34; } or\nlet kv = keyVault { name \u0026#34;keyvault\u0026#34; } let webapplication = webApp { ... link_to_keyvault kv secret_setting \u0026#34;storagekey\u0026#34; } The first keyword \u0026ldquo;links\u0026rdquo; the vault with the web app, and tells Farmer that all \u0026ldquo;secret\u0026rdquo; settings should now be read from this vault. We cannot reference the keyvault directly in this case because it\u0026rsquo;s declared after the web application, so we construct a ResourceId reference ourselves.\nThe second keyword actually adds the secret to the web app. If you hadn\u0026rsquo;t added the link_to_keyvault keyword, this would be rendered into ARM as a secret parameter, but in this case because we\u0026rsquo;ve linked the vault in, it gets redirected to point there instead.\nAdding extra type safety for sharing resources To prevent accidentally mistyping the secret or vault names, you should bind the magic strings into symbols at the top of the template and replace usages in the template.\nlet secretName = \u0026#34;storagekey\u0026#34; let vaultName = \u0026#34;\u0026lt;key vault name goes here\u0026gt;\u0026#34; Add all resources to your ARM template Add all the resources into an arm builder and then deploy the template as normal.\nlet template = arm { location Location.WestEurope add_resources [ secretsvault datastore webapplication ] } That\u0026rsquo;s it! You now have a web application that can read the secret from the vault without using any keyvault connection string. If you log into the portal, you\u0026rsquo;ll see that the secret setting is indeed in the Configuration section, but will have a green tick and a \u0026ldquo;Key vault reference\u0026rdquo; message next to it:\n  The value of the secret will look something like this:\n@Microsoft.KeyVault(SecretUri=https://\u0026lt;key vault name goes here\u0026gt;.vault.azure.net/secrets/storagekey) The App Service will transparently retrieve the secret from the vault for you when you try to access the setting.\n By default, even you will not be able to access the secret from key vault! If you want to grant yourself access to the secret in the vault, you can use the AccessPolicy.findUsers method in code to retrieve your principal and grant access to the secret through Farmer. Alternatively, you can manually grant yourself access through the Portal etc.\n "},{"uri":"https://compositionalit.github.io/farmer/","title":"Farmer","tags":[],"description":"","content":"  Making repeatable Azure deployments easy! Farmer is an easy-to-learn library for rapidly authoring and deploying entire Azure architectures.\n Infrastructure-as-code, done right. Simple code snippets allow you to rapidly construct complex topologies. Idempotent deployments. Safely provision a template repeatedly and know that only changes will be applied. Cross-platform. Runs on .NET Core on Windows, Mac or Linux. Built on trusted technologies. Farmer uses Microsoft\u0026rsquo;s Azure Resource Manager (ARM) technology for deployments to Azure. Commercial supported. Professional support plans for teams that wish to benefit from peace of mind and further improve the product. Easy to learn, easy to understand code through a simple, strongly-typed and pragmatic DSL.  Already using ARM templates? Farmer has you covered.\n Farmer is completely backwards compatible with ARM templates. Farmer generates standard ARM templates so you can continue to use existing deployment processes. Safely create dependencies between resources. Uses static typing to give confidence that your templates will work first time. Easily access common properties of resources. No more fighting to concatenate cryptic strings! Extensible API. Add new helpers and members as needed. Open source and free. Farmer is free to use and modify. We welcome contributions to the project!  Why not Azure Resource Manager? Farmer uses a simple DSL to declare resources and comes with helper functions to perform common tasks. Farmer templates are around 5-8 times smaller than ARM templates, meaning they are quicker and easier to author, understand and maintain. Read more on the comparison page.\nCreating a web application with a configured application insights and a linked storage account Farmer Templates These 20 lines of simple, readable and type-safe code are translated into 141 lines of JSON ARM template!\n// Create a storage account with a container let myStorageAccount = storageAccount { name \u0026#34;myTestStorage\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } // Create a web app with application insights that\u0026#39;s connected to the storage account. let myWebApp = webApp { name \u0026#34;myTestWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key } // Create an ARM template let deployment = arm { location Location.NorthEurope add_resources [ myStorageAccount myWebApp ] } // Deploy it to Azure! deployment |\u0026gt; Writer.quickDeploy \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters Want to try it out? Follow our quickstart guide now! "},{"uri":"https://compositionalit.github.io/farmer/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://compositionalit.github.io/farmer/tags/","title":"Tags","tags":[],"description":"","content":""}]