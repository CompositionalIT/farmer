[{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/aks-cluster/","title":"AKS Cluster","tags":[],"description":"","content":"Overview The AKS Cluster builder is used to create AKS clusters.\n Container Group (Microsoft.ContainerService/managedClusters)  AKS Builder Keywords The AKS Builder constructs AKS clusters.\n   Keyword Purpose     name Sets the name of the AKS cluster.   dns_prefix Sets the DNS prefix of the AKS cluster.   enable_rbac Enable Kubernetes Role-Based Access Control.   add_agent_pools Adds agent pools to the AKS cluster.   add_agent_pool Adds an agent pool to the AKS cluster.   add_identity Adds a managed identity to the the AKS cluster.   system_identity Activates the system identity of the AKS cluster.   network_profile Sets the network profile for the AKS cluster.   linux_profile Sets the linux profile for the AKS cluster.   service_principal_client_id Sets the client id of the service principal for the AKS cluster.   windows_username Sets the windows admin username for the AKS cluster.    Agent Pool Builder keywords The Agent Pool Builder constructs agent pools which are inserted into the AKS cluster.\n   Keyword Purpose     name Sets the name of the agent pool.   count Sets the count of VM\u0026rsquo;s in the agent pool.   user_mode Sets the agent pool to user mode.   disk_size Sets the disk size for the VM\u0026rsquo;s in the agent pool.   max_pods Sets the maximum number of pods in the agent pool.   os_type Sets the OS type of the VM\u0026rsquo;s in the agent pool.   subnet Sets the name of a virtual network subnet where this AKS cluster should be attached.   vm_size Sets the size of the VM\u0026rsquo;s in the agent pool.   vnet Sets the name of a virtual network in the same region where this AKS cluster should be attached.    CNI Builder The CNI builder helps create network profiles on the AKS cluster.\n   Keyword Purpose     docker_bridge Sets the docker bridge CIDR to a network other than the default 17.17.0.1/16.   dns_service Sets the DNS service IP - must be within the service CIDR, default is the second address in the service CIDR.   service_cidr Sets the service cidr to a network other than the default 10.224.0.0/16.    Example open Farmer open Farmer.Builders open Farmer.ContainerService let myAks = aks { name \u0026#34;k8s-cluster\u0026#34; dns_prefix \u0026#34;testaks\u0026#34; add_agent_pools [ agentPool { name \u0026#34;linuxPool\u0026#34; count 3 } ] linux_profile \u0026#34;aksuser\u0026#34; \u0026#34;public-key-here\u0026#34; service_principal_client_id \u0026#34;some-spn-client-id\u0026#34; network_profile ( azureCniNetworkProfile { service_cidr \u0026#34;10.250.0.0/16\u0026#34; } ) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/template-generation/","title":"Generating templates","tags":[],"description":"","content":"Farmer supports several ways to \u0026ldquo;output\u0026rdquo; ARM templates.\nGenerating JSON as a string You can generate an ARM template as a plain string:\nlet json = deployment.Template |\u0026gt; Writer.toJson // prints out the JSON  printfn \u0026#34;%s\u0026#34; json Writing to a file You can write out the ARM template directly to a file, from which you can then deploy to Azure using whichever mechanism you already use e.g. Azure CLI, Powershell, REST API etc.\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myTemplate\u0026#34; Notice how we use F#\u0026lsquo;s pipe operator to \u0026ldquo;pipe\u0026rdquo; data from the template configuration into json before writing to a file.\nIntegrated deployment to Azure You can also turn over deployment of the template directly to Farmer. In this case, it orchestrates commands to the Azure CLI as required.\nlet response = deployment |\u0026gt; Deploy.tryExecute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters match response with | Ok outputs -\u0026gt; printfn \u0026#34;Success! Outputs: %A\u0026#34; outputs | Error error -\u0026gt; printfn \u0026#34;Failed! %s\u0026#34; error As you can see, the response of calling tryExecute is a Result object which is either Ok, in which case any outputs returned from the template are made available as a Map\u0026lt;string, string\u0026gt;, or an Error, which is the error returned by the Azure CLI. Alternatively, you can call execute which will throw an exception rather than return a Result.\n You must have the Azure CLI installed on your machine in order for Farmer to perform deployments for you.\n Authenticating to Azure Azure CLI stores a login token on your machine, and Farmer will check for this. If you aren\u0026rsquo;t logged in, Farmer will automatically start the interactive Azure CLI login process for you.\nFor automated deployments e.g. continuous deployment or through scripts etc., you\u0026rsquo;ll want to use an unattended deployment mode. Some CI systems such as Azure Devops come with an pre-authenticated Azure CLI terminal from which you can run an application that uses Farmer. Alternatively, you can create a service principal, and supply them to the Deploy.authenticate function before calling Deploy.execute.\nYou should use a secure mechanism for storing and supplying the credentials to Farmer. Do not commit them into source control!\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/app-insights/","title":"App Insights","tags":[],"description":"","content":"Overview The App Insights builder is used to create Application Insights accounts. Use this if you need a standalone AI instance; if you need one for a web app, the web app will create one by default and configure the application settings automatically.\n Application Insights (Microsoft.Insights/components)  Builder Keywords    Keyword Purpose     name Sets the name of the App Insights instance.   disable_ip_masking Disable IP masking.   sampling_percentage Define sampling percentage (0-100)    Configuration Members    Member Purpose     InstrumentationKey Gets the ARM expression path to the instrumentation key of this App Insights instance.    Example open Farmer open Farmer.Builders let ai = appInsights { name \u0026#34;myAI\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/about/","title":"About","tags":[],"description":"","content":"About Farmer Farmer is a .NET domain-specific-language (DSL) for rapidly generating Azure Resource Manager (ARM) templates. Farmer is commercially supported, open source and free-to-use.\nFor those of you working with Azure today, you may already be aware that one of the most useful features is the ability to generate entire infrastructure architectures as code via ARM Template files. These templates contain a declarative model that allows repeatable deployments and idempotent releases (among other things).\nWhat\u0026rsquo;s wrong with ARM? Unfortunately, ARM templates have some limitations caused by the fact that they must be authored in a verbose JSON dialect:\n They provide very limited type checking and support, which makes creating discovery and creation of template features difficult. Templates need a lot of boilerplate to be created for even relatively simple and common resources. It requires \u0026ldquo;embedded\u0026rdquo;, difficult-to-maintain stringly-typed code in order to achieve what might be trivial in a \u0026ldquo;proper\u0026rdquo; programming language, such as references, variables and parameters - or writing elements such as loops. The documentation for ARM templates is not always kept up-to-date, so understanding and learning how to properly use them can involve a lot of searching and trial-and-error.  In other words, whilst working with ARM templates that have already been created is relatively straightforward, the authoring of the templates themselves is time-consuming and error-prone.\nWhilst there have been some recent improvements to ARM - including tooling improvements in VS Code through an extension - we think that we can do much better than relying on tooling for a specific IDE, which means using something different than JSON when directly authoring ARM templates.\nWhat does Farmer do to fix this? Farmer templates are simple .NET Core applications which reference the Farmer NuGet package. This package contains a set of types that model Azure resources in a strongly-typed and succinct fashion, as well as functionality to create ARM templates from this model - and even deploy directly to Azure.\nWhat can I use Farmer for? Farmer currently has support for a large number of common resources including web apps, sql and storage, with more being added over time.\n"},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-1/","title":"Your first Farmer template","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll:\n create a web application with a fully-configured Application Insights instance create an ARM deployment object and assign the web app to it generate an ARM template  Creating a Farmer app Create an F# console application using the .NET SDK and add the Farmer package in an empty directory:\ndotnet new console -lang F# dotnet add package Farmer  Farmer also has a .NET template to get started even more quickly!\n Defining a Farmer web application Open Program.fs and delete all the contents.\n In Farmer, resources are defined using special code blocks that look somewhat json-esque, known as a \u0026ldquo;builder\u0026rdquo;. In these builders you can quickly and easily configure a resource using special keywords, but unlike json you also have edit-time safety.\n Create a Farmer web application using the webApp { } builder:\nopen Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } Create an ARM template deployment object, before setting the location for the overall resource group and adding the web app into it.\nlet deployment = arm { location Location.NorthEurope add_resource myWebApp } Generating the ARM template Now you need to generate the ARM template from the deployment object to an ARM json file.\nAdd the following code:\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; Run the application:\ndotnet run You should notice that the file myFirstTemplate.json has been created.\nThe generated ARM template contains the following resources:\n A web application A server farm An application insights instance  The resources will be correctly configured with the appropriate dependencies set.\nThe full application open Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } let deployment = arm { location Location.NorthEurope add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/1-the-farmer-pipline/","title":"1. The Farmer Pipeline","tags":[],"description":"","content":"This step will get you up and running by incorporate something quickly and easily into the Farmer pipeline that emits a valid Azure Container Registry.\nStep 1.1: Prototype and test using an fsx file Technically this step is not necessary but it is the quickest way to get a working deployment from which you can iterate upon.\nStart by looking at this sample and identifying the section of JSON that relates to the resource we want - in our case, the Microsoft.ContainerRegistry/registries resource.\n The use of #r \u0026quot;nuget:...\u0026quot; syntax can be enabled by going to Settings \u0026gt; F# \u0026gt; Fsi Extra Parameters and adding --langversion:preview to the FSharp.fsiExtraParameters list (.NET 5 only)\nIf you are not using .NET 5, manually build Farmer and reference the dll manually - see the samples folder for examples.\n // container-registry-prototype.fsx #r \u0026#34;nuget: farmer\u0026#34; #r \u0026#34;nuget: Newtonsoft.Json\u0026#34; open Farmer open Farmer.CoreTypes // A function called \u0026#34;registries\u0026#34; that takes in a name, sku and boolean flag for whether to enable the admin user. let registries name sku adminUserEnabled = sprintf \u0026#34;\u0026#34;\u0026#34;{ \u0026#34;name\u0026#34;: \u0026#34;%s\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westeurope\u0026#34;, \u0026#34;tags\u0026#34;: { }, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;%s\u0026#34; }, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: %b } }\u0026#34;\u0026#34;\u0026#34; name sku adminUserEnabled |\u0026gt; Resource.ofJson let deployment = arm { location Location.NorthEurope add_resource (registries \u0026#34;my-registry\u0026#34; \u0026#34;Basic\u0026#34; true) } deployment |\u0026gt; Writer.quickWrite \u0026#34;test-output\u0026#34; // or push out for real to Azure!  // deployment // |\u0026gt; Deploy.execute \u0026#34;FarmerTest\u0026#34; Deploy.NoParameters // |\u0026gt; printfn \u0026#34;%A\u0026#34; Observe how we\u0026rsquo;ve pasted a minimal section of JSON and then tried to extract some of the candidates for parameterisation - in our case name, sku and adminUserEnabled, and how we\u0026rsquo;ve used the Resource.ofJson function to create an IArmResource for us to quickly allow us \u0026ldquo;into\u0026rdquo; the Farmer pipeline.\nTest out the JSON model you created and make sure it creates the resources in Azure you would expect. You can deploy with execute or you can use whatIf to see what the expected state would be.\nStep 1.2: Convert from JSON to an F# anonymous record For simple ARM resources, raw JSON may suffice, but normally you\u0026rsquo;ll want a little more control in order to programmatically choose whether to add / remove fields etc. during the export phase. The best way to do this is to replace the raw string export with an anonymous record:\nlet registries name sku adminUserEnabled = {| name = name ``type`` = \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; apiVersion = \u0026#34;2019-05-01\u0026#34; location = \u0026#34;westeurope\u0026#34; tags = {| |} sku = {| name = sku |} properties = {| adminUserEnabled = adminUserEnabled |} |} |\u0026gt; Resource.ofObj Notice how the structure is the same, but is now implemented directly in F#.\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/arm-basics/","title":"ARM Basics","tags":[],"description":"","content":" Skip this section if you are already familiar with ARM Templates\n This won\u0026rsquo;t be an introduction to Azure Resource Manager or ARM templates. Instead let\u0026rsquo;s go through the main parts that are important for creating a new resource.\nThe main parts of ARM Templates can be broken into resources, outputs, variables, and parameters. Farmer has limited support for parameters and no support for variables, so we will not cover them.\nSo a generated ARM Template from Farmer will have the following structure.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#\u0026#34;, \u0026#34;contentVersion\u0026#34;: \u0026#34;1.0.0.0\u0026#34;, \u0026#34;outputs\u0026#34;: {}, \u0026#34;parameters\u0026#34;: {}, \u0026#34;resources\u0026#34;: [] } When building a new resource in Farmer you are providing the means for a user of Farmer to generate a new resource type, or configure a new property on an existing resource. These resources are added by Farmer to the resources array you can see above.\nWhen building up a resource it will have a schema that looks something like this.\n{ \u0026#34;name\u0026#34;: \u0026#34;my-example-resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westeurope\u0026#34;, \u0026#34;tags\u0026#34;: {}, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;S1\u0026#34; }, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: true, }, \u0026#34;resources\u0026#34;: [] } Your resource you create will have a type of service that it represents. Each service has many versions, represented by a date. Typically your builder will at first focus on adding properties to the properties field to configure a service to be deployed in a certain state.\nWhere can I find docs on ARM templates schemas themselves? There are three good sources to learning about specific ARM resources and what parts need to be used in creating an equivalent Farmer resource:\n Reference Docs: The reference documentation contains details on the schema for every resource and every version e.g. Container Registry reference. Sample Template: The Azure Quickstart Templates github repository contains many examples of real-world ARM templates e.g. Container Registry with Geo Replication sample. Reverse engineer: You can manually create a required resource in Azure, and then use Azure\u0026rsquo;s export ARM template functionality to create an ARM template. It\u0026rsquo;s important that you test out the exported template yourself before porting it to Farmer, because Azure sometimes exports invalid templates!  "},{"uri":"https://compositionalit.github.io/farmer/contributing/outputs-and-expressions/","title":"Outputs and ARM Expressions","tags":[],"description":"","content":"Outputs can be created in Farmer for any ARM Expression, Resource Name or any optional string. ARM Expressions are most useful in this case for referring to values that only exist at deployment time, such as connection strings.\n Creating ARM Expressions Farmer ARM expressions are in reality just wrapped strings, and are easy to create. For example, the code to create a Storage Key property is similar to this:\nlet buildKey accountName : ArmExpression = // Create the raw string of the expression  let rawValue = sprintf \u0026#34;concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=%s;AccountKey=\u0026#39;, listKeys(\u0026#39;%s\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)\u0026#34; accountName accountName // Wrap the raw value in an ARM Expression and return it  ArmExpression rawValue Notice that you do not wrap the expression in square brackets [ ]; Farmer will do this when writing out the ARM template.\nExtracting the value of an ARM Expression ARM expressions also have the following members on them:\n Map - standard map Bind - standard bind Value - Returns the raw string value Eval - Returns the string as a formatted ARM expression i.e. surround in []  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/expressions/","title":"ARM Expressions","tags":[],"description":"","content":"ARM template expressions are a way of safely storing string values which contain expressions that are evaluated at deployment time by the Azure. ARM expressions can also contain a set of predefined functions supported by the ARM runtime. They can be passed back as outputs and used further downstream\nFarmer understands how to use ARM expressions and provides functionality to correctly wrap and unwrap them as raw strings into a JSON template.\n For manipulation of literal values that are known in your Farmer applications, you will not need to use ARM expressions. To manipulate such values, you can use standard F# and .NET capabilities.\n How do I use ARM expressions? Many Farmer builders contain pre-defined ARM expression that can be used for common tasks, such as passing a connection string from a storage account as a KeyVault secret, or a web application setting.\nAs an example, a Storage Account config contains a Key member that you can supply this to a web app as a setting:\nlet storageConfig = storageAccount { name \u0026#34;myStorageAccount\u0026#34; } let webAppConfig = webApp { name \u0026#34;myWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; storageConfig.Key } This will be written to the ARM template file as follows:\n\u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=myStorageAccount;AccountKey=\u0026#39;, listKeys(\u0026#39;myStorageAccount\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } Using ARM expressions means that you can deploy an application which is automatically configured at deployment time. This means that you never need to store an application secret such as a storage account key in source control, or even e.g. as a secret variable in your build / deployment process.\nReturning the value of ARM Expressions as outputs. ARM Expressions can also be passed back as outputs and used further downstream once your deployment is complete:\nlet template = arm { location Location.WestEurope add_resource storageConfig // Mark the storage_key as an output in the ARM template.  output \u0026#34;storage_key\u0026#34; storageConfig.Key } // Deploy the template. let outputs = template |\u0026gt; Deploy.execute template [] // Get the value of the storage_key. let key = outputs.[\u0026#34;storage_key\u0026#34;] Be aware though, that the value of the storage_key is visible as a plain text value in the output - so anyone with access to, for example, the Azure portal will be able to see the values of the storage key if they look at the deployment history.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/parameters/","title":"Parameters and Variables","tags":[],"description":"","content":"ARM templates support the idea both of parameterisation of templates and of the use of variables within a template for e.g. placeholders and re-using values.\nFarmer, by design, has only limited support for parameters and no support for variables. We don\u0026rsquo;t plan on adding rich support for either of these for the following reasons:\n We want to keep the Farmer codebase simple for maintainers We want to keep the Farmer API simple for users We want to keep the generated ARM templates as readable as possible We feel that instead of trying to embed conditional logic and program flow directly inside ARM templates in JSON, if you wish to parameterise your template that you should use a real programming language to do that: in this case, F#.  You can read more on this issue here\nSecure Parameters Farmer does support securestring parameters for e.g. SQL and Virtual Machine passwords - these are automatically generated based on the contents of the template rather than explicitly by yourself.\nFor example, assume the following Farmer SQL resource:\nlet db = sql { server_name \u0026#34;myserver\u0026#34; db_name \u0026#34;mydatabase\u0026#34; admin_username \u0026#34;mradmin\u0026#34; } This will generate an ARM template which looks as follows (irrelevant content is elided for clarity):\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;password-for-myserver\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;securestring\u0026#34; } }, \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2014-04-01-preview\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;myserver\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;administratorLogin\u0026#34;: \u0026#34;mradmin\u0026#34;, \u0026#34;administratorLoginPassword\u0026#34;: \u0026#34;[parameters(\u0026#39;password-for-myserver\u0026#39;)]\u0026#34;, }, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Sql/servers\u0026#34; } ] } Working with variables ARM templates allow you to declare variables inside a template to reuse a value across a template. ARM templates also allow the use of a custom set of a commands which are embedded within strings to generate program logic, using expressions which contain template functions. For example, to concatenate a string inside a ARM template made up of two variables and put into a third variable, you might use something like the following:\n{ \u0026#34;variables\u0026#34;: { \u0026#34;first\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;second\u0026#34;: \u0026#34;World\u0026#34;, \u0026#34;serverName\u0026#34;: \u0026#34;[concat(variables(\u0026#39;first\u0026#39;), \u0026#39; \u0026#39;, variables(\u0026#39;second\u0026#39;), \u0026#39;!\u0026#39;)]\u0026#34; } } In F#, you have access to the full power of .NET, rather than a limited set of weakly-typed functions:\nlet first = \u0026#34;Hello\u0026#34; let second = \u0026#34;World\u0026#34; let serverName = first + \u0026#34; \u0026#34; + second + \u0026#34;!\u0026#34; let dbName = sprintf \u0026#34;%s %s!\u0026#34; first second let db = sql { server_name serverName db_name dbName admin_username \u0026#34;mradmin\u0026#34; } Rapidly creating multiple resources You can also use F# list comprehensions to rapidly create several resources of the same type:\n// Create five SQL servers and databases let myDatabases = [ for i in 1 .. 5 -\u0026gt; sql { server_name (sprintf \u0026#34;server%d\u0026#34; i) db_name (sprintf \u0026#34;database%d\u0026#34; i) admin_username \u0026#34;mradmin\u0026#34; } ] // Add all five databases to the deployment let deployment = arm { location Location.NorthEurope add_resources myDatabases } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/arm/","title":"ARM Deployment","tags":[],"description":"","content":"Overview The ARM deployment builder is always the top-level element of your deployment. It contains the manifest of all Farmer resources that you create.\nBuilder Keywords    Keyword Purpose     location Sets the default location of all resources.   add_resource Adds a resource to the template.   add_resources Adds a collection of resources to the template.   output Creates an output value that will be returned by the ARM template. Since Farmer does not require variables, and the only parameters supported are secure strings, these will typically be an ARM expressions that are generated at deployment-time, such as the publishing password of a web app or the fully-qualified domain name of a SQL instance etc.    Example let deployment = arm { // All resources will share this location  location Location.NorthEurope // Assume myStorageAccount and myWebApp have been defined...  add_resource myStorageAccount add_resource myWebApp output \u0026#34;webAppName\u0026#34; myWebApp.Name output \u0026#34;webAppPassword\u0026#34; myWebApp.PublishingPassword } "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-2/","title":"Working with multiple resources","tags":[],"description":"","content":"Introduction In this quickstart, you\u0026rsquo;ll expand on the deployment authored in the previous quickstart as follows:\n add an Azure storage account add an application setting to the web app that references the storage account\u0026rsquo;s key set a dependency between the two resources  Creating a storage account Create a storage account by using the storageAccount builder.\nlet myStorage = storageAccount { name \u0026#34;yourfirststorage\u0026#34; }  Azure Storage Account names must be globally unique and between 3-24 alphanumeric lower-case characters!\n Referencing the storage account in the web app In this section, we will add an app setting to the web app and set the value to the storage account\u0026rsquo;s connection string.\n In F#, you need to define a value before you reference it, so make sure that you define the storage account above the web app.\n Add the storage account\u0026rsquo;s connection key to the webapp as an app setting.\nlet myWebApp = webApp { ... setting \u0026#34;storageKey\u0026#34; myStorage.Key } If you\u0026rsquo;re coming from a raw ARM template background, don\u0026rsquo;t worry about the need to set dependencies between the Storage Account and Web App - Farmer will automatically do this for you!\n Settings can be strings or (as in this case) an ARM expression, which is evaluated at deployment time.\n Adding the storage account to the deployment Add the storage account to the deployment using the same add_resource keyword as you did with myWebApp.\nAnalysing the ARM template Run the application:\ndotnet run You should notice that the template now contains a storage account. Also observe the dependency that has been created:\n{ \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2016-08-01\u0026#34;, \u0026#34;dependsOn\u0026#34;: [ \u0026#34;[resourceId(\u0026#39;Microsoft.Storage/storageAccounts\u0026#39;, \u0026#39;yourfirststorage\u0026#39;)]\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Web/sites\u0026#34; } ] } Also observe the application setting that has been created:\n{ \u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=yourfirststorage;AccountKey=\u0026#39;, listKeys(\u0026#39;yourfirststorage\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } ] } The full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorage\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/","title":"Quickstarts","tags":[],"description":"","content":"This section contains quickstarts to performing common tasks.\n Creating your first Farmer template Creating multiple resources Deploying to Azure The Farmer .NET Template  "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/2-iarm-resource/","title":"2. The IArmResource","tags":[],"description":"","content":"In this exercise, we\u0026rsquo;ll migrate our code from the previous step directly into the Farmer codebase.\nStep 2.1: Migrating to IArmResource Now that you know that your resource model produces the correct Json value when passed into Farmer, we can now create a formal IArmResource statically that contains the \u0026ldquo;parameterised\u0026rdquo; parts of the above function, such as name, sku and adminUserEnabled and properly take part in the Farmer pipeline. This record should use types as required to capture e.g. SKUs or other elements that would benefit from typing (in the example above, sku is a string, but we will shortly replace that with a union type).\n Try to avoid going too far - the implementation of JsonModel should, more or less, be a copying of fields across and adding in some extra boilerplate around the type field etc. Feel free to use member properties to capture values that are \u0026ldquo;derived\u0026rdquo; from other ones.\n // src/Farmer/Arm/ContainerRegistry.fs [\u0026lt;AutoOpen\u0026gt;] module Farmer.Arm.ContainerRegistry open Farmer // Temporarily define the SKU and other types alongside the IArmResource. type Sku = | Basic | Standard | Premium type Registries = { Name : ResourceName Location : Location Sku : Sku AdminUserEnabled : bool } interface IArmResource with member this.ResourceName = this.Name member this.JsonModel = {| name = this.Name.Value ``type`` = \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; apiVersion = \u0026#34;2019-05-01\u0026#34; sku = {| name = this.Sku.ToString() |} location = this.Location.ArmValue tags = {||} properties = {| adminUserEnabled = this.AdminUserEnabled |} |} :\u0026gt; _ Notice how we perform simple \u0026ldquo;serialization\u0026rdquo; of elements such as the SKU, but otherwise most fields are copies across.\nStep 2.2: Move domain types out of the IArmBuilder. For now, we\u0026rsquo;ve created any associated types such as Sku directly above the file, but you\u0026rsquo;ll want to migrate these to a Farmer.ContainerRegistry module in Common.fs afterwards e.g.\n// src/Farmer/Common.fs namespace Farmer module ContainerRegistry = type Sku = | Basic | Standard | Premium You can test this again easily by passing an instance into a Farmer deployment like we did in the previous step:\nopen Farmer.Arm.ContainerRegistry let registries = { Name = ResourceName \u0026#34;my-registry\u0026#34; Location = Location.WestEurope Sku = ContainerRegistry.Basic AdminUserEnabled = true } let deployment = arm { location Location.NorthEurope add_resource registries } deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34; Note that F# records must be completely filled, so you must provide values for all four fields.\nAlternatively, you could now write a test to assert the Json structure. Most tests in the project though tend to test from the Farmer builders, which we will get to soon. You can stop right here if you want - what you\u0026rsquo;ve done so far allows you to create IArmResource objects which can be added to the Farmer pipeline. However, we will go further in the next exericse and make it even easier to create Container Registries by creating an IBuilder.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/","title":"Tutorials","tags":[],"description":"","content":"This section contains tutorials for specific use-cases. Use these to help get ideas for how to model your Farmer resources!\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/bastion-host/","title":"Bastion Host","tags":[],"description":"","content":"Overview The Bastion Host builder creates a bastion host to access resources inside a virtual network. It also creates a static public IP for the bastion host.\n BastionHosts (Microsoft.Network/bastionHosts)  Builder Keywords    Applies To Keyword Purpose     BastionHost vnet Name of the virtual network the bastion host can access    Example #r @\u0026#34;./libs/Newtonsoft.Json.dll\u0026#34; #r @\u0026#34;../../src/Farmer/bin/Debug/netstandard2.0/Farmer.dll\u0026#34; open Farmer open Farmer.Builders arm { location Location.EastUS add_resources [ vnet { name \u0026#34;private-network\u0026#34; add_address_spaces [ \u0026#34;10.1.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;default\u0026#34; prefix \u0026#34;10.1.0.0/24\u0026#34; } subnet { name \u0026#34;AzureBastionSubnet\u0026#34; prefix \u0026#34;10.1.250.0/27\u0026#34; } ] } bastion { name \u0026#34;my-bastion-host\u0026#34; vnet \u0026#34;private-network\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/dependencies/","title":"Dependencies","tags":[],"description":"","content":"ARM resources can depend on one another, and Farmer caters for this as well. Dependencies guarantee that when resources are created, Azure will provision them in the correct order so that e.g. a storage account is created before Azure tries to grab the storage account key / connection string for your web app setting.\nMuch of this work is done for you:\n Farmer creates multiple resources for you at the builder level, and will ensure that the appropriate dependencies are set for you - for example, when creating a SQL Azure instance, Farmer will automatically ensure that the database depends on the server. Farmer will generally identify dependencies correctly when you have a relationship between builders, such as setting the key of a storage account on a web app.  Automatic dependency detection In the sample below, the web app { } will automatically realise that it needs to depend on Storage Account based on the \u0026ldquo;owner\u0026rdquo; of Key expression that is supplied.\nlet myStorage = storageAccount { name \u0026#34;sampleaccount\u0026#34; } let myApp = webApp { name \u0026#34;myapp\u0026#34; setting \u0026#34;storage_key\u0026#34; myStorage.Key } Manually setting dependencies Normally, Farmer will do everything you need. However, there are some times when you may need to explicitly set a dependency:\n Farmer has not automatically detected the dependencies (please raise an issue if you notice this!). You\u0026rsquo;re setting a dependency on a resource that you\u0026rsquo;re creating yourself, outside of Farmer. You want to set a dependency even though there is no explicit coupling between two resources / builders.  Setting a dependency requires you to call the depends_on keyword on the target resource, providing a handle to the dependent resource.\nlet myStorage1 = storageAccount { name \u0026#34;sampleaccountFirst\u0026#34; } let myApp = webApp { name \u0026#34;myapp\u0026#34; depends_on myStorage1 } Here, we set up an explicit dependency on myApp for myStorage.\nAdding multiple dependencies at once You can also supply multiple dependencies at once as a list; this is useful if you are programmatically creating multiple resources.\n// Create five storage accounts let storageAccounts : IBuilder list = [ for letter in [ \u0026#39;a\u0026#39; .. \u0026#39;e\u0026#39; ] do storageAccount { name (sprintf \u0026#34;mystorage%c\u0026#34; letter) } ] let myApp = webApp { name \u0026#34;myapp\u0026#34; depends_on storageAccounts // add them all to the web app as dependencies } Notice the extra type hint, : IBuilder list. This is required because F# does not, by default, allow you to implicitly treat a list of values as a supertype. In this case, a StorageAccountConfig list is not considered implicitly convertable to : IBuilder list (which is an interface that StorageAccountConfig implements). Therefore, we have to do it ourselves using the extra type declaration.\nYou can also use the :\u0026gt; (safe upcast) operator when declaring the StorageAccount:\nlet storageAccounts = [ // inferred as IBuilder list  for letter in [ \u0026#39;a\u0026#39; .. \u0026#39;e\u0026#39; ] do storageAccount { name (sprintf \u0026#34;mystorage%c\u0026#34; letter) } :\u0026gt; IBuilder ]  We\u0026rsquo;re looking at improving this situation in the future using F#\u0026lsquo;s \u0026ldquo;flexible types\u0026rdquo; feature.\n All builders that support dependencies support a number of depends_on overloads:\n A single, or a list of, Builders (as shown above) A single, or a list of, resources by their Name A single, or a list of, IArmResources  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/outputs/","title":"Outputs","tags":[],"description":"","content":"ARM templates also support the notion of outputs. Outputs can be used to provide your Farmer applications with values which were generated during the deployment process, to be used further downstream.\nFor example, you may wish to prime an Azure storage account with data post-creation. In this case, one way is to return back out the connection string of the storage account and use that to connect and upload your data.\nCreating and Consuming outputs Outputs are applied onto the arm { } builder using the output keyword.\nlet myStorage = storageAccount { name \u0026#34;sampleaccount\u0026#34; } let template = arm { add_resource myStorage output \u0026#34;storage_key\u0026#34; myStorage.Key } let outputs = template |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [] let connectionString = outputs.[\u0026#34;storage_key\u0026#34;] Outputs are returned back from the deployment as a simple Map\u0026lt;string, string\u0026gt;.\nAny ARM expression can be returned as an output, and you can create as many outputs as you wish.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/","title":"API Overview","tags":[],"description":"","content":"API aims The key guiding principles of the Farmer API are (in order):\n Simplicity: Make it as easy as possible to do the most common tasks. Type safety: Where possible, use F#\u0026lsquo;s type system to make it impossible to create invalid templates. Flexibility: Provide users with the ability to override the defaults where needed.  Farmer Resources Farmer works on a simple, consistent process:\n You create Farmer resources, such as Storage Accounts and Web Apps. Each Farmer resource can represent one or many ARM resources. For example, a Farmer webApp resource represents both the Microsoft.Web/sites and Microsoft.Web/serverfarms resources. In addition, it optionally also provides simplified access to an Microsoft.Insights/components. You configure each resource using simple, human-readable custom keywords in a strongly-typed environment. You link together resources as required. Once you have created all resources, you bundle them up together into an ARM deployment resource. You then generate (and optionally deploy) an ARM template. The rest of your deployment pipeline stays the same.  The diagram below illustrates how Farmer resources map to ARM ones:\ngraph TD subgraph ARM Template classDef danger fill:orange; C(Microsoft.Web/serverfarms) -. dependency .-F D(Microsoft.Insights/components) -. dependency .-F E(Microsoft.Storage/storageAccounts) -. dependency .-F E -. storage key .- F E -. storage key .- G F(Microsoft.Web/sites) G(blobServices/containers) class C danger class D danger class E danger class F danger class G danger end subgraph Farmer A(webApp)-. depends on .-B B(storageAccount)-. key .-A end  In this example, we create a storage account and web app in Farmer, which maps five different ARM template resources. As you can see, resources in Farmer are declared at a higher level of abstraction than ARM template resources. This makes things much simpler to reason about, and quicker to author.\nAn example Farmer Resource All Farmer resources follow the same approach:\n You define a resource using a special \u0026ldquo;builder\u0026rdquo; that allows the use of custom keywords. This is known as an F# computation expression. Each builder is designed for a specific type of Azure resource e.g. websites, functions, virtual machines etc., and each has defaults set for the most common scenario. This resource is validated and converted into a Farmer configuration object, which contains the configuration for that resource including any defaults. This configuration is then added to an overarching Farmer ARM deployment object. The ARM deployment object is converted into an ARM template json file.  graph LR subgraph JSON C(ARM Template) end subgraph .NET A(Farmer Builder)--validation and defaults --B B(Farmer Configuration) --emitted to -- C end  Here\u0026rsquo;s an example web application.\nlet myWebApp = webApp { name \u0026#34;mystorage\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku Sku.B1 always_on app_insights_off worker_size WorkerSize.Medium number_of_workers 3 run_from_package }  The webApp { } builder defines the start and end of the definition of the web application. Within this builder, you use custom keywords to configure the web app, such as name and setting. Some keywords take arguments, but others e.g. always_on are simple declarative markers.   You can view details of all farmer resources in the resource guide.\n Putting it all together The diagram above can be shown in code as follows:\n/// An Azure Storage account with a container. let storage = storageAccount { name \u0026#34;astorageaccount\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } /// An Azure App Service with built-in App Insights. let app = webApp { name \u0026#34;awebapp\u0026#34; setting \u0026#34;storageKey\u0026#34; storage.Key // pull in the storage key to an app setting  depends_on storage // state that this web app depends on the storage account } /// An ARM deployment with both of the above resources attached let deployment = arm { location Location.NorthEurope add_resource storage add_resource app } // Write the ARM template out to myTemplate.json let filename = deployment.Template |\u0026gt; Writer.toJson |\u0026gt; Writer.toFile \u0026#34;myTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-3/","title":"Deploying to Azure","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll update the application to deploy the generated ARM template to Azure directly from Farmer.\n Farmer generates normal ARM templates. You use all of the standard mechanisms for deploying ARM templates such as through the portal, Powershell, .NET or Azure CLI etc. This tutorial shows you a simple way to deploy templates from your development machine directly from within F#.\n Install the Azure CLI If you haven\u0026rsquo;t done so already, install the Azure CLI on your machine.\nDeploy the template As Farmer emits standard ARM templates, you can use all the standard ARM template deployment tools at your disposal - whether that\u0026rsquo;s Visual Studio, Powershell, or the Azure CLI. In our case, we can also use Farmer\u0026rsquo;s API which wraps around the Azure CLI.\nModify the application you created at the end of quickstart #2 so that instead of writing the template to a file, we deploy it directly:\ndeployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters  Note that the Web Application and Storage Account names should be globally unique; they must be unique across Azure i.e. someone else can\u0026rsquo;t have another web app or storage account with the same name!\n Farmer will now create the ARM template, and also generate a batch / shell script which calls the Azure CLI. You\u0026rsquo;ll be prompted to login to Azure by the CLI, after which point it will create the named resource group in the location specified in the arm { } builder.\nWait until the process is completed and log into the Azure Portal. Navigate to the newly-created resource group and inspect the overview record list e.g.\nCongratulations - you\u0026rsquo;ve now created and deployed an ARM template entirely from F#!\nThe full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorageaccount\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/3-ibuilder/","title":"3. The IBuilder interface","tags":[],"description":"","content":"Sometimes, ARM resources are captured at a level of abstraction that is too low for us to reason about. In such cases, we\nAn IBuilder is not only even easier to consume by users than the F# record above, but can create multiple IArmResource objects at once. This is especially useful for more complex resources that tend to come in groups of two or three together - for example, Server Farm and Web Apps, or Cosmos DB Accounts, Databases and Containers. An IBuilder encapsulates the logic needed to create and configure all the resources together.\n In this example, the Container Registry builder only creates a single resource.\n Step 3.1: The Configuration Record The first step is to create a simple configuration record that contains any data that is required to be captured by the user. Often, this may map nearly 1:1 with the IArmResource - normally the main difference will be that you do not need to provide the Location here, as Farmer will automatically provide that for you.\n// src/Farmer/Builders.ContainerRegistry.fs type ContainerRegistryConfig = { Name : ResourceName Sku : Sku AdminUserEnabled : bool } interface IBuilder with member this.DependencyName = this.Name member this.BuildResources location _ = [ { Name = this.Name Location = location Sku = this.Sku AdminUserEnabled = this.AdminUserEnabled } The IBuilder interface has two methods:\n DependencyName - this is the name of the resource. It\u0026rsquo;s used by Farmer when setting dependencies between multiple resources. BuildResources - this functions takes in two arguments: the location the resources should be deployed to, and a list of any existing resources that have been created so far. Normally, you can ignore the second argument. The method should return the list of IArmResource resources that must be created - as you can see, this is a relatively simple mapping. For more complex builders e.g. one which represent multiple IArmResources at once, your BuildResources function will emit a list of IArmResources.   It\u0026rsquo;s tempting to suggest simply applying IBuilder directly onto the IArmResource. You could probably do this, but the separation and clarity provided here is an important step, and gives freedom in the future to diverge the shapes of the builder and the resource.\n Step 3.2 Test out the IBuilder. You can finish this exercise by confirming that your IBuilder works correctly:\nopen Farmer.Builders.ContainerRegistry let registries = { Name = ResourceName \u0026#34;my-registry\u0026#34; Sku = ContainerRegistry.Basic AdminUserEnabled = true } let deployment = arm { location Location.WestEurope add_resource registries } deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34;  Ensure that the location of WestEurope has been correctly applied to the emitted ARM template json file!\n "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cdn/","title":"CDN","tags":[],"description":"","content":"Overview The CDN builder is used to create Azure Content Delivery Network instances.\n CDN Profile (Microsoft.Cdn/profiles) CDN Endpoint (Microsoft.Cdn/profiles/endpoints) CDN Custom Domain (Microsoft.Cdn/profiles/endpoints/customDomains)  There are two builders available:\n The CDN builder, which maps to a CDN profile. The Endpoint builder, which creates endpoints and custom domains. Endpoints are created within a CDN.  CDN Builder Keywords    Keyword Purpose     name Sets the name of the CDN instance.   sku Sets the SKU of the CDN instance. Defaults to Standard Akamai.   add_endpoints Adds several endpoints to the CDN.    Endpoint Builder Keywords    Keyword Purpose     name Sets the name of the endpoint instance. If you do not set this, a name is generated based on the origin.   origin Sets the address of the origin and is used to auto-generate the endpoint name if none if supplied.   depends_on Sets dependencies on this endpoint.   add_compressed_content Adds a set of content types to compress.   query_string_caching_behaviour Specifies the Query String Caching Behaviour.   enable_http Enables HTTP delivery on the endpoint.   disable_http Disables HTTP delivery on the endpoint.   enable_https Enables HTTPS delivery on the endpoint.   disable_https Disables HTTPS delivery on the endpoint.   custom_domain Sets the custom domain name to use on the endpoint.   optimise_for Optimises delivery for a specific type of content.     Storage Accounts and Web Apps have special support for CDN endpoints. You can supply a storage account or web app builders directly as the origin.\n Example let isaacWebApp = webApp { name \u0026#34;isaacsuperweb\u0026#34; app_insights_off } let isaacStorage = storageAccount { name \u0026#34;isaacsuperstore\u0026#34; } let isaacCdn = cdn { name \u0026#34;isaacsupercdn\u0026#34; add_endpoints [ endpoint { origin isaacStorage optimise_for Cdn.OptimizationType.LargeFileDownload } endpoint { origin isaacWebApp disable_http } endpoint { name \u0026#34;custom-endpoint-name\u0026#34; origin \u0026#34;mysite.com\u0026#34; add_compressed_content [ \u0026#34;text/plain\u0026#34;; \u0026#34;text/html\u0026#34;; \u0026#34;text/css\u0026#34; ] query_string_caching_behaviour Cdn.BypassCaching } ] } "},{"uri":"https://compositionalit.github.io/farmer/arm-vs-farmer/","title":"Farmer and ARM","tags":[],"description":"","content":"    Farmer ARM Template     Core ARM features     Repeatable deployments? Yes, Farmer runs on top of ARM Yes   ARM deployment mechanisms? All, plus easy-to-use F# deployment All   Variables support? Yes, native support in F# Yes   Parameters support? Yes, native support in F# or secure parameters Yes   Supported resources? All, including custom builders for ~50 popular resources All   Declarative model support? Yes Yes   Support for all ARM tools? Yes, Farmer runs on top of ARM Yes   Linked Template support? No - generally not required. Yes   Authoring     Easy to author? Yes No   Easy to read? Yes No   Documented? Yes, website and discoverable intellisense Limited, documented but often out-of-date   Editor support? Yes, any F# editor including VS Code, VS and Rider Limited, only VS Code has any support   Safety     Type-safe? Yes, full support from the F# compiler and type system Limited through VS Code extension and LSP   Validation support? Edit-time, run-time, deploy-time Deploy-time and limited edit-time   Flexibility     Link resources easily? Yes Not easily complex path expressions must be known   Compose resources together? Yes Not easily   Create multiple resources simultaneously? Yes No, each resource must be defined separately   Create resources in several ways? Yes, builders, records, functions or classes No, must use JSON   Full programming language? Yes, F# is a simple yet powerful programming language No, JSON with limited functions   Imperative model? Yes, F# supports imperative programming No, you must program in a declarative style   Interop and extensibility     Add your own ARM resources? Yes, plug-in model to add new ARM resources N/A   Create your own combinations of resources? Yes No, each resource must be defined separately   Use external libraries? Yes, use any NuGet packages during authoring and full .NET Core No, fixed set of functions   Use in .NET applications? Yes, Farmer is a .NET Core library and can be used in-proc No, JSON files    "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cognitive-services/","title":"Cognitive Services","tags":[],"description":"","content":"Overview The Cognitive Services builder is used to create Azure Cognitive Services instances.\n Cognitive Services (Microsoft.CognitiveServices/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Cognitive Services instance.   sku Sets the SKU of the instance. Defaults to F0 (free).   api Specifies the Kind of api to use for the service instance. Defaults to AllInOne.    Configuration Members    Member Purpose     Key Gets the ARM expression path to the Key of this Cognitive Services instance.    Example open Farmer open Farmer.Builders let translator = cognitiveServices { name \u0026#34;mytranslator\u0026#34; sku CognitiveServices.F0 api CognitiveServices.AnomalyDetector } let key : ArmExpression = translator.Key "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/template/","title":"The Farmer .NET Template","tags":[],"description":"","content":"Farmer comes with a .NET template that makes getting started easy.\nCreating a basic Farmer app The easiest way to create a Farmer app is to use the Farmer .NET Template.\ndotnet new -i Farmer.Template dotnet new Farmer  You only have to install the template once on your machine!\n This creates a new dotnet application solution and project that looks by default as follows:\nopen Farmer open Farmer.Builders let deployment = arm { location Location.NorthEurope } printf \u0026#34;Generating ARM template...\u0026#34; deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34; printfn \u0026#34;all done! Template written to output.json\u0026#34; From here, you can add resources in the normal manner.\nBasic configuration options You can configure the template using the following optional arguments.\nARM Template filename The name of the ARM template JSON file e.g. --armTemplate myTemplate\nLocation The location to create resources in e.g. --location WestUS\nDeploy Configuration You can also configure the Farmer template to deploy to Azure out of the box using the --ci option. This has two modes of operation:\nAzure DevOps deployment This comes with a ready-made devops YAML file designed for simple CI/CD, using Farmer to generate ARM templates and Azdo to deploy using its own ARM Template deployment process. You should supply the following arguments:\n \u0026ndash;ci: Tells the template to create a Farmer app for use with Azure Devops. \u0026ndash;azureSubscription: Set the full name of the Azure Subscription that has been already configured in Azdo that has permission to deploy templates to Azure. \u0026ndash;resourceGroup: Set the name of the resource group that you wish to deploy to.  Direct deployment If you prefer a deployment process that is not coupled to Azure Devops, you can create a service principle in Azure and use the generated credentials in Farmer. Farmer will use its own wrapper around the Azure REST API to deploy to Azure, reporting progress to the console.\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/4-creating-builder-syntax/","title":"4. Providing Builder syntax","tags":[],"description":"","content":"If you want to get the nice json-like syntax for your configuration record, you need to implement a separate class which contains a set of methods that act on the Configuration Record that you created previously - one for each keyword that you want.\n If you need have not built your own computation expression before, here are some resources to brush up:\n Office microsoft docs The \u0026ldquo;Computation Expressions\u0026rdquo; series Workshop   Step 4.1: Creating basic keywords We will not cover the inner details of creating a CE here. But to get started the only member you need to implement id Yield, which returns a minimal implementation of your resource.\n// Builder.ContainerRegistry.fs type ContainerRegistryBuilder() = /// Required - creates default \u0026#34;starting\u0026#34; values  member _.Yield _ = { Name = ResourceName.Empty Sku = Basic AdminUserEnabled = false } [\u0026lt;CustomOperation \u0026#34;name\u0026#34;\u0026gt;] /// Sets the name of the Azure Container Registry instance.  member _.Name (state:ContainerRegistryConfig, name) = { state with Name = ResourceName name } [\u0026lt;CustomOperation \u0026#34;sku\u0026#34;\u0026gt;] /// Sets the name of the SKU/Tier for the Container Registry instance.  member _.Sku (state:ContainerRegistryConfig, sku) = { state with Sku = sku } [\u0026lt;CustomOperation \u0026#34;enable_admin_user\u0026#34;\u0026gt;] /// Enables the admin user on the Azure Container Registry.  member _.EnableAdminUser (state:ContainerRegistryConfig) = { state with AdminUserEnabled = true } let containerRegistry = ContainerRegistryBuilder() Each keyword has a similar set of steps required:\n Create a member which takes in at least one argument, the current state object. The implement should perform some modification and return back the newly-updated state. Decorate the method with the CustomOperation attribute; the string value passed to it will become the keyword name. Use _ to separate words of the keyword e.g. enable_admin_user. Put a /// comment on the method for intellisense to guide users.  Now you can create members on the builder that appear as custom operators in your resource CE. In each member you build up the state of the resource configuration you created in the previous step.\n Don\u0026rsquo;t forget to assign an instance of the builder to a value so it is available for consumers!\n Parameterless keywords You can create parameterless keywords by simply only taking in the state argument e.g. enable_admin_user above.\nKeywords with multiple arguments You can take in multiple arguments by simply putting a comma after each additional argument. They will be consumed by the user with spaces.\nOverloaded keywords You can provide multiple overloads for a keyword. However, each overload must take in the same number of arguments. Do not re-apply the CustomOperation attribute - simply provide multiple methods with the same name.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/cosmos-backed-webapp/","title":"Cosmos-backed Web App","tags":[],"description":"","content":"Introduction This tutorial walks you through creating a web application which is backed by a Cosmos DB database, and is fully configured with connection string settings for you to start developing against. We\u0026rsquo;ll cover the following steps:\n Creating a Cosmos DB account with a single database. Creating a web application with an automatically configured app insights instance. Configuring the web application to have the connection settings required to connect to the Cosmos DB instance.    Full code available here\n  Create the CosmosDB instance Create a CosmosDB instance using the cosmosDb builder:\nopen Farmer open Farmer.Builders open Farmer.CosmosDb let theDatabase = cosmosDb { name \u0026#34;Tasks\u0026#34; account_name \u0026#34;isaac-to-do-app-cosmos\u0026#34; consistency_policy Session } Create and configure a web app Create a web application, and provide settings that are derived from the Cosmos DB instance that you just created.\n The API of the functions builder is virtually identical to that of the Web App builder. You can replace webApp with functions below, removing the sku keyword, and you will get a working Azure Functions instance instead.\n let theApp = webApp { name \u0026#34;isaac-to-do-app\u0026#34; sku WebApp.Sku.B1 setting \u0026#34;CosmosDb:Account\u0026#34; theDatabase.Endpoint setting \u0026#34;CosmosDb:Key\u0026#34; theDatabase.PrimaryKey setting \u0026#34;CosmosDb:DatabaseName\u0026#34; theDatabase.DbName setting \u0026#34;CosmosDb:ContainerName\u0026#34; \u0026#34;Items\u0026#34; }  You don\u0026rsquo;t have to explicitly set a dependency between the two. Farmer will \u0026ldquo;pull out\u0026rdquo; the Cosmos DB details itself.\n You don\u0026rsquo;t have to be concerned about secrets of the CosmosDB instance leaking in your ARM template, because no secrets are supplied. Instead, your template will be populated with ARM expressions which will only be evaluated at runtime:\n{ \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:Account\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[reference(resourceId(\u0026#39;Microsoft.DocumentDb/databaseAccounts\u0026#39;, \u0026#39;isaac-to-do-app-cosmos\u0026#39;), \u0026#39;2020-03-01\u0026#39;).documentEndpoint]\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:ContainerName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Items\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:DatabaseName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Tasks\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:Key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[listKeys(resourceId(\u0026#39;Microsoft.DocumentDb/databaseAccounts\u0026#39;, \u0026#39;isaac-to-do-app-cosmos\u0026#39;), providers(\u0026#39;Microsoft.DocumentDb\u0026#39;,\u0026#39;databaseAccounts\u0026#39;).apiVersions[0]).primaryMasterKey]\u0026#34; } Add both resources to your ARM template let template = arm { location Location.WestEurope add_resources [ theDatabase theApp ] } You can now deploy the template and you\u0026rsquo;ll have a web application which has all required secrets to communicate with the Cosmos DB instance.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/multiple-web-apps/","title":"Multiple web apps","tags":[],"description":"","content":"Introduction This tutorial walks you through creating multiple web applications that will share a common web server. We\u0026rsquo;ll cover the following steps:\n Creating a web app. Creating multiple web apps and \u0026ldquo;sharing\u0026rdquo; the first web app\u0026rsquo;s service plan and Application Insights instances. How to use F#\u0026lsquo;s list comprehensions to rapidly creating multiple websites.    Full code available here\n  Creating a single web app Create a standard web app as normal:\nlet primaryWebApp = webApp { name \u0026#34;primarywebapp\u0026#34; sku WebApp.Sku.F1 } Creating secondary web apps Create a second web app, but this time link to the service plan that is part of the first web app:\nlet secondaryWebApp = webApp { name \u0026#34;secondarywebapp\u0026#34; link_to_service_plan primaryWebApp.ServicePlanName link_to_app_insights primaryWebApp.AppInsightsName } You can now add both web apps to the arm { } block for deployment:\nlet template = arm { location Location.NorthEurope add_resource primaryWebApp add_resource secondaryWebApp } Creating dedicated Service Plan and App Insights instances Rather than \u0026ldquo;piggy back\u0026rdquo; on a \u0026ldquo;primary\u0026rdquo; web app, you can also opt to create dedicated service plan and app insights instances and configure all web apps to use them. This is a slightly more verbose option, but you may find it clearer, and as we\u0026rsquo;ll see shortly, it can sometimes be useful to declare these instances outside of the web app:\nlet plan = servicePlan { name \u0026#34;theFarm\u0026#34; sku WebApp.Sku.F1 } let ai = appInsights { name \u0026#34;insights\u0026#34; } let aWebApp = webApp { name \u0026#34;primarywebapp\u0026#34; link_to_service_plan plan link_to_app_insights ai } let anotherWebApp = webApp { name \u0026#34;secondarywebapp\u0026#34; link_to_service_plan plan link_to_app_insights ai }  As you are creating the plan and AI instances yourself, you also need to remember to add them to the arm { } block!\n Rapidly creating multiple web apps F# has excellent support for working with collections of data, including creating data. Let\u0026rsquo;s assume we wanted to create four web apps, each with a name \u0026ldquo;mywebapp-{index}\u0026rdquo; e.g. \u0026ldquo;mywebapp-1\u0026rdquo; etc. We can use F#\u0026lsquo;s list comprehensions to create four web apps quickly and easily.\nlet webApps : IBuilder list = [ for i in 1 .. 4 do webApp { name (\u0026#34;mywebapp-\u0026#34; + string i) link_to_service_plan plan link_to_app_insights ai } ] The key parts to note are:\n Use of [ ], which in F# signify a list of some data. Use of for .. in .. do syntax to iterate over numbers 1 to 4, assigning each value to i. Creating unique names for each web app using simple string concatentation. An explicit type annotation (: IBuilder list). Without getting into too much detail, this is needed because F# is somewhat stricter about implicit type conversions than other languages, particularly around list contra/covariance.  List comprehensions in F# are very powerful. You can use this approach with a specific set of names that are themselves a list as well e.g.\nlet planets = [ \u0026#34;jupiter\u0026#34;; \u0026#34;mars\u0026#34;; \u0026#34;pluto\u0026#34;; \u0026#34;venus\u0026#34; ] let webApps = [ for planet in planets do ... ] Adding multiple resources to the template Once you have created a list of web apps, you can add them all at once to the ARM builder using the add_resources keyword:\nlet template = arm { ... add_resources webApps } "},{"uri":"https://compositionalit.github.io/farmer/tutorials/serverless-etl/","title":"Serverless ETL","tags":[],"description":"","content":"Introduction This tutorial shows how to create the infrastructure required to implement a common pattern for code-first \u0026ldquo;extract-transform-load\u0026rdquo; (ETL) processes. In this tutorial, imagine you wish to react to data being created in a blob in Storage, then parse it, and finally insert the \u0026ldquo;parsed\u0026rdquo; data into SQL in a relational database for use by e.g. a web application. We\u0026rsquo;ll cover the following steps:\n Creating an Azure Functions instance, with automatically configured storage and app insights instances. Creating a SQL Azure database and server. Configuring the Functions instance to have connection settings required to connect to both Storage and SQL instances. Safely providing a SQL Server password to Farmer at deployment time.    Full code available here\n  Create the SQL instance Create a SQL Server and database using the sqlServer builder. This server would be used for processed data at the end of the ETL pipeline.\nopen Farmer open Farmer.Builders let transactionalDb = sqlServer { name \u0026#34;etlserver\u0026#34; admin_username \u0026#34;theadministrator\u0026#34; add_databases [ sqlDb { name \u0026#34;parseddata\u0026#34;; sku Sql.DtuSku.S1 } ] }  We explicitly set the SKU of the database. You don\u0026rsquo;t have to do this; if you elect not to, Farmer will create an elastic pool and assign the database into that.\n Create and configure a Functions instance Create a functions instance which would contain the application that monitors the storage account for blobs, process each blob and then insert data into SQL. Also, provide the connection string that is derived from the SQL instance that you just created.\nlet etlProcessor = functions { name \u0026#34;etlprocessor\u0026#34; storage_account_name \u0026#34;mydata\u0026#34; setting \u0026#34;sql-conn\u0026#34; (transactionalDb.ConnectionString \u0026#34;parseddata\u0026#34;) }  Functions instances require a storage account to operate, and will automatically create one for you. In this sample, we have explicitly provided the storage account name; you don\u0026rsquo;t have to do this - Farmer will derive one based on the function instance name. If you prefer to manage the storage account yourself, you can create a storage account and use the link_to_storage_account keyword instead.\nFarmer will also automatically configure the functions instance with connection string settings for both the AzureWebJobsStorage and AzureWebJobsDashboard settings. You can use these to also configure your functions app to read from.\n Adding extra type safety for sharing resources If the mistype the database name for the connection string, Farmer will automatically fail and let you know at runtime. However, a better approach is to use F# to enforce sharing the same database name across the Function instance and SQL server by referencing the database instance directly, instead of a raw string:\nlet database = sqlDb { name \u0026#34;isaacparseddata\u0026#34; sku Sql.DtuSku.S1 } let transactionalDb = sqlServer { ... add_databases [ database ] } let etlProcessor = functions { ... setting \u0026#34;sql-conn\u0026#34; (transactionalDb.ConnectionString database) }  In this case, you don\u0026rsquo;t need to add the database as a resource to the arm { } block; Farmer will do it automatically as part of the sqlServer builder.\n Add both resources to your ARM template let template = arm { location Location.WestEurope add_resource transactionalDb add_resource etlProcessor } Deploy the template When deploying the template, you\u0026rsquo;ll need to provide the password for the SQL Server instance. This is captured as a secure parameter to the template; this guarantees that the password will not be stored in the ARM template as plain text.\n{ \u0026#34;parameters\u0026#34;: { \u0026#34;password-for-isaacetlserver\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;securestring\u0026#34; } } } The parameter name is automatically generated based on the server name. A member on the sql configuration value can be used to quickly get to this and to set the password at deployment time:\ntemplate |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ transactionalDb.PasswordParameter, \u0026#34;SQL PASSWORD GOES HERE\u0026#34; ] |\u0026gt; printfn \u0026#34;%A\u0026#34;  You should never commit secrets into source control. Instead, set environment variables or command line parameters to your Farmer program to read in the password and pass it into the execute function. For CI/CD tools such as Octopus or Azure DevOps, you can set secrets that appear as environment variables.\n "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/deployment-script/","title":"Deployment Script","tags":[],"description":"","content":"Overview The Deployment Script builder is used to execute Azure CLI scripts as part of an ARM deployment.\n Deployment Script (Microsoft.Resources/deploymentScripts)  Builder Keywords    Keyword Purpose     name Sets the name of the deployment script resource.   arguments List of arguments to pass to the script.   cli Specifies the CLI runtime, default is az cli.   content Sets script content for the resource.   env_vars Defines environment variables in the script environment.   force_update_tag A tag that cn be changed to force a resource update so the script is run again.   identity Sets the user assigned identity for the deployment script resource (must be a contributor in the resource group).   primary_script_uri Sets a URI to download script content.   retention_interval_days Sets the days to retain the script runtime infrastructure to run again quickly.   script_content Sets script content for the resource.   supporting_script_uris Sets a URI to download additional content for the script.   timeout Sets the maximum amount of time to allow the script to run.   add_tags Adds tags to the script runtime resource.   add_tag Adds a tag to the script runtime resource.    Example open Farmer open Farmer.Builders open Farmer.CoreTypes /// The deployment script must run under an identity with any necessary permissions /// to perform the commands in the script. Also must be a contributor in the /// resource group. let scriptIdentity = userAssignedIdentity { name \u0026#34;script-user\u0026#34; } /// The script identity must be a contributor over this resource group. let scriptRole = role_assignment (ArmExpression.create(\u0026#34;guid(resourceGroup().id)\u0026#34;).Eval()) Roles.Contributor scriptIdentity.PrincipalId /// Define the parameters, identity, and content for the script let getDateScript = deploymentScript { name \u0026#34;custom-script\u0026#34; identity scriptIdentity force_update_tag (System.DateTime.Now.ToString(\u0026#34;o\u0026#34;)) /// Format output as JSON and pipe to $AZ_SCRIPTS_OUTPUT_PATH to make it available as an output variable.  content \u0026#34;\u0026#34;\u0026#34;printf \u0026#34;{\u0026#39;date\u0026#39;:\u0026#39;%s\u0026#39;\u0026#34;} \u0026#34;`date`\u0026#34; \u0026gt; $AZ_SCRIPTS_OUTPUT_PATH \u0026#34;\u0026#34;\u0026#34; } /// The deployment runs the script and gets any output variables. let template = arm { location Location.EastUS add_resource scriptIdentity add_resource scriptRole add_resource getDateScript output \u0026#34;date\u0026#34; \u0026#34;[reference(\u0026#39;custom-script\u0026#39;).outputs.date]\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-group/","title":"Container Group","tags":[],"description":"","content":"Overview The Container Group builder is used to create Azure Container Group instances.\n Container Group (Microsoft.ContainerInstance/containerGroups)  Builder Keywords    Applies To Keyword Purpose     containerInstance name Sets the name of the Container Group instance.   containerInstance image Sets the container image.   containerInstance command Sets the commands to execute within the container instance in exec form.   containerInstance add_ports Sets the ports the container exposes.   containerInstance cpu_cores Sets the maximum CPU cores the container may use.   containerInstance memory Sets the maximum gigabytes of memory the container may use.   containerInstance env_vars Sets a list of environment variables for the container.   containerInstance add_volume_mount Adds a volume mount on a container from a volume in the container group.   containerGroup add_instances Adds container instances to the group.   containerGroup operating_system Sets the OS type (default Linux).   containerGroup restart_policy Sets the restart policy (default Always)   containerGroup public_dns Sets the DNS host label when using a public IP.   containerGroup private_ip Indicates the container should use a system-assigned private IP address for use in a virtual network.   containerGroup network_profile Name of a network profile resource for the subnet in a virtual network where the container group will attach.   containerGroup add_identity Adds a managed identity to the the container group.   containerGroup system_identity Activates the system identity of the container group.   containerGroup add_registry_credentials Adds a container image registry credential with a secure parameter for the password.   containerGroup add_tcp_port Adds a TCP port to be externally accessible.   containerGroup add_udp_port Adds a UDP port to be externally accessible.   containerGroup add_volumes Adds volumes to a container group so they are accessible to containers.    Example open Farmer open Farmer.Builders open Farmer.ContainerGroup let nginx = containerInstance { name \u0026#34;nginx\u0026#34; image \u0026#34;nginx:1.17.6-alpine\u0026#34; add_ports PublicPort [ 80us; 443us ] add_ports InternalPort [ 9090us; ] memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 1 env_vars [ env_var \u0026#34;CONTENT_PATH\u0026#34; \u0026#34;/www\u0026#34; secure_env_var \u0026#34;SECRET_PASSWORD\u0026#34; \u0026#34;shhhhhh!\u0026#34; ] add_volume_mount \u0026#34;secret-files\u0026#34; \u0026#34;/config/secrets\u0026#34; add_volume_mount \u0026#34;source-code\u0026#34; \u0026#34;/src/farmer\u0026#34; } let containerGroupUser = userAssignedIdentity { name \u0026#34;aciUser\u0026#34; } let group = containerGroup { name \u0026#34;webApp\u0026#34; operating_system Linux restart_policy AlwaysRestart add_identity containerGroupUser add_udp_port 123us add_instances [ nginx ] add_registry_credentials [ registry \u0026#34;mygregistry.azurecr.io\u0026#34; \u0026#34;registryuser\u0026#34; ] add_volumes [ volume_mount.secret_string \u0026#34;secret-files\u0026#34; \u0026#34;secret1\u0026#34; \u0026#34;abcdefg\u0026#34; volume_mount.git_repo \u0026#34;source-code\u0026#34; (Uri \u0026#34;https://github.com/CompositionalIT/farmer\u0026#34;) ] } Private Virtual Network Example Attaching a container group to a virtual network requires adding a service delegation on a subnet indicating it is for container groups, adding a network profile to bind the container group interface to that subnet, and finally adding the container group itself with a private IP address.\nopen Farmer open Farmer.Builders let privateNetwork = vnet { name \u0026#34;private-vnet\u0026#34; add_address_spaces [ \u0026#34;10.30.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;ContainerSubnet\u0026#34; prefix \u0026#34;10.30.19.0/24\u0026#34; add_delegations [ SubnetDelegationService.ContainerGroups ] } ] } let aciProfile = networkProfile { name \u0026#34;vnet-aci-profile\u0026#34; vnet \u0026#34;private-vnet\u0026#34; subnet \u0026#34;ContainerSubnet\u0026#34; } let myContainer = container { name \u0026#34;helloworld\u0026#34; image \u0026#34;microsoft/aci-helloworld\u0026#34; add_ports PublicPort [ 80us ] } let group = containerGroup { name \u0026#34;webApp\u0026#34; operating_system Linux restart_policy AlwaysRestart add_instances [ myContainer ] network_profile \u0026#34;vnet-aci-profile\u0026#34; private_ip [TCP, 80us] } Execute container command example Modified from azure-cli example here: https://docs.microsoft.com/en-us/azure/container-instances/container-instances-start-command\nopen Farmer open Farmer.Builders open Farmer.ContainerGroup let wordcount = containerInstance { name \u0026#34;mycontainer1\u0026#34; image \u0026#34;mcr.microsoft.com/azuredocs/aci-wordcount:latest\u0026#34; memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 1 env_vars [ env_var \u0026#34;NumWords\u0026#34; \u0026#34;3\u0026#34; env_var \u0026#34;MinLength\u0026#34; \u0026#34;5\u0026#34; ] command_line [ \u0026#34;python\u0026#34;; \u0026#34;wordcount.py\u0026#34;; \u0026#34;http://shakespeare.mit.edu/romeo_juliet/full.html\u0026#34; ] } let group = containerGroup { name \u0026#34;wordcount\u0026#34; operating_system Linux restart_policy RestartOnFailure add_instances [ wordcount ] } "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/5-unit-testing/","title":"5. Unit Testing","tags":[],"description":"","content":"Usually I would be pro writing the tests before you implement all this but it is important to get a feel for the moving parts. At this point you may want to write some tests so you can iterate quickly on getting the structure of your ARM template correct.\nThe tests you will find in the project are black-box style tests that focus on the input of a resource and the output of the ARM template. If you want to create tests for your mapping functions that is fine but remember between the strong type system and making it difficult to have null values, those kind of tests seldom yield much benefit in F#.\nOf course, unit tests can only tell you so much when dealing with something as complex as Azure. Create a fsx file to run to check that your resource is deploying as expected.\n// container-registry.fsx #r \u0026#34;Newtonsoft.Json.dll\u0026#34; #r @\u0026#34;../Farmer/bin/Debug/netstandard2.0/Farmer.dll\u0026#34; open Farmer open Farmer.Resources.ContainerRegistry let myRegistry = containerRegistry { name \u0026#34;devonRegistry\u0026#34; sku ContainerRegistrySku.Basic enable_admin_user } let deployment = arm { location NorthEurope add_resource myRegistry output \u0026#34;registry\u0026#34; myRegistry.Name output \u0026#34;loginServer\u0026#34; myRegistry.LoginServer } deployment |\u0026gt; Deploy.execute \u0026#34;FarmerTest\u0026#34; Deploy.NoParameters |\u0026gt; printfn \u0026#34;%A\u0026#34; Create a Resource Group to run it, here I called it \u0026ldquo;FarmerTest\u0026rdquo;.\nRun dotnet fsi container-registry.fsx\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/create-pull-requests/","title":"Creating Pull Requests","tags":[],"description":"","content":" This article is not a detailed guide on how to create a pull request (PR). See here to learn more about how to work with pull requests on GitHub.\n The purpose of this article is to illustrate the main checklists you must go through before a PR will be considered for inclusion in Farmer. If you are new to Farmer, F# or GitHub - don\u0026rsquo;t worry. The team will be happy to support you getting your feature over the line.\nThese are the following checks we\u0026rsquo;ll normally put in place:\n1. Create an issue first! Except for small pull requests, create an issue to discuss the feature. The last thing we want is for someone to spend hours of their time on a feature only for someone else to have started work on something similar, or for the admins of the project to reject it for whatever reason e.g. does not fit with the project etc. Creating an issue does not take long and will help save time for everyone.\n2. Create Documentation Every PR to Farmer must have some documentation with it. If you modify a resource and add a new keyword, it must be added to the appropriate docs page.\n3. Write Unit Tests Every PR to Farmer should have at least one test associated with it. If no tests are added, you can expect at least a request for one or explanation as to why one is not necessary.\n4. Write Release Notes Every PR to Farmer must include an entry to the RELEASE_NOTES.md file under the next release. Briefly explain the feature and ideally link to the PR number e.g.\n5. Adhere to Coding Standards Here are some (very basic!) standards for the project:\n Follow the coding style of the existing source. Use 4 spaces for indentation. As a last resort, adhere to official style guide as a basis.  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-registry/","title":"Container Registry","tags":[],"description":"","content":"Overview The Container Registry builder is used to create Azure Container Registry (ACR) instances.\n Container Registry (Microsoft.ContainerRegistry/registries)  Builder Keywords    Keyword Purpose     name Sets the name of the Container Registry instance.   sku Sets the SKU of the instance. Defaults to Basic.   enable_admin_user The value that indicates whether the admin user is enabled.    Example open Farmer open Farmer.Builders let myRegistry = containerRegistry { name \u0026#34;myRegistry\u0026#34; sku ContainerRegistry.Basic enable_admin_user } "},{"uri":"https://compositionalit.github.io/farmer/deployment-guidance/","title":"Deployment Guidance","tags":[],"description":"","content":"You can deploy Farmer templates in a number of ways, depending on how you would prefer to work with ARM templates and tooling.\nOption 1: \u0026ldquo;ARM templates are just a means to an end to me\u0026rdquo; If you don\u0026rsquo;t use ARM templates today, or don\u0026rsquo;t need to edit them directly, you can opt to do away with them completely. You\u0026rsquo;ll create Farmer applications which use a simple F# SDK to interact with Azure; Farmer will create ARM templates in the background for you transparently, so you\u0026rsquo;ll never see or interact with them.\nIn such a case, you can opt to deploy directly through Farmer. This mode provides an F# wrapper around the Azure CLI which captures your credentials during the deployment process.\nIf you\u0026rsquo;re looking to stay within F# and e.g. respond to outcomes from the deployment such as using deployment outputs, this is an excellent option because Farmer is just a dotnet application and the deployment call is a simple function call.\nAnother benefit of this is because Farmer is a simple .NET Standard library, you can use it natively within .NET build tools such as FAKE or CAKE.\nCombined Resource and Application Deployment Farmer can also optionally do more for you by handling the entire deployment process, including deployment of your application artifacts.\ngraph LR subgraph Azure Resource Group D(Azure App Service) end subgraph JSON C(ARM Template) -- REST API or Azure CLI -- D end subgraph .NET A(Farmer)-- resources emitted to -- C A -. your application deployed via ZIP Deploy.- D end  Watch this short video to see more!\n  Option 2: \u0026ldquo;I already have an ARM deployment strategy\u0026rdquo; If you already use ARM templates, you\u0026rsquo;ll probably already have a strategy for working with templates and deploying them to Azure, such as PowerShell, the Azure CLI or a build system such as Azure DevOps or Octopus Deploy. In such a case, you may want to use Farmer to generate, but not deploy, your ARM templates.\nOption 3: \u0026ldquo;I want to hand-craft my ARM templates\u0026rdquo; If you want to retain fine-grained control over ARM templates, you can use Farmer to create a one-off task to rapidly generate an ARM template which you then take ownership of. In this case, Farmer itself won\u0026rsquo;t be a part of your build / deploy chain, which will remain the same as today - you\u0026rsquo;ll use Farmer just as an edit-time task to create an ARM template itself which you will then manually modify.\nThe choice is yours.\nHow do I create a Service Principal? If you\u0026rsquo;re trying to deploy to Azure in an automated fashion, you may need to create a Service Principal account that has permissions in Azure to deploy ARM templates on your behalf.\nThe Azure CLI provides a simple way to create one using the az ad sp command:\naz ad sp create-for-rbac --name farmer-deploy This will provide output similar to the following:\n{ \u0026#34;appId\u0026#34;: \u0026#34;1181c21b-78f3-42b3-a26d-03ba75c7b674\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;farmer-deploy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;http://farmer-deploy\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;4aa3b120-f2b2-4ea9-941b-5891fef0ef11\u0026#34;, \u0026#34;tenant\u0026#34;: \u0026#34;aa7f7453-15af-4ab0-5d41-aeb4a25293bc\u0026#34; } The mapping from these fields to the credentials used in Farmer\u0026rsquo;s authenticate function are:\n   Azure CLI Farmer     appId appId   password secret   tenant tenantId    You should store these credentials in a secure store, such as your CI/CD service or e.g. Azure KeyVault and should avoid committing them into source control.\n"},{"uri":"https://compositionalit.github.io/farmer/support/","title":"Commercial Support","tags":[],"description":"","content":"The creators of Farmer, Compositional IT, offer a professional fully managed support package which we strongly recommend for any organisations using Farmer on a commercial basis. It includes:\n Prioritised resolution of any bugs. If you find a bug that\u0026rsquo;s blocking you, we\u0026rsquo;ll prioritise it and release a hot fix as soon as it\u0026rsquo;s ready. Prioritised resolution and escalation of issues. If there\u0026rsquo;s a possible issue or question, we\u0026rsquo;ll prioritise dealing with it. Prioritised feature requests: Get new features that are important to you added first. Personalised support and guidance via email, telephone or video. Speak to one of our team for advice and best practices on how to best manage deployments. Discounts on our F# and Azure training and coaching services  Please contact us to find out more! "},{"uri":"https://compositionalit.github.io/farmer/testimonials/","title":"Testimonials","tags":[],"description":"","content":"Please submit a pull request here with details of your success stories of using Farmer!  \u0026ldquo;We\u0026rsquo;ve been using Farmer to help rapidly onboard our customers onto Azure with repeatable processes, particularly with the SAFE Stack. It\u0026rsquo;s helping our team adopt best practices without passing on expense to our customers.\u0026rdquo;\nIsaac Abraham, Director, Compositional IT\n  \u0026ldquo;Farmer quickly became an essential tool for Continuous Deployment at our F# projects. Clean DSL, great documentation, growing support of various Azure services and PR-friendly approach made Farmer to be one of the best open source projects in these days.\u0026rdquo;\nRoman Provaznk, F# Lead Developer, CN Group\n  \u0026ldquo;Holy moly, this was a breeze!! I\u0026rsquo;m SO going to use this more often, even if it\u0026rsquo;s just to get a baseline for a customer. Saves tons of time!\nJan De Vries, Microsoft MVP\n  \u0026ldquo;Hey @isaac_abraham, #Farmer is kind of awesome. A few lines and my fav env is created. #ILike\u0026rdquo;\nJan(ek) Fellien, Microsoft MVP\n  \u0026ldquo;Finally took a look at farmer just now\u0026hellip;. I should have looked months ago. I mean, I can actually read a farmer template. And it makes sense?!\u0026rdquo; Arjen Smits\n "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cosmos-db/","title":"Cosmos DB","tags":[],"description":"","content":"Overview The CosmosDb package containers two builders, used to create databases and containers.\n CosmosDB Account (Microsoft.DocumentDb/databaseAccounts) CosmosDB SQL (\u0026quot;Microsoft.DocumentDB/databaseAccounts/sqlDatabases) CosmosDB SQL Container (Microsoft.DocumentDb/databaseAccounts/sqlDatabases/containers)   There is currently only support for document databases (the so-called \u0026ldquo;SQL API\u0026rdquo;), with support for Gremlin, Table and Cassandra data models planned.\n Cosmos DB Builder The CosmosDB builder abstracts the idea of account and database into one. If you wish to \u0026ldquo;re-use\u0026rdquo; an already-created Cosmos DB account, use link_to_account keyword - no account will be created and the database will be attached to the existing one.\n   Applies To Keyword Purpose     Database name Sets the name of the database.   Database link_to_account Instructs Farmer to link this database to an existing Cosmos DB account rather than creating a new one.   Database throughput Sets the throughput of the account.   Database add_containers Adds a list of containers to the database.   Account account_name Sets the name of the CosmosDB account.   Account api (not yet implemented) Sets the API and data model to use \u0026ndash; currently defaults to \u0026ldquo;Core (SQL)\u0026quot;.   Account enable_public_network_access Enables public network access for the account.   Account disable_public_network_access Disables public network access for the account.   Account consistency_policy Sets the consistency policy of the database.   Account failover_policy Sets the failover policy of the database.   Account free_tier Registers this server with the free pricing tier, if supported and allowed by Azure.    Cosmos Container Builder The container builder allows you to create and configure a specific container that is attached to a cosmos database.\n   Keyword Purpose     name Sets the name of the container.   partition_key Sets the partition key of the container.   add_index Adds an index to the container.   exclude_path Excludes a path from the container index.    Example open Farmer open Farmer.Builders let myCosmosDb = cosmosDb { name \u0026#34;isaacsappdb\u0026#34; account_name \u0026#34;isaacscosmosdb\u0026#34; throughput 400\u0026lt;CosmosDb.RU\u0026gt; failover_policy CosmosDb.NoFailover consistency_policy (CosmosDb.BoundedStaleness(500, 1000)) add_containers [ cosmosContainer { name \u0026#34;myContainer\u0026#34; partition_key [ \u0026#34;/id\u0026#34; ] CosmosDb.Hash add_index \u0026#34;/path\u0026#34; [ CosmosDb.Number, CosmosDb.Hash ] exclude_path \u0026#34;/excluded/*\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/links/","title":"Links","tags":[],"description":"","content":"In this page, you can find blog posts, videos and tweets on Farmer that will give you a better sense of the scenery and the dialogue around it.\nBlog Posts  Compositional IT articles on Farmer Azure SQL Database deployment with Farmer, DbUp and GitHub Actions Introduction to Farmer - IaC with Azure Farmer: Simpler ARM deployments with Octopus Deploy  Videos  Learn how to deploy complete .NET Web Apps to Azure in less than 5 minutes! Working with raw JSON ARM resources with Farmer Authoring ARM templates the easy way with Farmer Making Infrastructure as Code Easier in Azure Introduction to Farmer and Stepping up the game with ARM templates  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/dns/","title":"DNS Zone","tags":[],"description":"","content":"Overview The DNS Zone module contains two types of builders - dnsZone, used to create DNS Zones, and ___Record (like cnameRecord, aRecord, ..), used to create DNS Records sets. It supports most record types (except SOA, SRV and CAA) and has specific builders for every record type.\n DNS Zone (Microsoft.Network/dnsZones) A Record (Microsoft.Network/dnsZones/A) AAAA Record (Microsoft.Network/dnsZones/AAAA) CNAME Record (Microsoft.Network/dnsZones/CNAME) TXT Record (Microsoft.Network/dnsZones/TXT) MX Record (Microsoft.Network/dnsZones/MX) NS Record (Microsoft.Network/dnsZones/NS) PTR Record (Microsoft.Network/dnsZones/PTR)  TODO The following items are currently unsupported:\n SOA records SRV records CAA records Private Zone (untested) Virtual network support for Private Zones Tags  DNS Zone Builder Keywords    Keyword Purpose     name Sets the name of the domain.   zone_type Sets the zone type.   add_records Adds DNS Zone records (see below).    Each Record type has its own custom builder. All builders share the following common keywords:\n   Keyword Purpose     name Sets the name of the record set (default to @).   ttl Sets the time-to-live of the record set.    In addition, each record builder has its own custom keywords:\nA Record Builder Keywords    Keyword Purpose     add_ipv4_addresses Add IPv4 addresses to this record set.   target_resource A reference to an azure resource from where the dns resource value is taken.    AAAA Record Builder Keywords    Keyword Purpose     add_ipv6_addresses Add IPv6 addresses to this record set.   target_resource A reference to an azure resource from where the dns resource value is taken.    CNAME Record Builder Keywords    Keyword Purpose     cname Sets the canonical name for this CNAME record.   target_resource A reference to an azure resource from where the dns resource value is taken.    TXT Record Builder Keywords    Keyword Purpose     add_values Add TXT values to this record set.    MX Record Builder Keywords    Keyword Purpose     add_values Add MX values to the record set.    NS Record Builder Keywords    Keyword Purpose     add_nsd_names Add NS values to this record set.    PTR Record Builder Keywords    Keyword Purpose     add_ptrd_names Add PTR names to this record set.    Example #r @\u0026#34;./libs/Newtonsoft.Json.dll\u0026#34; #r @\u0026#34;../../src/Farmer/bin/Debug/netstandard2.0/Farmer.dll\u0026#34; open Farmer open Farmer.Builders let dns = dnsZone { name \u0026#34;farmer.com\u0026#34; zone_type Dns.Public add_records [ cnameRecord { name \u0026#34;www2\u0026#34; ttl 3600 cname \u0026#34;farmer.github.com\u0026#34; } aRecord { ttl 7200 add_ipv4_addresses [ \u0026#34;192.168.0.1\u0026#34;; \u0026#34;192.168.0.2\u0026#34; ] } aaaaRecord { ttl 7200 add_ipv6_addresses [ \u0026#34;100:100:100:100\u0026#34; ] } txtRecord { ttl 3600 add_values [ \u0026#34;v=spf1 include:spf.protection.outlook.com -all\u0026#34; ] } mxRecord { ttl 7200 add_values [ 0, \u0026#34;farmer-com.mail.protection.outlook.com\u0026#34;; 1, \u0026#34;farmer2-com.mail.protection.outlook.com\u0026#34;; ] } ] } let deployment = arm { location Location.NorthEurope add_resource dns } deployment |\u0026gt; Writer.quickWrite \u0026#34;dns-example\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/contributing/","title":"Contributing","tags":[],"description":"","content":"Thanks for thinking about contributing! Azure is a giant beast and help supporting more use-cases is always appreciated. To make it easier to contribute, we put together this little guide. Please take a few minutes to read through before starting work on a pull request (PR) to Farmer.\nThe process (don\u0026rsquo;t worry\u0026hellip; this is not waterfall)  Open an issue, or comment on an existing open issue covering the resource you would like to work on. Basically, a PR from you should not come as a surprise. Implement the 20% of features that cover 80% of the use cases. PR against the master branch from your fork. Add/update tests as required. Create a new *.md file with the name of your resource in the folder /content/api-overview/resources/. Eg. container-registry.md Add a description, keywords, and an example to the docs page. PRs need to pass build/test against both Linux \u0026amp; Windows build, and a review, before being merged in.  TODO There\u0026rsquo;s still more to document!\n Validation best practices Multiple resource builders Linking resources (one-to-many relationships) Post-deploy tasks  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/data-lake/","title":"Data Lake","tags":[],"description":"","content":"Overview The Data Lake builder is used to create Azure Data Lake instances.\n Data Lake (Microsoft.DataLakeStore/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Cognitive Services instance.   sku Sets the SKU of the instance. Defaults to Consumption.   enable_encryption Turns on data lake encryption.    Example open Farmer open Farmer.Builders let myLake = dataLake { name \u0026#34;myDataLake\u0026#34; sku DataLake.Commitment_100TB enable_encryption } "},{"uri":"https://compositionalit.github.io/farmer/faq/","title":"FAQs","tags":[],"description":"","content":"How can I help? Try out Farmer and see what you think.\n Create as many issues as you can for both bugs, discussions and features Create suggestions for features and the most important elements you would like to see added  I have an Azure subscription, but I\u0026rsquo;m not an expert. I like the look of this - how do I \u0026ldquo;use\u0026rdquo; it?  Create an ARM template using the Farmer sample app. Follow the steps here to deploy the generated template into Azure. Log any issues or ideas that you find here.  How do I get Farmer to work from a continuous deployment (CD) process?  Look at some of the alternative strategies outlined here. Read up on ARM deployment strategies e.g. Azure Devops have guides here.  The Farmer .NET Template also has support for creating a Azure Devops-ready application from scratch.\nI don\u0026rsquo;t know F#. Would you consider writing a C# version of this? I\u0026rsquo;m afraid not. F# isn\u0026rsquo;t hard to learn (especially for simple DSLs such as this), and you can easily integrate F# applications as part of a dotnet solution, since F# is a first-class citizen of the dotnet core ecosystem. You can even create new resources in C# since the core abstractions of Farmer are two simple .NET interfaces.\nAre you trying to replace ARM templates? No, we\u0026rsquo;re not. Farmer generates ARM templates that can be used just as normal; Farmer can also be used simplify to make the process of getting started much simpler, or incorporated into your build pipeline as a way to avoid managing difficult-to-manage ARM templates and instead use them as the final part of your build / release pipeline.\nAre you trying to compete with Pulumi? No, we\u0026rsquo;re not. Farmer has (at least currently) a specific goal in mind, which is to lower the barrier to entry for creating and working with ARM templates. We\u0026rsquo;re not looking to create a cross-platform DSL to also support things like Terraform etc. or provide a stateful service store that Pulumi offers. Instead, Farmer is a simple way to continue to use ARM templates today but benefit from a more rapid authoring and maintenance process.\nThere\u0026rsquo;s no support for variables or parameters! Farmer intentionally has limited support for ARM parameters and variables. Read here to find out the alternatives.\nCan I add resources that are not supported by Farmer? Yes. You can use some adapters that Farmer provides to generate resources using basic .NET objects, or even paste ARM template JSON directly into Farmer and have that embedded inside. See the following links from the Contributing section:\n Using raw JSON with Resource.ofJSON Using anonymous records or objects with Resource.ofObj Using the IArmResource interface.  The resource I need isn\u0026rsquo;t included! Create an issue on our github repository, ideally with a sample ARM template and a link to the official Microsoft documentation on the resource. We can\u0026rsquo;t promise we\u0026rsquo;ll look at it immediately, but raising the issue is an important first step to getting more resources supported.\nBut our organisation really needs that resource enhancement today! Drop us an email explaining what you need; we\u0026rsquo;re happy to discuss a commercial support arrangement to provide you with features that you need in a more timely fashion.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/event-grid/","title":"Event Grid","tags":[],"description":"","content":"Overview The Event Grid is a simple but powerful builder that links events from Azure services such as Storage and App Service to one or many subscribers which can consume the events. The event grid builder supports a degree of type safety - all system events are provided from a strongly-typed list, and events are directly linked to specific builders - so, for example, you cannot accidentally subscribe to Storage Account events if the event publisher is a Web App. It supports the following ARM resources.\n Topics (Microsoft.EventGrid/systemTopics) Subscriptions (Microsoft.EventGrid/systemTopics/eventSubscriptions)  Builder Keywords    Keyword Purpose     topic_name The name of the topic that will be created.   source The source of the events. See below for the full list of builder configurations that are supported.   add_queue_subscriber Adds a new storage queue subscriber. Requires the storage account config that will receive the events, the queue name and the list of events to subscribe to.   add_webhook_subscriber Adds a new web hook (HTTP) subscriber. Requires the web app config that will receive the event, associated URI local path and the list of events to subscribe to. Also contains an overload that takes in a Web App name and the full Uri of the web hook.   add_eventhub_subscriber Adds a new event hub subscriber. Requiresthe event hub builder config that will receive the events and the list of events to subscribe to.    Supported Sources Farmer supports the following Event Grid sources using Farmer builders:\n   Builder Events namespace      StorageAccount SystemEvents.Storage    WebApp SystemEvents.AppServer    KeyVault SystemEvents.KeyVault    SignalR SystemEvents.SignalR    Maps SystemEvents.Maps    ContainerRegistry SystemEvents.ContainerRegistry    ServiceBus SystemEvents.ServiceBus    IotHub SystemEvents.IotHub    EventHub SystemEvents.EventHub     Example The following sample creates a source storage account that emits events on the event grid topic, whilst two destinations are created: an event hub and a storage queue, each listening for different events.\nopen Farmer open Farmer.Builders let queueName = \u0026#34;events\u0026#34; let storageSource = storageAccount { name \u0026#34;isaacstorageacc\u0026#34;; add_private_container \u0026#34;data\u0026#34; } let destionationHub = eventHub { name \u0026#34;isaachub\u0026#34;; namespace_name \u0026#34;isaacns\u0026#34; } let destinationStorage = storageAccount { name \u0026#34;destinationstorage\u0026#34;; add_queue queueName; add_private_container \u0026#34;events\u0026#34; } let eventHubGrid = eventGrid { topic_name \u0026#34;isaacHubTopic\u0026#34; source storageSource add_eventhub_subscriber destionationHub [ SystemEvents.Storage.BlobCreated; SystemEvents.Storage.BlobDeleted ] add_queue_subscriber destinationStorage queueName [ SystemEvents.Storage.BlobCreated ] } let template = arm { add_resources [ storageSource eventHubGrid destinationStorage destionationHub ] } "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/","title":"Adding A Resource","tags":[],"description":"","content":"This set of guided exercises shows the different steps required to create new ARM resources in Farmer. We\u0026rsquo;ll create a basic resource that can hook into the Farmer pipeline, by adding support to Farmer for the ContainerRegistry Azure resource. This will involve:\n Defining an type that implements IArmResource that maps directly to the ARM template output. Defining any domain types required to capture details on the resource. Defining a type that implements IBuilder and an associated computation expression that will be easier for users to consume than an F# record.  This will end up allowing us to define a resource that looks like this:\nlet myRegistry = containerRegistry { name \u0026#34;devonRegistry\u0026#34; sku ContainerRegistrySku.Basic enable_admin_user } let deployment = arm { location NorthEurope add_resource myRegistry } which generates JSON looking something like this:\n{ \u0026#34;name\u0026#34;: \u0026#34;devonRegistry\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;northeurope\u0026#34;, \u0026#34;tags\u0026#34;: {}, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Basic\u0026#34; }, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: true, }, \u0026#34;resources\u0026#34;: [] } Useful terminology  Resource: A resource is a single Azure service provided by ARM; in Farmer these resource models are created by implementing the IArmResource interface. Template: Represents an ARM template with parameters, outputs and zero, one or many resources. Location: An Azure Region where a service exists. Deployment: Represents the deployment of an ARM template to a specific Location and Resource Group name. Builder: In Farmer, an IBuilder represents provides the capability of creating a smart type that helps model a resource or a collection of resources into associated IArmResource objects required for constructing the ARM template. For example, Farmer\u0026rsquo;s WebApp builder provides a logical abstraction on top of several ARM resources: Web App, Server Farm and Application Insights.  Requirements  Minimum version is 2.5.0 of Azure CLI Azure account to test against  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/event-hub/","title":"Event Hub","tags":[],"description":"","content":"Overview The Event Hub builder creates event hub namespaces, event hubs, consumer groups and authorization rules in a single builder.\n Event Hub Namespace (Microsoft.EventHub/namespaces) Event Hub (Microsoft.EventHub/namespaces/eventhubs) Consumer Group (Microsoft.EventHub/namespaces/eventhubs/consumergroups) Authorization Rule (Microsoft.EventHub/namespaces/eventhubs/AuthorizationRules\u0026quot;)   The Event Hub builder works in a similar fashion to the web app builder in that it automatically creates the host (in this case, the event hub namespace) when creating the event hub. If you wish to create multiple hubs in the same namespace, configure the namespace-level properties in the first event hub; subsequent event hubs should link to the namespace of the hub created by the first hub.\n Builder Keywords    Applies To Keyword Purpose     Namespace namespace_name Sets the name of the event hub namespace, if you are creating the namespace along with the hub.   Namespace sku Sets the SKU of the event hub namespace.   Namespace capacity Sets the capacity of the event hub namespace (see here for more details)   Namespace enable_zone_redundant Enables zone redundancy on the event hub namespace.   Namespace enable_auto_inflate Enables auto inflate throughput; you must supply the maximum throughput level.   Namespace disable_auto_inflate Disables auto inflate throughput.   Event Hub name Sets the name of the event hub.   Event Hub message_retention_days Sets the number of days to retain messages for on the event hub.   Event Hub partitions Sets the number of partitions on the event hub.   Event Hub add_consumer_group Creates a consumer group for the event hub.   Event Hub add_authorization_rule Adds a named authorization rule on the event hub.   Event Hub link_to_namespace Sets the name of an existing or already-defined event hub namespace that this event hub should link to.   Event Hub capture_to_storage Activates Event Hub data capture to a Storage Account. Takes in a storage account or resource name, and the container to write events to.    Configuration Members    Member Purpose     DefaultKey Gets an ARM expression for the root namespace key of the Event Hub namespace.   GetKey Gets an ARM expression for a named key on this event hub.    Example open Farmer open Farmer.Builders let storage = storageAccount { name \u0026#34;isaacssuperstorage\u0026#34; } let primaryHub = eventHub { namespace_name \u0026#34;allmyevents\u0026#34; sku EventHub.Standard enable_zone_redundant enable_auto_inflate 3 add_authorization_rule \u0026#34;FirstRule\u0026#34; [ EventHub.Listen; EventHub.Send ] add_authorization_rule \u0026#34;SecondRule\u0026#34; AllAuthorizationRights name \u0026#34;first-hub\u0026#34; partitions 2 message_retention_days 3 add_consumer_group \u0026#34;myGroup\u0026#34; } let secondHub = eventHub { name \u0026#34;second-hub\u0026#34; link_to_namespace \u0026#34;allmyevents\u0026#34; partitions 1 message_retention_days 1 capture_to_storage myStorageAccount \u0026#34;mycontainer\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/","title":"Resources","tags":[],"description":"","content":"Resources Farmer currently has support for the most popular resources in Azure, such as Storage, App Service and Functions. You can find out more about each resource in detail in the menu.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/express-route/","title":"ExpressRoute","tags":[],"description":"","content":"Overview An ExpressRoute circuit is a dedicated link to Azure to provide communication with Azure services without traversing the Internet. It requires some coordination with a networking provider for these circuits, so some information, such as the service provider and peering location must be obtained from Azure reference documentation. The ExpressRoute builder creates an ExpressRoute circuit and enables Azure private peering and Microsoft peering.\n ExpressRoute Namespace (Microsoft.Network/expressRouteCircuits)  Builder Keywords    Applies To Keyword Purpose     ExpressRoute service_provider Connectivity service provider from Azure reference documentation   ExpressRoute peering_location Connectivity peering location from Azure reference documentation   ExpressRoute tier Standard or Premium   ExpressRoute family Metered or Unlimited data   ExpressRoute bandwidth Bandwidth in Mbps for the circuit   ExpressRoute add_peering Peering details for the circuit - can add Azure Private and Microsoft peerings   Peering peering_type A network CIDR block of 4 IP addresses (/30) for the ExpressRoute primary circuit   Peering peer_asn Peer Autonomous System Number - this is a uniquely assigned number for the peer network, typically provided by the service provider in agreement with Microsoft   Peering azure_asn Azure Autonomous System Number - Microsoft oftent uses AS 12076 for Azure public, Azure private and Microsoft peering   Peering primary_prefix A network CIDR block of 4 IP addresses (/30) for the ExpressRoute primary circuit   Peering secondary_prefix A network CIDR block of 4 IP addresses (/30) for the ExpressRoute secondary circuit   Peering vlan A unique VLAN ID for the peering   Peering shared_key An optional shared key the service provider may specify for the peering    Example open Farmer open Farmer.Builders open Farmer.ExpressRoute let circuit = expressRoute { name \u0026#34;my-express-route\u0026#34; service_provider \u0026#34;Equinix\u0026#34; peering_location \u0026#34;New York\u0026#34; tier Premium family MeteredData bandwidth 1000\u0026lt;Mbps\u0026gt; add_peering ( peering { peering_type AzurePrivatePeering peer_asn 55277L azure_asn 12076 primary_prefix (IPAddressCidr.parse \u0026#34;10.254.12.0/30\u0026#34;) secondary_prefix (IPAddressCidr.parse \u0026#34;10.254.12.4/30\u0026#34;) vlan 2406 } ) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/functions/","title":"Functions","tags":[],"description":"","content":"Overview The Functions builder is used to create Azure Functions accounts. It abstracts the App Host and Service Plan into the same component, and will also create and configure a linked App Insights resource. In addition, it will automatically create a backing storage account required by the functions runtime.\n Web Site (Microsoft.Web/sites) Web Host (Microsoft.Web/serverfarms) Application Insights (Microsoft.Insights/components) Storage Accounts (Microsoft.Storage/storageAccounts)  Builder Keywords    Keyword Purpose     name Sets the name of the functions instance.   service_plan_name Sets the name of the service plan hosting the function instance.   link_to_service_plan Instructs Farmer to link this webapp to an existing service plan rather than creating a new one.   link_to_storage_account Do not create an automatic storage account; instead, link to a storage account that is created outside of this Functions instance.   https_only Disables http for this functions app so that only HTTPS is used.   app_insights_auto_name Sets the name of the automatically-created app insights instance.   app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   link_to_app_insights Instead of creating a new AI instance, configure this webapp to point to another AI instance that you are managing yourself.   use_runtime Sets the runtime of the Functions host.   use_extension_version Sets the extension version of the functions host.   operating_system Sets the operating system of the Functions host.   setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   settings Sets a list of app setting of the web app as tuples in the form of (\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;).   depends_on Sets dependencies for the web app.   enable_cors Enables CORS support for the app. Either specify AllOrigins or a list of valid URIs.   enable_cors_credentials Allows CORS requests with credentials.    Post-deployment Builder Keywords The Functions builder contains special commands that are executed after the ARM deployment is completed.\n   Keyword Purpose     zip_deploy Supplying a folder or zip file will instruct Farmer to upload the contents directly to the Azure Functions once the ARM deployment is complete.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this functions app.   StorageAccountKey Gets the ARM expression path to the storage account key of this functions app.   AppInsightsKey Gets the ARM expression path to the app insights key of this functions app, if it exists.   DefaultKey Gets the ARM expression path for the default key of this functions app.   MasterKey Gets the ARM expression path for the master key of this functions app.    Example open Farmer open Farmer.Builders let myFunctions = functions { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; app_insights_off } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/iot-hub/","title":"IOT Hub","tags":[],"description":"","content":"Overview The IOT Hub builder creates IOT Hub and linked Provision Services.\n IOT Hubs (Microsoft.Devices/IotHubs) Provisioning Services (Microsoft.Devices/provisioningServices)  Builder Keywords    Keyword Purpose     name Specifies the name of the IOT Hub   sku Sets the SKU of the IOT Hub   capacity Sets the name of the capacity for the IOT Hub instance   partition_count Sets the name of the SKU/Tier for the IOT Hub instance   retention_days Sets the name of the SKU/Tier for the IOT Hub instance   enable_device_provisioning Sets the name of the SKU/Tier for the IOT Hub instance    Configuration Members    Member Purpose     GetKey Returns an ARM expression to retrieve the IOT Hub key for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.   GetConnectionString Returns an ARM expression to generate an IOT Hub connection string for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let hub = iotHub { name \u0026#34;yourhubname\u0026#34; sku IotHub.B1 capacity 2 partition_count 2 retention_days 3 enable_device_provisioning } let deployment = arm { location Location.NorthEurope add_resource hub output \u0026#34;iot_key\u0026#34; (hub.GetKey IotHub.IotHubOwner) output \u0026#34;iot_connection\u0026#34; (hub.GetConnectionString IotHub.RegistryReadWrite) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/keyvault/","title":"Key Vault","tags":[],"description":"","content":"Overview The KeyVault package contains three builders, for the different components used by KeyVault: One for access policies, one for secrets, and one for the overall keyvault container.\n KeyVault (Microsoft.KeyVault/vaults) Secrets (Microsoft.KeyVault/vaults/secrets)  Secret Builder The secret builder allows you to store secrets into key vault. Values for a secret are passed by Secure String parameters.\n   Keyword Purpose     name Sets the name of the secret.   value Sets the name of the secure string parameter that will contain the value of the secret.   content_type Sets the content type of the secret.   enable_secret Enables the secret.   disable_secret Disables the secret.   activation_date Sets the activation date of the secret.   expiration_date Sets the expiration date of the secret.   depends_on Sets the dependencies of the key vault.   add_tag Adds a tag to the secret.   add_tags Adds multiple tags to the secret.    Access Policy Builder The Access Policy builder allows you to create access policies for key vault.\n   Keyword Purpose     object_id Sets the Object ID of the permission set.   application_id Sets the Application ID of the permission set.   key_permissions Sets the Key permissions of the permission set.   storage_permissions Sets the Storage permissions of the permission set.   secret_permissions Sets the Secret permissions of the permission set.   certificate_permissions Sets the Certificate permissions of the permission set.    Key Vault Builder The Key Vault builder contains access policies, secrets, and configuration information to create a full key vault account.\n   Keyword Purpose     name Sets the name of the vault.   sku Sets the sku of the vault.   tenant_id Sets the Tenant ID of the vault.   enable_vm_access Allows VM access to the vault.   disable_vm_access Disallows VM access to the vault.   enable_resource_manager_access Allows Resource Manager access to the vault.   disable_resource_manager_access Disallows Resource Manager access to the vault.   enable_disk_encryption_access Allows Azure Disk Encyption service access to the vault.   disable_disk_encryption_access Disallows Azure Disk Encyption service access to the vault.   enable_soft_delete Enables VM access to the vault.   enable_soft_delete_with_purge_protection Disables VM access to the vault.   uri Sets the URI of the vault.   enable_recovery_mode Sets the Creation Mode to Recovery.   disable_recovery_mode Sets the Creation Mode to Default.   add_access_policy Adds an access policy to the vault.   add_access_policies Adds access policies to the vault.   enable_azure_services_bypass Allows Azure traffic can bypass network rules.   disable_azure_services_bypass Disallows Azure traffic can bypass network rules.   allow_default_traffic Allow traffic if no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   deny_default_traffic Deny traffic when no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   add_ip_rule Adds an IP address rule. This can be an IPv4 address range in CIDR notation, such as \u0026lsquo;124.56.78.91\u0026rsquo; (simple IP address) or \u0026lsquo;124.56.78.0/24\u0026rsquo; (all addresses that start with 124.56.78).   add_vnet_rule Adds a virtual network rule. This is the full resource id of a vnet subnet, such as \u0026lsquo;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026rsquo;.   add_secret Adds a secret to the vault. This can either be a \u0026ldquo;full\u0026rdquo; secret config created using the Secret Builder, a string literal value which represents the parameter name, or a string literal with a resource and an expression based on that resource e.g. a storage account and the Key member.   add_secrets Adds multiple secrets to the vault. This can either be \u0026ldquo;full\u0026rdquo; secret configs created using the Secret Builder, string literal values which represents the parameter name.   add_tag Adds a tag to the key vault.   add_tags Adds multiple tags to the key vault.    Utilities  The KeyVault module comes with a set of utility functions to quickly create access policies if you do not wish to use the AccessPolicy builder, in the Farmer.KeyVault.AccessPolicy module which enable creating an access policy for a PrincipalId or an ObjectId which will have the GET Secret permission. In addition, the AccessPolicy module also contains helpers to search for users or groups in active directory (requires Azure CLI installed), as well as their Object IDs. These can be used to rapidly create Access Policies for specific users.  Example open Farmer open Farmer.Builders open System let policy = accessPolicy { object_id Guid.Empty application_id Guid.Empty certificate_permissions [ KeyVault.Certificate.List ] secret_permissions KeyVault.Secret.All key_permissions [ KeyVault.Key.List ] } let complexSecret = secret { name \u0026#34;myComplexSecret\u0026#34; content_type \u0026#34;application/text\u0026#34; enable_secret activation_date (DateTime.Today.AddDays -1.) expiration_date (DateTime.Today.AddDays 1.) } let vault = keyVault { name \u0026#34;MyVault\u0026#34; sku KeyVault.Sku.Standard tenant_id Guid.Empty enable_disk_encryption_access enable_resource_manager_access enable_soft_delete_with_purge_protection disable_vm_access enable_recovery_mode add_access_policy policy enable_azure_services_bypass add_ip_rule \u0026#34;127.0.0.1\u0026#34; add_vnet_rule \u0026#34;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026#34; allow_default_traffic add_secret complexSecret add_secret \u0026#34;simpleSecret\u0026#34; add_secrets [ \u0026#34;firstSecret\u0026#34;; \u0026#34;secondSecret\u0026#34;] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/loganalytics/","title":"Log Analytics","tags":[],"description":"","content":"Overview The Log Analytics builder is used to create Work space instances.\n Log Analytics (Microsoft.OperationalInsights/workspaces)  Builder Keywords    Keyword Purpose     name Sets the name of the log analytics instance.   retention_period Sets the retention period for logs in days.   enable_ingestion Enables ingestion network traffic.   enable_query Enables query network traffic.   daily_cap Specifies an upper limit on the amount of data to ingest daily.   add_tags Adds a set of tags to the resource   add_tag Adds a tag to the resource    Example open Farmer open Farmer.Builders let myAnalytics = logAnalytics { name \u0026#34;myloganalytics\u0026#34; retention_period 30\u0026lt;Days\u0026gt; enable_ingestion enable_query daily_cap 5\u0026lt;Gb\u0026gt; add_tag \u0026#34;tag1\u0026#34; \u0026#34;myTestResourceFarmer\u0026#34; } let deployment = arm { location Location.WestEurope add_resource myRegistry } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/managed-identity/","title":"Managed Identity","tags":[],"description":"","content":"Overview Managed Identity is used to create an identity that resources can run under automatically. This is similar to a service principal except that there is no credential to manage and the authorization token is retrieved through a secure internal handshake between the resource and the identity service in Azure.\n User Assigned Identity (Microsoft.ManagedIdentity/userAssignedIdentities)  Using a managed identity as opposed to e.g. connection strings brings several benefits:\n There is no client secret or certificate to configure and rotate because this is handled implicitly by Azure infrastructure. The identity is tied to one or more specific resources, so cannot be used by anything else, like a user. Many services allow more granular permissions than e.g. a connection string. You can grant and revoke access completely independently of the application attempting to gain access to the resource.  Once created, the managed identity resource can be referenced by other resources both in order to:\n Enable a resource to run as that identity Enable a resource to grant permissions to that identity  For example, you may wish to run a Virtual Machine or an Web App under a identity that you create, and then to grant permissions to that identity to allow reading from a storage account. You can define the permissions completely independently of the Virtual Machine or Web App.\ngraph LR A(identity) B(virtual machine)-. runs as .-A D(web app)-. runs as .-A C(storage account)-. grants permissions .-A A -. request made in this identiy .-C   See here and here for the official documentation on the Microsoft Azure docs website.\n Identity Types in Azure Identities come in two flavours in Azure: System and User assigned.\n System Identities are available whenever you create a resource, such as a VM. Each resource has its own system identity, and they cannot be shared across resources. User Identities are created by you; they exist idependently of any resources and thus can be shared across them. In Farmer, the userAssignedIdentity builder can be used for this. You also need to \u0026ldquo;link\u0026rdquo; a user identity to the resource that you wish to be able to \u0026ldquo;run as\u0026rdquo; it.   User Assigned Identities are themselves ARM resources and need to be added to your Farmer arm {} blocks!\n graph LR A(user assigned identity) subgraph Web App B(system identity) end C(storage account) C -.grants permissions .- A C -.grants permissions .- B  User Assigned Identity Builder The userAssignedIdentity builder constructs user assigned managed identities which can be created and then assigned to one or more resources.\n   Keyword Purpose     name Sets the name of the user assigned identity.   add_tag Adds a tag to the user assigned identity resource.   add_tags Adds multiple tags to the user assigned identity resource.    Helper Methods Because the User Assigned Identity builder is so simple, we also provide a simple builder function to create identities as an alternative to using the standard builder syntax:\nopen Farmer.Builders let uai = createUserAssignedIdentity \u0026#34;mytestidentity\u0026#34; Example: System Identity In this example, a web app needs a secret from a key vault. By using the system identity on the web app, application code can be granted access to the key vault with no need to provide it a client secret.\nopen Farmer open Farmer.Builders let wa = webApp { name \u0026#34;myApp\u0026#34; system_identity // turn on the system identity of the web app } let vault = keyVault { name \u0026#34;my-vault\u0026#34; add_access_policies [ // grant access to the web app\u0026#39;s system identity to key vault.  // by default GET and LIST permissions are granted.  AccessPolicy.create wa.SystemIdentity ] } let template = arm { add_resources [ wa; vault ] } There is no need to add a specific identity resource to Farmer in this case because the System Identity is created along with the web app itself.\nExample: User Assigned Identity In this example, a web app needs access to a Storage Account with a specific role. By assigning an identity to the web app, the application code can be granted access to the storage account; we also provide the Client Id to the application as a public setting in order for the application to correctly impersonate as the identity within code.\nBy creating a user assigned identity, unlike a system identity, we can also apply this identity onto other resources so that they, too, can \u0026ldquo;share\u0026rdquo; the permissions and identity. In this example, we also apply the identity onto a container group.\n// Create a user assigned identity let sharedIdentity = userAssignedIdentity { name \u0026#34;container-group-identity\u0026#34; } // Apply it onto the web app let myWeb = webApp { name \u0026#34;myApp\u0026#34; // Add the identity to the web app  add_identity sharedIdentity // Provide the client id to the app for use in code  setting \u0026#34;ClientId\u0026#34; sharedIdentity.ClientId } let group = containerGroup { name \u0026#34;myapp-with-identity\u0026#34; add_instances [ containerInstance { name \u0026#34;my-app\u0026#34; image \u0026#34;myregistry.azurecr.io/myapp:latest\u0026#34; } ] // Also apply it here. All of the containers in this group share this managed identity.  add_identity sharedIdentity } let data = storageAccount { name \u0026#34;dataidentity\u0026#34; // Allow the shared identity blob data reader access to storage.  grant_access sharedIdentity Roles.StorageBlobDataReader } let deployment = arm { add_resources [ sharedIdentity myWeb group data ] } In this example, notice that we explicitly add the sharedIdentity resource to the arm {} block.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/maps/","title":"Maps","tags":[],"description":"","content":"Overview The Maps builder creates Azure Maps accounts.\n Maps (Microsoft.Maps/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Maps account.   sku Sets the sku of the Azure Maps account.    Example open Farmer open Farmer.Builders let myMaps = maps { name \u0026#34;mymaps\u0026#34; sku Maps.S0 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/nsg/","title":"Network Security Group","tags":[],"description":"","content":"Overview The Network Security Group builder creates network security groups with rules for securing network access to resources.\n Network Security Groups (Microsoft.Network/networkSecurityGroups) Security Rules (Microsoft.Network/networkSecurityGroups/securityRules)  Builder Keywords    Applies To Keyword Purpose     nsg name Specifies the name of the network security group   nsg add_rules Adds security rules to the network security group   securityRule name The name of the security rule   securityRule description The description of the security rule   securityRule services The services port(s) and protocol(s) protected by this security rule   securityRule add_source Specify access from any source protocol, address, and port   securityRule add_source_any Specify access from any address and any port   securityRule add_source_address Specify access from a specific address and any port   securityRule add_source_network Specify access from a specific network and any port   securityRule add_source_tag Specify access from a tagged source such as \u0026ldquo;Internet\u0026rdquo;, \u0026ldquo;VirtualNetwork\u0026rdquo;, or \u0026ldquo;AzureLoadBalancer\u0026rdquo;   securityRule add_destination Specify access to any source protocol, address, and port   securityRule add_destination_any Specify access to any address and any port   securityRule add_destination_address Specify access to a specific address and any port   securityRule add_destination_network Specify access from a specific network and any port   securityRule add_destination_tag Specify access to a tagged destination such as \u0026ldquo;Internet\u0026rdquo;, \u0026ldquo;VirtualNetwork\u0026rdquo;, or \u0026ldquo;AzureLoadBalancer\u0026rdquo;   securityRule allow Allows this traffic (the default)   securityRule deny Denies this traffic    Basic Example open Farmer open Farmer.Builders open Farmer.NetworkSecurity // Create a rule for https services accessible from the internet let httpsAccess = securityRule { name \u0026#34;web-servers\u0026#34; services [ NetworkService (\u0026#34;https\u0026#34;, Port 443us) ] add_source_tag TCP \u0026#34;Internet\u0026#34; add_destination_any } // Create an NSG and add the rule to it. let myNsg = nsg { name \u0026#34;my-nsg\u0026#34; add_rules [ httpsAccess ] } Multiple Tier Private Network Example open Farmer open Farmer.Builders open Farmer.NetworkSecurity // Many services have a few ports, such as web services that are often on 80 and 443. // Some services only have a single port // Different tiers may reside on different network segments let corporateNet = \u0026#34;172.24.0.0/20\u0026#34; let webNet = \u0026#34;10.100.30.0/24\u0026#34; let appNet = \u0026#34;10.100.31.0/24\u0026#34; let dbNet = \u0026#34;10.100.32.0/24\u0026#34; // Create a rule for web servers - the \u0026#39;web\u0026#39; service, accessible from the corporate network let webAccess = securityRule { name \u0026#34;web-servers\u0026#34; description \u0026#34;Public web server access\u0026#34; services [ NetworkService (\u0026#34;http\u0026#34;, Port 80us) NetworkService (\u0026#34;https\u0026#34;, Port 443us) ] add_source_network TCP corporateNet add_destination_network webNet } // Create another rule for app servers - accessible only from network with the web servers let appAccess= securityRule { name \u0026#34;app-servers\u0026#34; description \u0026#34;Internal app server access\u0026#34; services [ NetworkService (\u0026#34;http\u0026#34;, Port 8080us) ] add_source_network TCP webNet add_destination_network appNet } // Create another rule for DB servers - accessible only from network with the app servers let dbAccess = securityRule { name \u0026#34;db-servers\u0026#34; description \u0026#34;Internal database server access\u0026#34; services [ NetworkService (\u0026#34;postgres\u0026#34;, Port 5432us)] add_source_network TCP appNet add_destination_network dbNet } // Create an NSG and add all 3 rules to it. let myNsg = nsg { name \u0026#34;my-nsg\u0026#34; add_rules [ webAccess appAccess dbAccess ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/postgresql/","title":"PostgreSQL","tags":[],"description":"","content":"Overview The PostgreSQL module contains two builders - postgreSQL, used to create PostgreSQL Azure servers, and postgreSQLDb, used to create individual databases. It supports features such as firewall, autogrow and version selection. Every PostgreSQL Azure server you create will automatically create a SecureString parameter for the admin account password.\n PostgreSQL server (Microsoft.DBforPostgreSQL/servers)  PostgreSQL Builder keywords    Applies To Keyword Purpose     Server name (string) Sets the name of the PostgreSQL server.   Server admin_username (string) Sets the admin username of the server.   Server geo_redundant_backup (bool) Enables/disables geo-redundant backup   Server enable_geo_redundant_backup Enables geo-redundant backup   Server disable_geo_redundant_backup Disables geo-redundant backup   Server storage_autogrow (bool) Enables/disables auto-grow storage   Server enable_storage_autogrow Enables auto-grow storage   Server disable_storage_autogrow Disables auto-grow storage   Server storage_size (int\u0026lt;Gb\u0026gt;) Sets the initial size of the storage available   Server backup_retention (int\u0026lt;Days\u0026gt;) Sets the number of days to keep backups   Server server_version (Version) Selects the PostgreSQL version of the server   Server capacity (int\u0026lt;VCores\u0026gt;) Sets the number of cores for the server   Server tier (Sku) Sets the service tier of the server   Server add_database (database:Database) Adds a database from the result of a postgreSQLDb builder expression   Server add_database (name:string) Adds a database with name of name   Server enable_azure_firewall Enables firewall access to all Azure services   Server add_firewall_rule (name:string, start ip:string, end ip:string) Adds a firewall rule to the server    PostgreSQLDb Builder keywords    Applies To Keyword Purpose     Database name (string) Sets the name of the PostgreSQL database   Database collation (string) Sets the collation of the postgreSQL database   Database charset (string) Sets the charset of the postgreSQL database    Example open Farmer open Farmer.Builders open Farmer.PostgreSQL let myPostgres = postgreSQL { admin_username \u0026#34;adminallthethings\u0026#34; name \u0026#34;aserverformultitudes42\u0026#34; capacity 4\u0026lt;VCores\u0026gt; storage_size 50\u0026lt;Gb\u0026gt; tier GeneralPurpose add_database \u0026#34;my_db\u0026#34; enable_azure_firewall } let template = arm { location Location.NorthEurope add_resource myPostgres } // WARNING: // since there is currently no free tier for PostgreSQL, actually deploying this // *will* incur spending on your subscription. template |\u0026gt; Write.quickWrite \u0026#34;postgres-example\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/redis/","title":"Redis Cache","tags":[],"description":"","content":"Overview The Redis builder creates managed Redis Cache accounts.\n Redis (Microsoft.Cache/redis)  Builder Keywords    Keyword Purpose     name Sets the name of the Redis cache instance.   sku Sets the sku of the Redis cache instance.   capacity Sets the capacity level of the Redis cache instance, should be between 1-6 - see here.   enable_non_ssl_port Enabled access to the cache over the non-SSL port.   setting Allows you to set a Redis-cache specific setting at deployment-time    Configuration Members    Member Purpose     Key Gets an ARM expression for the primary key of the Redis cache instance.    Example open Farmer open Farmer.Builders.Redis let myCache = redis { name \u0026#34;myredis\u0026#34; sku Redis.Standard capacity 1 enable_non_ssl_port setting \u0026#34;maxclients\u0026#34; 256 setting \u0026#34;maxmemory-reserved\u0026#34; 2 setting \u0026#34;maxfragmentationmemory-reserved\u0026#34; 12 setting \u0026#34;maxmemory-delta\u0026#34; 2 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/search/","title":"Search","tags":[],"description":"","content":"Overview The Search builder creates storage accounts and their associated containers.\n Search (Microsoft.Search/searchServices)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Search instance.   sku Sets the sku of the Azure Search instance.   replicas Sets the replica count of the Azure Search instance.   partitions Sets the number of partitions of the Azure Search instance.    Configuration Members    Member Purpose     AdminKey Gets an ARM expression for the admin key of the search instance.   QueryKey Gets an ARM expression for the query key of the search instance.    Example open Farmer open Farmer.Builders let mySearch = search { name \u0026#34;isaacsSearch\u0026#34; sku Search.Basic } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/service-bus/","title":"Service Bus","tags":[],"description":"","content":"Overview The Service Bus builder creates service bus namespaces and their associated queues.\n Service Bus Namespaces (Microsoft.ServiceBus/namespaces)  Builder Keywords    Applies To Keyword Purpose     Queue name The name of the queue.   Queue lock_duration_minutes The length of time that a lock can be held on a message.   Queue max_delivery_count The maximum number of times a message can be delivered before dead lettering.   Queue duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for.   Queue enable_session Enables session support.   Queue enable_dead_letter_on_message_expiration Enables dead lettering of messages that expire.   Queue enable_partition Enables partition support on the queue.   Queue link_to_namespace Link this queue to an existing namespace instead of creating a new one.   Queue message_ttl Time To Live (TTL) value for messages expressed as a TimeSpan string, such as \u0026lsquo;01:30:00\u0026rsquo; 1 hour, 30 minutes.   Queue message_ttl_days Time To Live (TTL) value for messages in days.   Subscription name The name of the subscription.   Subscription lock_duration_minutes The length of time that a lock can be held on a message.   Subscription max_delivery_count The maximum number of times a message can be delivered before dead lettering.   Subscription duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for.   Subscription enable_session Enables session support.   Subscription enable_dead_letter_on_message_expiration Enables dead lettering of messages that expire.   Subscription enable_partition Enables partition support on the queue.   Subscription link_to_namespace Link this queue to an existing namespace instead of creating a new one.   Subscription add_filters Adds multiple filters to a subscription   Subscription add_sql_filter Adds a filter to a subscription using SQL syntax.   Subscription add_correlation_filter Adds a filter to a subscription using header value correlation.   Topic name The name of the topic.   Topic duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for.   Topic enable_partition Enables partition support on the topic.   Topic message_ttl Time To Live (TTL) value for messages expressed as a TimeSpan string, such as \u0026lsquo;01:30:00\u0026rsquo; 1 hour, 30 minutes, or as an integer days e.g. 4\u0026lt;Days\u0026gt;.   Namespace sku The ServiceBusNamespaceSku e.g. Standard   Namespace namespace_name The name of the namespace that holds the queue.   Namespace depends_on Sets dependencies on the service bus namespace.    Configuration Members    Member Purpose     NamespaceDefaultConnectionString Returns an ARM expression to retrieve the Primary Connection String of the service bus.   DefaultSharedAccessPolicyPrimaryKey Returns an ARM expression to retrieve the Primary Key of the service bus.    Example open Farmer open Farmer.Builders open Farmer.ServiceBus let myServiceBus = serviceBus { name \u0026#34;my-namespace\u0026#34; sku Standard add_queues [ queue { name \u0026#34;queueA\u0026#34; } queue { name \u0026#34;queueB\u0026#34; } ] add_topics [ topic { name \u0026#34;topicA\u0026#34; } topic { name \u0026#34;topicB\u0026#34; } ] } let deployment = arm { location Location.NorthEurope add_resource myServiceBus output \u0026#34;connectionString\u0026#34; myServiceBus.NamespaceDefaultConnectionString output \u0026#34;defaultSharedAccessPolicyPrimaryKey\u0026#34; myServiceBus.DefaultSharedAccessPolicyPrimaryKey } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/signalr/","title":"SignalR","tags":[],"description":"","content":"Overview The SignalR builder creates SignalR services.\n SignalR Service (Microsoft.SignalRService/signalR)  Builder Keywords    Keyword Purpose     name Sets the name of the SignalR service.   sku Sets the sku of the SignalR service.   capacity Sets the capacity of the SignalR service. (optional)   allowed_origins Sets the allowed origins of the SignalR service. (optional)    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the primary connection string of the service. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let mySignalR = signalR { name \u0026#34;mysignalr\u0026#34; sku SignalR.Standard capacity 10 allowed_origins [ \u0026#34;https://github.com\u0026#34; ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/static-web-app/","title":"Static Web Apps","tags":[],"description":"","content":"Overview The Static Web App builder is used to create Static Web Apps. The Static Web App service is modern web app service that offers streamlined full-stack development from source code to global high availability. You can use it to host static web applications and Azure Functions in a single resource, using GitHub native workflows to build and deploy your application.\n Static Site (Microsoft.Web/staticSites)   At the time of writing, Static Web Apps are in public preview. Not all Azure locations support them.\n Static Web App Builder Keywords    Keyword Purpose     name Sets the name of the static web app.   repository The URI of the github repository containing your static web app.   artifact_location The folder where the built web app is copied to e.g. build (optional)   api_location The path containing your Azure Functions (optional)   app_location The path containing your application code (optional)   branch The branch that you which to use for the static web app (optional, defaults to \u0026lsquo;master\u0026rsquo;)    Configuration Members    Name Purpose     RepositoryParameter Provides the generated name for the repository token parameter name.    Parameters    Name Purpose     repositorytoken-for-name Provides the Github Personal Access Token (PAT) required to authenticate and create the appropriate Github Action.    Example open Farmer open Farmer.Builders let myApp = staticWebApp { name \u0026#34;isaacsstatic\u0026#34; repository \u0026#34;https://github.com/isaacabraham/staticwebreact\u0026#34; artifact_location \u0026#34;build\u0026#34; api_location \u0026#34;api\u0026#34; } let deployment = arm { location Location.WestEurope add_resource myApp } deployment |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ myApp.RepositoryParameter, \u0026#34;Github personal access token goes here...\u0026#34; ] "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/storage-account/","title":"Storage Account","tags":[],"description":"","content":"Overview The Storage Account builder creates storage accounts and their associated containers.\n Storage Accounts (Microsoft.Storage/storageAccounts) Storage Containers (blobServices/containers) File Shares (fileServices/shares) Queues (Microsoft.Storage/storageAccounts/queueServices/queues)  Builder Keywords    Keyword Purpose     name Specifies the name of the storage account   sku Sets the SKU of the storage account. A set of predefined SKU values are available as members in Storage.Sku, but you can create the full range of combinations of Kind and SKU as needed.   add_public_container Adds a general-purpose public storage container   add_private_container Adds a general-purpose private storage container   add_blob_container Adds a general-purpose private blob container   add_file_share Adds a file share to storage account   add_file_share_with_quota Adds a file share to storage account with a share quota in Gb   add_queue Adds a queue to the storage account   add_queues Adds a list of queues to the storage account   use_static_website Activates static website host, and uploads the provided local content as a post-deployment task to the storage with the specified index page   static_website_error_page Specifies the 404 page to display for static website hosting   enable_data_lake Enables Azure Data Lake Gen2 support on the storage account   add_lifecycle_policy Given a rule name, a list of PolicyActions and a list of string filters, creates a lifecycle policy for the storage account   grant_access Given a managed identity (can be either user- or system- assigned), and a specific RoleId from the Roles module, grants access to the identity for the provided role.    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the storage account\u0026rsquo;s primary connection string. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.   WebsitePrimaryEndpoint Returns an ARM Expression for the Primary endpoint for static website (if enabled).   WebsitePrimaryEndpointHost Returns an ARM Expression for the Host of the Primary endpoint for static website (if enabled). Use this for e.g. Azure CDN integration.    Helpers The StorageAccount type contains helper methods to quickly create ARM expressions for Storage Account connection strings.\nExample open Farmer open Farmer.Builders let storage = storageAccount { name \u0026#34;isaacssuperstorage\u0026#34; sku Storage.Premium_LRS add_public_container \u0026#34;mypubliccontainer\u0026#34; add_private_container \u0026#34;myprivatecontainer\u0026#34; add_blob_container \u0026#34;myblobcontainer\u0026#34; add_file_share \u0026#34;share1\u0026#34; add_file_share_with_quota \u0026#34;share2\u0026#34; 1024\u0026lt;Gb\u0026gt; use_static_website \u0026#34;local/path/to/folder/content\u0026#34; \u0026#34;index.html\u0026#34; static_website_error_page \u0026#34;error.html\u0026#34; enable_data_lake true add_lifecycle_rule \u0026#34;moveToCool\u0026#34; [ Storage.CoolAfter 30\u0026lt;Days\u0026gt;; Storage.ArchiveAfter 90\u0026lt;Days\u0026gt; ] Storage.NoRuleFilters add_lifecycle_rule \u0026#34;cleanup\u0026#34; [ Storage.DeleteAfter 7\u0026lt;Days\u0026gt; ] [ \u0026#34;data/recyclebin\u0026#34; ] grant_access myWebApp.SystemIdentity Roles.StorageBlobDataReader } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/sql/","title":"SQL Azure","tags":[],"description":"","content":"Overview The SQL Azure module contains two builders - sqlServer, used to create SQL Azure servers, and sqlDb, used to create individual databases. It supports features such as encryption, firewalls and automatic pool creation. Every SQL Azure server you create will automatically create a SecureString parameter for the admin account password.\n SQL Azure server (Microsoft.Sql/servers)  SQL Server Builder Keywords    Keyword Purpose     server_name Sets the name of the SQL server.   add_firewall_rule Adds a custom firewall rule given a name, start and end IP address range.   enable_azure_firewall Adds a firewall rule that enables access to other Azure services.   admin_username Sets the admin username of the server.   elastic_pool_name Sets the name of the elastic pool, if required. If not set, Farmer will generate a name for you.   elastic_pool_sku Sets the sku of the elastic pool, if required. If not set, Farmer will default to Basic 50.   elastic_pool_database_min_max Sets the optional minimum and maximum DTUs for the elastic pool for each database.   elastic_pool_capacity Sets the optional disk size in MB for the elastic pool for each database.    SQL Server Configuration Members    Member Purpose     ConnectionString Gets a literal .NET connection string using the administrator username / password, given a database or database name. The password will be evaluated based on the contents of the password parameter supplied to the template at deploy time.   PasswordParameter Gets a string that represents the parameter password required for deployment on the sql instance by Farmer e.g. \u0026ldquo;password-for-mysqlserver\u0026rdquo;.    SQL Database Builder Keywords    Keyword Purpose     name Sets the name of the database.   sku Sets the sku of the database. If not set, the database is assumed to be part of an elastic pool which will be automatically created.   hybrid_benefit If a VCore-style SKU is selected, this allows you to use Azure Hybrid Benefit licensing.   db_size Sets the maximum database size.   collation Sets the collation of the database.   use_encryption Enables transparent data encryption of the database.    Example open Farmer open Farmer.Builders open Sql let myDatabases = sqlServer { name \u0026#34;my_server\u0026#34; admin_username \u0026#34;admin_username\u0026#34; enable_azure_firewall elastic_pool_name \u0026#34;mypool\u0026#34; elastic_pool_sku PoolSku.Basic100 add_databases [ sqlDb { name \u0026#34;poolDb1\u0026#34; } sqlDb { name \u0026#34;poolDb2\u0026#34; } sqlDb { name \u0026#34;dtuDb\u0026#34;; sku Basic } sqlDb { name \u0026#34;memoryDb\u0026#34;; sku M_8 } sqlDb { name \u0026#34;cpuDb\u0026#34;; sku Fsv2_8 } sqlDb { name \u0026#34;businessCriticalDb\u0026#34;; sku (BusinessCritical Gen5_2) } sqlDb { name \u0026#34;hyperscaleDb\u0026#34;; sku (Hyperscale Gen5_2) } sqlDb { name \u0026#34;generalPurposeDb\u0026#34; sku (GeneralPurpose Gen5_8) db_size (1024\u0026lt;Mb\u0026gt; * 128) hybrid_benefit } ] } let template = arm { location Location.NorthEurope add_resource myDatabases } template |\u0026gt; Writer.quickWrite \u0026#34;sql-example\u0026#34; template |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ \u0026#34;password-for-my_server\u0026#34;, \u0026#34;*****\u0026#34; ] "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/virtual-machine/","title":"Virtual Machine","tags":[],"description":"","content":"Overview The Virtual Machine builder creates a fully configured virtual machine and all its required child resources.\n Virtual Machines (Microsoft.Compute/virtualMachines) Virtual Networks (Microsoft.Network/virtualNetworks) IP Addresses (Microsoft.Network/publicIPAddresses) Network Interfaces (Microsoft.Network/networkInterfaces) Storage Accounts (Microsoft.Storage/storageAccounts)  In addition, every VM you create will add a SecureString parameter to the ARM template, whose name follows the pattern password-for-[virtual machine name].\nBuilder Keywords    Keyword Purpose     name Sets the name of the VM.   diagnostics_support Turns on diagnostics support using an automatically created created storage account.   diagnostics_support_external Turns on diagnostics support using an existing storage account.   vm_size Sets the size of the VM.   username Sets the admin username of the VM (note: the password is supplied as a securestring parameter to the generated ARM template).   operating_system Sets the operating system of the VM. A set of samples is provided in the CommonImages module.   os_disk Sets the size and type of the OS disk for the VM.   add_disk Adds a data disk to the VM with a specific size and type.   add_ssd_disk Adds a SSD data disk to the VM with a specific size.   add_slow_disk Adds a conventional (non-SSD) data disk to the VM with a specific size.   domain_name_prefix Sets the prefix for the domain name of the VM.   address_prefix Sets the IP address prefix of the VM.   subnet_prefix Sets the subnet prefix of the VM.   custom_script Executes the supplied inline custom script on the VM.   custom_script_files Uploads the supplied set of files, specified by URI, to the VM on creation.    Configuration Members    Member Purpose     NicName Provides the resource name of the Network Interface Card (NIC)   VnetName Provides the resource name of the Virtual Network (VNet)   SubnetName Provides the resource name of the subnet   IpName Provides the resource name of the IP Address   Hostname Returns an ARM expression to retrieve the fully-qualified domain name from the virtual machine\u0026rsquo;s DNS settings.\u0026rdquo;    Example open Farmer open Farmer.Builders let myVm = vm { name \u0026#34;myFarmerVm\u0026#34; username \u0026#34;yourUsername\u0026#34; vm_size Vm.Standard_A2 operating_system Vm.WindowsServer_2012Datacenter os_disk 128 Vm.StandardSSD_LRS add_ssd_disk 128 add_slow_disk 512 custom_script \u0026#34;powershell setup-vm.ps1\u0026#34; // you have to actually *call* the script  custom_script_files [ \u0026#34;https://foo.bar/foo/setup-vm.ps1\u0026#34; ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/vnet-gateway/","title":"Virtual Network Gateway","tags":[],"description":"","content":"Overview The Virtual Network Gateway builder creates virtual network gateways for ExpressRoute or VPN connections to a virtual network.\n Virtual Network Gateways (Microsoft.Network/virtualNetworkGatways) Connections (Microsoft.Network/connections)  Builder Keywords    Applies To Keyword Purpose     Gateway name Specifies the name of the virtual network gateway   Gateway vnet The name of the virtual network to which the gateway connects   Gateway er_gateway_sku SKU for an ExpressRoute gateway   Gateway vpn_gateway_sku SKU for a VPN gateway   Gateway vpn_type Sets the VPN type to route-based (default) or policy-based.   Gateway gateway_ip_config Specifies the gateway public and private IP addresses   Gateway active_active_ip_config Specifies the second public and private IP configuration for a redundant gateway   Gateway disable_bgp BGP is enabled by default, but this can disable it   Gateway vpn_client Specifies the VPN client configuration using the vpnclient builder (optional)   VPNClient add_address_pool The reference of the address space resource which represents Address space for P2S VpnClient   VPNClient add_root_certificate Adds the name and the public data of a root certificate to validate client certificates used for VPN Client connexion. This can be either just the data of the base64 content of the certificate or a multiline string starting with \u0026mdash;\u0026ndash;BEGIN CERTIFICATE\u0026mdash;\u0026ndash; and ending with \u0026mdash;\u0026ndash;END CERTIFICATE\u0026mdash;\u0026ndash;   VPNClient add_revoked_certificate Adds the name and the thumbprint of a revoked client certificate   VPNClient protocols Sets the protocols for the VPN client. SSTP (default), IkeV2 or OpenVPN   Connection name Specifies the name of the connection   Connection vnet_gateway1 Name of the first vnet gateway this is connecting   Connection vnet_gateway2 Name of the second vnet gateway this is connecting, for use when connecting two vnets   Connection local_gateway Name of the local gateway connection for a VPN   Connection peer_id Id of the peer, typically an ExpressRoute circuit Id   Connection auth_key Authorization key used when peering across subscriptions    Example open Farmer open Farmer.Builders open Farmer.VirtualNetworkGateway let gw = gateway { name \u0026#34;er-gateway\u0026#34; vnet \u0026#34;my-vnet\u0026#34; // Must contain a subnet named \u0026#39;GatewaySubnet\u0026#39;  er_gateway_sku ErGatewaySku.Standard vpn_client (vpnclient { add_address_pool \u0026#34;10.31.0.0/16\u0026#34; add_root_certificate \u0026#34;rootcert\u0026#34; \u0026#34;\u0026#34; }) } let privateNet = vnet { name \u0026#34;my-vnet\u0026#34; add_address_spaces [ \u0026#34;10.30.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;GatewaySubnet\u0026#34; prefix \u0026#34;10.30.254.0/28\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/web-app/","title":"Web App","tags":[],"description":"","content":"Overview The Web App builder is used to create Azure App Service accounts. It abstracts the Service Plan into the same component, and will also create and configure a linked App Insights resource. If you wish to create a website that connects to an existing service plan, use the link_to_service_plan keyword and provide the resource name of the service plan to connect to.\n Web Site (Microsoft.Web/sites) Server Farms (Microsoft.Web/serverfarms) Source Controls (Microsoft.Web/sites/sourcecontrols) Application Insights (Microsoft.Insights/components)  Web App Builder Keywords    Applies To Keyword Purpose     Web App name Sets the name of the web app.   Web App link_to_service_plan Instructs Farmer to link this webapp to a Farmer service plan configuration defined elsewhere in your application, rather than creating a new one.   Web App link_to_unmanaged_service_plan Instructs Farmer to link this webapp to an existing service plan that is externally managed, rather than creating a new one.   Web App app_insights_auto_name Sets the name of the automatically-created app insights instance.   Web App app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   Web App link_to_app_insights Instructs Farmer to link this webapp to a Farmer App Insights configuration defined elsewhere in your application, rather than creating a new one.   Web App link_to_unmanaged_app_insights Instructs Farmer to link this webapp to an existing app insights instance that is externally managed, rather than creating a new one.   Web App run_from_package Sets the web app to use \u0026ldquo;run from package\u0026rdquo; deployment capabilities.   Web App website_node_default_version Sets the node version of the web app.   Web App setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   Web App secret_setting Sets a \u0026ldquo;secret\u0026rdquo; app setting of the web app. You must supply the \u0026ldquo;key\u0026rdquo;, whilst the value will be supplied as a secure parameter.   Web App settings Sets a list of app setting of the web app as tuples in the form of (\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;).   Web App connection_string Creates a connection string whose value is supplied as secret parameter, or as an ARM expression in the tupled form of (\u0026ldquo;key\u0026rdquo;, expr).   Web App connection_strings Creates a set of connection strings of the web app whose values will be supplied as secret parameters.   Web App https_only Disables http for this webapp so that only HTTPS is used.   Web App enable_http2 Configures the webapp to allow clients to connect over http2.0.   Web App disable_client_affinity Stops the webapp from sending client affinity cookies.   Web App enable_websockets Configures the webapp to allow clients to connect via websockets.   Web App depends_on Sets dependencies for the web app.   Web App docker_image Sets the docker image to be pulled down from Docker Hub, and the command to execute as a second argument. Automatically sets the OS to Linux.   Web App docker_ci Turns on continuous integration of the web app from the Docker source repository using a webhook.   Web App docker_use_azure_registry Uses the supplied Azure Container Registry name as the source of the Docker image, instead of Docker Hub. You do not need to specify the full url, but just the name of the registry itself.   Web App add_identity Adds a managed identity to the the Web App.   Web App system_identity Activates the system identity of the Web App.   Web App enable_cors Enables CORS support for the app. Either specify WebApp.AllOrigins or a list of valid URIs as strings.   Web App enable_cors_credentials Allows CORS requests with credentials.   Web App source_control Given a github repository URI and branch name, configures the web app to automatically deploy those files to the web app   Web App disable_source_control_ci Disables continuous integration from source control on push   Web App enable_source_control_ci Enables continuous integration from source control on push   Service Plan service_plan_name Sets the name of the service plan. If not set, uses the name of the web app postfixed with \u0026ldquo;-plan\u0026rdquo;.   Service Plan always_on Sets \u0026ldquo;Always On\u0026rdquo; flag.   Service Plan runtime_stack Sets the runtime stack.   Service Plan operating_system Sets the operating system. If Linux, App Insights configuration settings will be omitted as they are not supported by Azure App Service.   Service Plan sku Sets the sku of the service plan.   Service Plan worker_size Sets the size of the service plan worker.   Service Plan number_of_workers Sets the number of instances on the service plan.     Farmer also comes with a dedicated Service Plan builder that contains all of the above keywords that apply to a Service Plan.\nUse this builder if you wish to have an explicit and clear separation between your web app and service plan. Otherwise, it is recommended to use the service plan keywords that exist directly in the web app builder, and let Farmer handle the connections between them.\n Post-deployment Builder Keywords The Web App builder contains special commands that are executed after the ARM deployment is completed.\n   Keyword Purpose     zip_deploy Supplying a folder or zip file will instruct Farmer to upload the contents directly to the App Service once the ARM deployment is complete.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this web app.   ServicePlan Gets the Resource Name of the service plan for this web app.   AppInsights Gets the Resource Name of the service plan for the AI resource linked to this web app.   SystemIdentity Gets the system-created managed principal for the web app. It must have been enabled using the system_identity keyword.    Key Vault integration The Web App builder comes with special integration into KeyVault. By activating KeyVault integration, the web app builder can automatically link to, or even create, a full KeyVault instance. All Secret or ARM Expression-based Settings (e.g. a setting that links to the Key of a Storage Account) will automatically be redirected to KeyVault. The value will be stored in KeyVault and the system identity will be activated and provided into the KeyVault with GET permissions. Lastly, Web App app settings will remain in place, using the Azure App Service built-in KeyVault redirection capabilities.\nThe following keywords exist on the web app:\n   Member Purpose     use_keyvault Tells the web app to create a brand new KeyVault for this App Service\u0026rsquo;s secrets.   use_managed_keyvault Tells the web app to use an existing Farmer-managed KeyVault which you have defined elsewhere.   use_external_keyvault Tells the web app to use an existing non-Farmer managed KeyVault which you have defined elsewhere.    Example open Farmer open Farmer.Builders open Farmer.WebApp let myWebApp = webApp { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku WebApp.Sku.B1 always_on app_insights_off worker_size Medium number_of_workers 3 run_from_package system_identity } "},{"uri":"https://compositionalit.github.io/farmer/","title":"Farmer","tags":[],"description":"","content":"  Making repeatable Azure deployments easy! Farmer is an easy-to-learn library for rapidly authoring and deploying entire Azure architectures.\n Infrastructure-as-code, done right. Simple code snippets allow you to rapidly construct complex topologies. Idempotent deployments. Safely provision a template repeatedly and know that only changes will be applied. Cross-platform. Runs on .NET Core on Windows, Mac or Linux. Built on trusted technologies. Farmer uses Microsoft\u0026rsquo;s Azure Resource Manager (ARM) technology for deployments to Azure. Commercial supported. Professional support plans for teams that wish to benefit from peace of mind and further improve the product. Easy to learn, easy to understand code through a simple, strongly-typed and pragmatic DSL.  Already using ARM templates? Farmer has you covered.\n Farmer is completely backwards compatible with ARM templates. Farmer generates standard ARM templates so you can continue to use existing deployment processes. Safely create dependencies between resources. Uses static typing to give confidence that your templates will work first time. Easily access common properties of resources. No more fighting to concatenate cryptic strings! Extensible API. Add new helpers and members as needed. Open source and free. Farmer is free to use and modify. We welcome contributions to the project!  Why not Azure Resource Manager? Farmer uses a simple DSL to declare resources and comes with helper functions to perform common tasks. Farmer templates are around 5-8 times smaller than ARM templates, meaning they are quicker and easier to author, understand and maintain. Read more on the comparison page.\nCreating a web application with a configured application insights and a linked storage account Farmer Templates These 20 lines of simple, readable and type-safe code are translated into 141 lines of JSON ARM template!\n// Create a storage account with a container let myStorageAccount = storageAccount { name \u0026#34;myTestStorage\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } // Create a web app with application insights that\u0026#39;s connected to the storage account. let myWebApp = webApp { name \u0026#34;myTestWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key } // Create an ARM template let deployment = arm { location Location.NorthEurope add_resources [ myStorageAccount myWebApp ] } // Deploy it to Azure! deployment |\u0026gt; Writer.quickDeploy \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters Want to try it out? Follow our quickstart guide now! "},{"uri":"https://compositionalit.github.io/farmer/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://compositionalit.github.io/farmer/tags/","title":"Tags","tags":[],"description":"","content":""}]