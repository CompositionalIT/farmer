[{"uri":"https://compositionalit.github.io/farmer/api-overview/template-generation/","title":"Generating templates","tags":[],"description":"","content":"Farmer supports several ways to \u0026ldquo;output\u0026rdquo; ARM templates.\nGenerating JSON as a string You can generate an ARM template as a plain string:\nlet json = deployment.Template |\u0026gt; Writer.toJson // prints out the JSON  printfn \u0026#34;%s\u0026#34; json Writing to a file You can write out the ARM template directly to a file, from which you can then deploy to Azure using whichever mechanism you already use e.g. Azure CLI, Powershell, REST API etc.\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myTemplate\u0026#34; Notice how we use F#\u0026lsquo;s pipe operator to \u0026ldquo;pipe\u0026rdquo; data from the template configuration into json before writing to a file.\nIntegrated deployment to Azure You can also turn over deployment of the template directly to Farmer. In this case, it orchestrates commands to the Azure CLI as required.\nlet response = deployment |\u0026gt; Deploy.tryExecute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters match response with | Ok outputs -\u0026gt; printfn \u0026#34;Success! Outputs: %A\u0026#34; outputs | Error error -\u0026gt; printfn \u0026#34;Failed! %s\u0026#34; error As you can see, the response of calling tryExecute is a Result object which is either Ok, in which case any outputs returned from the template are made available as a Map\u0026lt;string, string\u0026gt;, or an Error, which is the error returned by the Azure CLI. Alternatively, you can call execute which will throw an exception rather than return a Result.\n You must have the Azure CLI installed on your machine in order for Farmer to perform deployments for you.\n Authenticating to Azure Azure CLI stores a login token on your machine, and Farmer will check for this. If you aren\u0026rsquo;t logged in, Farmer will automatically start the interactive Azure CLI login process for you.\nFor automated deployments e.g. continuous deployment or through scripts etc., you\u0026rsquo;ll want to use an unattended deployment mode. Some CI systems such as Azure Devops come with an pre-authenticated Azure CLI terminal from which you can run an application that uses Farmer. Alternatively, you can create a service principal, and supply them to the Deploy.authenticate function before calling Deploy.execute.\nYou should use a secure mechanism for storing and supplying the credentials to Farmer. Do not commit them into source control!\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/app-insights/","title":"App Insights","tags":[],"description":"","content":"Overview The App Insights builder is used to create Application Insights accounts. Use this if you need a standalone AI instance; if you need one for a web app, the web app will create one by default and configure the application settings automatically.\n Application Insights (Microsoft.Insights/components)  Builder Keywords    Keyword Purpose     name Sets the name of the App Insights instance.    Configuration Members    Member Purpose     InstrumentationKey Gets the ARM expression path to the instrumentation key of this App Insights instance.    Example open Farmer open Farmer.Builders let ai = appInsights { name \u0026#34;myAI\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/arm/","title":"ARM Deployment","tags":[],"description":"","content":"Overview The ARM deployment builder is always the top-level element of your deployment. It contains the manifest of all Farmer resources that you create.\nBuilder Keywords    Keyword Purpose     location Sets the default location of all resources.   add_resource Adds a resource to the template.   add_resources Adds a collection of resources to the template.   output Creates an output value that will be returned by the ARM template. Since Farmer does not require variables, and the only parameters supported are secure strings, these will typically be an ARM expressions that are generated at deployment-time, such as the publishing password of a web app or the fully-qualified domain name of a SQL instance etc.    Example let deployment = arm { // All resources will share this location  location Locations.NorthEurope // Assume myStorageAccount and myWebApp have been defined...  add_resource myStorageAccount add_resource myWebApp output \u0026#34;webAppName\u0026#34; myWebApp.Name output \u0026#34;webAppPassword\u0026#34; myWebApp.PublishingPassword } "},{"uri":"https://compositionalit.github.io/farmer/about/","title":"About","tags":[],"description":"","content":"About Farmer Farmer is an open source, free to use .NET domain-specific-language (DSL) for rapidly generating non-complex Azure Resource Manager (ARM) templates.\nFor those of you working with Azure today, you may already be aware that one of the most useful features is the ability to generate entire infrastructure architectures as code via ARM Template files. These templates contain a declarative model that allows repeatable deployments and idempotent releases (among other things).\nWhat\u0026rsquo;s wrong with ARM? Unfortunately, ARM templates have some limitations caused by the fact that they must be authored in a verbose JSON dialect:\n They provide very limited type checking and support, which makes creating discovery and creation of template features difficult. Templates need a lot of boilerplate to be created for even relatively simple and common resources. It requires \u0026ldquo;embedded\u0026rdquo;, difficult-to-maintain stringly-typed code in order to achieve what might be trivial in a \u0026ldquo;proper\u0026rdquo; programming language, such as references, variables and parameters - or writing elements such as loops. The documentation for ARM templates is not always kept up-to-date, so understanding and learning how to properly use them can involve a lot of searching and trial-and-error.  In other words, whilst working with ARM templates that have already been created is relatively straightforward, the authoring of the templates themselves is time-consuming and error-prone.\nWhilst there have been some recent improvements to ARM - including tooling improvements in VS Code through an extension - we think that we can do much better than relying on tooling for a specific IDE, which means using something different than JSON when directly authoring ARM templates.\nWhat does Farmer do to fix this? Farmer templates are simple .NET Core applications which reference the Farmer NuGet package. This package contains a set of types that model Azure resources in a strongly-typed and succinct fashion, as well as functionality to create ARM templates from this model - and even deploy directly to Azure.\nWhat can I use Farmer for? Farmer currently has support for a large number of common resources including web apps, sql and storage, with more being added over time.\n"},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-1/","title":"Your first Farmer template","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll:\n create a web application with a fully-configured Application Insights instance create an ARM deployment object and assign the web app to it generate an ARM template  Creating a Farmer app Create an F# console application using the .NET SDK and add the Farmer package in an empty directory:\ndotnet new console -lang F# dotnet add package Farmer  Farmer also has a .NET template to get started even more quickly!\n Defining a Farmer web application Open Program.fs and delete all the contents.\n In Farmer, resources are defined using special code blocks that look somewhat json-esque, known as a \u0026ldquo;builder\u0026rdquo;. In these builders you can quickly and easily configure a resource using special keywords, but unlike json you also have edit-time safety.\n Create a Farmer web application using the webApp { } builder:\nopen Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } Create an ARM template deployment object, before setting the location for the overall resource group and adding the web app into it.\nlet deployment = arm { location Location.NorthEurope add_resource myWebApp } Generating the ARM template Now you need to generate the ARM template from the deployment object to an ARM json file.\nAdd the following code:\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; Run the application:\ndotnet run You should notice that the file myFirstTemplate.json has been created.\nThe generated ARM template contains the following resources:\n A web application A server farm An application insights instance  The resources will be correctly configured with the appropriate dependencies set.\nThe full application open Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } let deployment = arm { location Location.NorthEurope add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/1-the-farmer-pipline/","title":"1. The Farmer Pipeline","tags":[],"description":"","content":"This step will get you up and running by incorporate something quickly and easily into the Farmer pipeline that emits a valid Azure Container Registry.\nStep 1.1: Prototype and test using an fsx file Technically this step is not necessary but it is the quickest way to get a working deployment from which you can iterate upon.\nStart by looking at this sample and identifying the section of JSON that relates to the resource we want - in our case, the Microsoft.ContainerRegistry/registries resource.\n The use of #r \u0026quot;nuget:...\u0026quot; syntax can be enabled by going to Settings \u0026gt; F# \u0026gt; Fsi Extra Parameters and adding --langversion:preview to the FSharp.fsiExtraParameters list (.NET 5 only)\nIf you are not using .NET 5, manually build Farmer and reference the dll manually - see the samples folder for examples.\n // container-registry-prototype.fsx #r \u0026#34;nuget: farmer\u0026#34; #r \u0026#34;nuget: Newtonsoft.Json\u0026#34; open Farmer open Farmer.CoreTypes // A function called \u0026#34;registries\u0026#34; that takes in a name, sku and boolean flag for whether to enable the admin user. let registries name sku adminUserEnabled = sprintf \u0026#34;\u0026#34;\u0026#34;{ \u0026#34;name\u0026#34;: \u0026#34;%s\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westeurope\u0026#34;, \u0026#34;tags\u0026#34;: { }, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;%s\u0026#34; }, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: %b } }\u0026#34;\u0026#34;\u0026#34; name sku adminUserEnabled |\u0026gt; Resource.ofJson let deployment = arm { location Location.NorthEurope add_resource (registries \u0026#34;my-registry\u0026#34; \u0026#34;Basic\u0026#34; true) } deployment |\u0026gt; Writer.quickWrite \u0026#34;test-output\u0026#34; // or push out for real to Azure!  // deployment // |\u0026gt; Deploy.execute \u0026#34;FarmerTest\u0026#34; Deploy.NoParameters // |\u0026gt; printfn \u0026#34;%A\u0026#34; Observe how we\u0026rsquo;ve pasted a minimal section of JSON and then tried to extract some of the candidates for parameterisation - in our case name, sku and adminUserEnabled, and how we\u0026rsquo;ve used the Resource.ofJson function to create an IArmResource for us to quickly allow us \u0026ldquo;into\u0026rdquo; the Farmer pipeline.\nTest out the JSON model you created and make sure it creates the resources in Azure you would expect. You can deploy with execute or you can use whatIf to see what the expected state would be.\nStep 1.2: Convert from JSON to an F# anonymous record For simple ARM resources, raw JSON may suffice, but normally you\u0026rsquo;ll want a little more control in order to programmatically choose whether to add / remove fields etc. during the export phase. The best way to do this is to replace the raw string export with an anonymous record:\nlet registries name sku adminUserEnabled = {| name = name ``type`` = \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; apiVersion = \u0026#34;2019-05-01\u0026#34; location = \u0026#34;westeurope\u0026#34; tags = {| |} sku = {| name = sku |} properties = {| adminUserEnabled = adminUserEnabled |} |} |\u0026gt; Resource.ofObj Notice how the structure is the same, but is now implemented directly in F#.\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/arm-basics/","title":"ARM Basics","tags":[],"description":"","content":" Skip this section if you are already familiar with ARM Templates\n This won\u0026rsquo;t be an introduction to Azure Resource Manager or ARM templates. Instead let\u0026rsquo;s go through the main parts that are important for creating a new resource.\nThe main parts of ARM Templates can be broken into resources, outputs, variables, and parameters. Farmer has limited support for parameters and no support for variables, so we will not cover them.\nSo a generated ARM Template from Farmer will have the following structure.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#\u0026#34;, \u0026#34;contentVersion\u0026#34;: \u0026#34;1.0.0.0\u0026#34;, \u0026#34;outputs\u0026#34;: {}, \u0026#34;parameters\u0026#34;: {}, \u0026#34;resources\u0026#34;: [] } When building a new resource in Farmer you are providing the means for a user of Farmer to generate a new resource type, or configure a new property on an existing resource. These resources are added by Farmer to the resources array you can see above.\nWhen building up a resource it will have a schema that looks something like this.\n{ \u0026#34;name\u0026#34;: \u0026#34;my-example-resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westeurope\u0026#34;, \u0026#34;tags\u0026#34;: {}, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;S1\u0026#34; }, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: true, }, \u0026#34;resources\u0026#34;: [] } Your resource you create will have a type of service that it represents. Each service has many versions, represented by a date. Typically your builder will at first focus on adding properties to the properties field to configure a service to be deployed in a certain state.\nWhere can I find docs on ARM templates schemas themselves? There are three good sources to learning about specific ARM resources and what parts need to be used in creating an equivalent Farmer resource:\n Reference Docs: The reference documentation contains details on the schema for every resource and every version e.g. Container Registry reference. Sample Template: The Azure Quickstart Templates github repository contains many examples of real-world ARM templates e.g. Container Registry with Geo Replication sample. Reverse engineer: You can manually create a required resource in Azure, and then use Azure\u0026rsquo;s export ARM template functionality to create an ARM template. It\u0026rsquo;s important that you test out the exported template yourself before porting it to Farmer, because Azure sometimes exports invalid templates!  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/","title":"Resources","tags":[],"description":"","content":"Resources Farmer currently has support for the most popular resources in Azure, such as Storage, App Service and Functions. You can find out more about each resource in detail in the menu.\n"},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-2/","title":"Working with multiple resources","tags":[],"description":"","content":"Introduction In this quickstart, you\u0026rsquo;ll expand on the deployment authored in the previous quickstart as follows:\n add an Azure storage account add an application setting to the web app that references the storage account\u0026rsquo;s key set a dependency between the two resources  Creating a storage account Create a storage account by using the storageAccount builder.\nlet myStorage = storageAccount { name \u0026#34;yourfirststorage\u0026#34; }  Azure Storage Account names must be globally unique and between 3-24 alphanumeric lower-case characters:\n Referencing the storage account in the web app In this section, we will add an app setting to the web app and set the value to the storage account\u0026rsquo;s connection string.\n In F#, you need to define a value before you reference it, so make sure that you define the storage account above the web app.\n Add the storage account\u0026rsquo;s connection key to the webapp as an app setting.\nlet myWebApp = webApp { ... setting \u0026#34;STORAGE_CONNECTION\u0026#34; myStorage.Key }  Settings can be strings or (as in this case) an ARM expression, which is evaluated at deployment time.\n Setting a dependency on the storage account In ARM templates, you need to explicitly set up dependencies between resources that refer to one another; this is still required in Farmer. This tells Azure to create the storage account before it creates the web app.\nlet myWebApp = webApp { ... depends_on myStorage } Adding the storage account to the deployment Add the storage account to the deployment using the same add_resource keyword as you did with myWebApp.\nAnalysing the ARM template Run the application:\ndotnet run You should notice that the template now contains a storage account. Also observe the dependency that has been created:\n{ \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2016-08-01\u0026#34;, \u0026#34;dependsOn\u0026#34;: [ \u0026#34;yourfirststorage\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Web/sites\u0026#34; } ] } Also observe the application setting that has been created:\n{ \u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=yourfirststorage;AccountKey=\u0026#39;, listKeys(\u0026#39;yourfirststorage\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } ] } The full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorageaccount\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key depends_on myStorageAccount.Name } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/","title":"Quickstarts","tags":[],"description":"","content":"This section contains quickstarts to performing common tasks.\n Creating your first Farmer template Creating multiple resources Deploying to Azure The Farmer .NET Template  "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/2-iarm-resource/","title":"2. The IArmResource","tags":[],"description":"","content":"In this exercise, we\u0026rsquo;ll migrate our code from the previous step directly into the Farmer codebase.\nStep 2.1: Migrating to IArmResource Now that you know that your resource model produces the correct Json value when passed into Farmer, we can now create a formal IArmResource statically that contains the \u0026ldquo;parameterised\u0026rdquo; parts of the above function, such as name, sku and adminUserEnabled and properly take part in the Farmer pipeline. This record should use types as required to capture e.g. SKUs or other elements that would benefit from typing (in the example above, sku is a string, but we will shortly replace that with a union type).\n Try to avoid going too far - the implementation of JsonModel should, more or less, be a copying of fields across and adding in some extra boilerplate around the type field etc. Feel free to use member properties to capture values that are \u0026ldquo;derived\u0026rdquo; from other ones.\n // src/Farmer/Arm/ContainerRegistry.fs [\u0026lt;AutoOpen\u0026gt;] module Farmer.Arm.ContainerRegistry open Farmer // Temporarily define the SKU and other types alongside the IArmResource. type Sku = | Basic | Standard | Premium type Registries = { Name : ResourceName Location : Location Sku : Sku AdminUserEnabled : bool } interface IArmResource with member this.ResourceName = this.Name member this.JsonModel = {| name = this.Name.Value ``type`` = \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; apiVersion = \u0026#34;2019-05-01\u0026#34; sku = {| name = this.Sku.ToString() |} location = this.Location.ArmValue tags = {||} properties = {| adminUserEnabled = this.AdminUserEnabled |} |} :\u0026gt; _ Notice how we perform simple \u0026ldquo;serialization\u0026rdquo; of elements such as the SKU, but otherwise most fields are copies across.\nStep 2.2: Move domain types out of the IArmBuilder. For now, we\u0026rsquo;ve created any associated types such as Sku directly above the file, but you\u0026rsquo;ll want to migrate these to a Farmer.ContainerRegistry module in Common.fs afterwards e.g.\n// src/Farmer/Common.fs namespace Farmer module ContainerRegistry = type Sku = | Basic | Standard | Premium You can test this again easily by passing an instance into a Farmer deployment like we did in the previous step:\nopen Farmer.Arm.ContainerRegistry let registries = { Name = ResourceName \u0026#34;my-registry\u0026#34; Location = Location.WestEurope Sku = ContainerRegistry.Basic AdminUserEnabled = true } let deployment = arm { location Location.NorthEurope add_resource registries } deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34; Note that F# records must be completely filled, so you must provide values for all four fields.\nAlternatively, you could now write a test to assert the Json structure. Most tests in the project though tend to test from the Farmer builders, which we will get to soon. You can stop right here if you want - what you\u0026rsquo;ve done so far allows you to create IArmResource objects which can be added to the Farmer pipeline. However, we will go further in the next exericse and make it even easier to create Container Registries by creating an IBuilder.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-group/","title":"Container Group","tags":[],"description":"","content":"Overview The Container Group builder is used to create Azure Container Group instances.\n Container Group (Microsoft.ContainerInstance/containerGroups)  Builder Keywords    Keyword Purpose     name Sets the name of the Container Group instance.   image Sets the container image.   ports Sets the ports the container exposes.   cpu_cores Sets the maximum CPU cores the container may use.   memory Sets the maximum gigabytes of memory the container may use.   group_name Sets the name of the container group.   link_to_container_group Links this container to an already-created container group.   os_type Sets the OS type (default Linux).   restart_policy Sets the restart policy (default Always)   public_dns Sets the DNS host label when using a public IP.   private_ip Indicates the container should use a system-assigned private IP address for use in a virtual network.   private_static_ip Sets a static assigned IP address for use in a virtual network   ip_address (Deprecated) Sets the IP addresss (default Public).   network_profile Name of a network profile resource for the subnet in a virtual network where the container group will attach.   add_tcp_port Adds a TCP port to be externally accessible.   add_udp_port Adds a UDP port to be externally accessible.    Example open Farmer open Farmer.Builders let nginx = container { group_name \u0026#34;appWithHttpFrontend\u0026#34; os_type Linux add_tcp_port 80us add_tcp_port 443us restart_policy ContainerGroup.RestartPolicy.Always name \u0026#34;nginx\u0026#34; image \u0026#34;nginx:1.17.6-alpine\u0026#34; ports [ 80us; 443us ] memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 1 } Private Virtual Network Example Attaching a container group to a virtual network requires adding a service delegation on a subnet indicating it is for container groups, adding a network profile to bind the container group interface to that subnet, and finally adding the container group itself with a private IP address.\nopen Farmer open Farmer.Builders let privateNetwork = vnet { name \u0026#34;private-vnet\u0026#34; add_address_spaces [ \u0026#34;10.30.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;ContainerSubnet\u0026#34; prefix \u0026#34;10.30.19.0/24\u0026#34; add_delegations [ SubnetDelegationService.ContainerGroups ] } ] } let aciProfile = networkProfile { name \u0026#34;vnet-aci-profile\u0026#34; vnet \u0026#34;private-vnet\u0026#34; subnet \u0026#34;ContainerSubnet\u0026#34; } let myContainer = container { name \u0026#34;helloworld\u0026#34; image \u0026#34;microsoft/aci-helloworld\u0026#34; network_profile \u0026#34;vnet-aci-profile\u0026#34; ports [ 80us ] private_static_ip \u0026#34;10.30.19.4\u0026#34; [TCP, 80us] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-registry/","title":"Container Registry","tags":[],"description":"","content":"Overview The Container Registry builder is used to create Azure Container Registry (ACR) instances.\n Container Registry (Microsoft.ContainerRegistry/registries)  Builder Keywords    Keyword Purpose     name Sets the name of the Container Registry instance.   sku Sets the SKU of the instance. Defaults to Basic.   enable_admin_user The value that indicates whether the admin user is enabled.    Example open Farmer open Farmer.Builders let myRegistry = containerRegistry { name \u0026#34;myRegistry\u0026#34; sku ContainerRegistry.Basic enable_admin_user } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cognitive-services/","title":"Cognitive Services","tags":[],"description":"","content":"Overview The Cognitive Services builder is used to create Azure Cognitive Services instances.\n Cognitive Services (Microsoft.CognitiveServices/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Cognitive Services instance.   sku Sets the SKU of the instance. Defaults to F0 (free).   api Specifies the API to use for the service instance. Defaults to AllInOne.    Example open Farmer open Farmer.Builders let translator = cognitiveServices { name \u0026#34;mytranslator\u0026#34; sku CognitiveServices.F0 api CognitiveServices.AnomalyDetector } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/parameters/","title":"Parameters and Variables","tags":[],"description":"","content":"ARM templates support the idea both of parameterisation of templates and of the use of variables within a template for e.g. placeholders and re-using values.\nFarmer, by design, has only limited support for parameters and no support for variables. We don\u0026rsquo;t plan on adding rich support for either of these for the following reasons:\n We want to keep the Farmer codebase simple for maintainers We want to keep the Farmer API simple for users We want to keep the generated ARM templates as readable as possible We feel that instead of trying to embed conditional logic and program flow directly inside ARM templates in JSON, if you wish to parameterise your template that you should use a real programming language to do that: in this case, F#.  You can read more on this issue here\nSecure Parameters Farmer does support securestring parameters for e.g. SQL and Virtual Machine passwords - these are automatically generated based on the contents of the template rather than explicitly by yourself.\nFor example, assume the following Farmer SQL resource:\nlet db = sql { server_name \u0026#34;myserver\u0026#34; db_name \u0026#34;mydatabase\u0026#34; admin_username \u0026#34;mradmin\u0026#34; } This will generate an ARM template which looks as follows (irrelevant content is elided for clarity):\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;password-for-myserver\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;securestring\u0026#34; } }, \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2014-04-01-preview\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;myserver\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;administratorLogin\u0026#34;: \u0026#34;mradmin\u0026#34;, \u0026#34;administratorLoginPassword\u0026#34;: \u0026#34;[parameters(\u0026#39;password-for-myserver\u0026#39;)]\u0026#34;, }, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Sql/servers\u0026#34; } ] } Working with variables ARM templates allow you to declare variables inside a template to reuse a value across a template. ARM templates also allow the use of a custom set of a commands which are embedded within strings to generate program logic, using expressions which contain template functions. For example, to concatenate a string inside a ARM template made up of two variables and put into a third variable, you might use something like the following:\n{ \u0026#34;variables\u0026#34;: { \u0026#34;first\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;second\u0026#34;: \u0026#34;World\u0026#34;, \u0026#34;serverName\u0026#34;: \u0026#34;[concat(variables(\u0026#39;first\u0026#39;), \u0026#39; \u0026#39;, variables(\u0026#39;second\u0026#39;), \u0026#39;!\u0026#39;)]\u0026#34; } } In F#, you have access to the full power of .NET, rather than a limited set of weakly-typed functions:\nlet first = \u0026#34;Hello\u0026#34; let second = \u0026#34;World\u0026#34; let serverName = first + \u0026#34; \u0026#34; + second + \u0026#34;!\u0026#34; let dbName = sprintf \u0026#34;%s %s!\u0026#34; first second let db = sql { server_name serverName db_name dbName admin_username \u0026#34;mradmin\u0026#34; } Rapidly creating multiple resources You can also use F# list comprehensions to rapidly create several resources of the same type:\n// Create five SQL servers and databases let myDatabases = [ for i in 1 .. 5 -\u0026gt; sql { server_name (sprintf \u0026#34;server%d\u0026#34; i) db_name (sprintf \u0026#34;database%d\u0026#34; i) admin_username \u0026#34;mradmin\u0026#34; } ] // Add all five databases to the deployment let deployment = arm { location Location.NorthEurope add_resources myDatabases } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/","title":"API Overview","tags":[],"description":"","content":"API aims The key guiding principles of the Farmer API are (in order):\n Simplicity: Make it as easy as possible to do the most common tasks. Type safety: Where possible, use F#\u0026lsquo;s type system to make it impossible to create invalid templates. Flexibility: Provide users with the ability to override the defaults where needed.  Farmer Resources Farmer works on a simple, consistent process:\n You create Farmer resources, such as Storage Accounts and Web Apps. Each Farmer resource can represent one or many ARM resources. For example, a Farmer webApp resource represents both the Microsoft.Web/sites and Microsoft.Web/serverfarms resources. In addition, it optionally also provides simplified access to an Microsoft.Insights/components. You configure each resource using simple, human-readable custom keywords in a strongly-typed environment. You link together resources as required. Once you have created all resources, you bundle them up together into an ARM deployment resource. You then generate (and optionally deploy) an ARM template. The rest of your deployment pipeline stays the same.  The diagram below illustrates how Farmer resources map to ARM ones:\ngraph TD subgraph ARM Template classDef danger fill:orange; C(Microsoft.Web/serverfarms) -. dependency .-F D(Microsoft.Insights/components) -. dependency .-F E(Microsoft.Storage/storageAccounts) -. dependency .-F E -. storage key .- F E -. storage key .- G F(Microsoft.Web/sites) G(blobServices/containers) class C danger class D danger class E danger class F danger class G danger end subgraph Farmer A(webApp)-. depends on .-B B(storageAccount)-. key .-A end  In this example, we create a storage account and web app in Farmer, which maps five different ARM template resources. As you can see, resources in Farmer are declared at a higher level of abstraction than ARM template resources. This makes things much simpler to reason about, and quicker to author.\nAn example Farmer Resource All Farmer resources follow the same approach:\n You define a resource using a special \u0026ldquo;builder\u0026rdquo; that allows the use of custom keywords. This is known as an F# computation expression. Each builder is designed for a specific type of Azure resource e.g. websites, functions, virtual machines etc., and each has defaults set for the most common scenario. This resource is validated and converted into a Farmer configuration object, which contains the configuration for that resource including any defaults. This configuration is then added to an overarching Farmer ARM deployment object. The ARM deployment object is converted into an ARM template json file.  graph LR subgraph JSON C(ARM Template) end subgraph .NET A(Farmer Builder)--validation and defaults --B B(Farmer Configuration) --emitted to -- C end  Here\u0026rsquo;s an example web application.\nlet myWebApp = webApp { name \u0026#34;mystorage\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku Sku.B1 always_on app_insights_off worker_size WorkerSize.Medium number_of_workers 3 run_from_package }  The webApp { } builder defines the start and end of the definition of the web application. Within this builder, you use custom keywords to configure the web app, such as name and setting. Some keywords take arguments, but others e.g. always_on are simple declarative markers.   You can view details of all farmer resources in the resource guide.\n Putting it all together The diagram above can be shown in code as follows:\n/// An Azure Storage account with a container. let storage = storageAccount { name \u0026#34;astorageaccount\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } /// An Azure App Service with built-in App Insights. let app = webApp { name \u0026#34;awebapp\u0026#34; setting \u0026#34;storageKey\u0026#34; storage.Key // pull in the storage key to an app setting  depends_on storage // state that this web app depends on the storage account } /// An ARM deployment with both of the above resources attached let deployment = arm { location Location.NorthEurope add_resource storage add_resource app } // Write the ARM template out to myTemplate.json let filename = deployment.Template |\u0026gt; Writer.toJson |\u0026gt; Writer.toFile \u0026#34;myTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cosmosdb/","title":"Cosmos DB","tags":[],"description":"","content":"Overview The CosmosDb package containers two builders, used to create databases and containers.\n CosmosDB Account (Microsoft.DocumentDb/databaseAccounts) CosmosDB SQL (\u0026quot;Microsoft.DocumentDB/databaseAccounts/sqlDatabases) CosmosDB SQL Container (Microsoft.DocumentDb/databaseAccounts/sqlDatabases/containers)   There is currently only support for document databases (the so-called \u0026ldquo;SQL API\u0026rdquo;), with support for Gremlin, Table and Cassandra data models planned.\n Cosmos DB Builder The CosmosDB builder abstracts the idea of account and database into one. If you wish to \u0026ldquo;re-use\u0026rdquo; an already-created Cosmos DB account, use link_to_account keyword - no account will be created and the database will be attached to the existing one.\n   Applies To Keyword Purpose     Database name Sets the name of the database.   Database link_to_account Instructs Farmer to link this database to an existing Cosmos DB account rather than creating a new one.   Database throughput Sets the throughput of the account.   Database add_containers Adds a list of containers to the database.   Account account_name Sets the name of the CosmosDB account.   Account api (not yet implemented) Sets the API and data model to use \u0026ndash; currently defaults to \u0026ldquo;Core (SQL)\u0026quot;.   Account enable_public_network_access Enables public network access for the account.   Account disable_public_network_access Disables public network access for the account.   Account consistency_policy Sets the consistency policy of the database.   Account failover_policy Sets the failover policy of the database.   Account free_tier Registers this server with the free pricing tier, if supported and allowed by Azure.    Cosmos Container Builder The container builder allows you to create and configure a specific container that is attached to a cosmos database.\n   Keyword Purpose     name Sets the name of the container.   partition_key Sets the partition key of the container.   add_index Adds an index to the container.   exclude_path Excludes a path from the container index.    Example open Farmer open Farmer.Builders let myCosmosDb = cosmosDb { name \u0026#34;isaacsappdb\u0026#34; account_name \u0026#34;isaacscosmosdb\u0026#34; throughput 400 failover_policy CosmosDb.NoFailover consistency_policy (CosmosDb.BoundedStaleness(500, 1000)) add_containers [ cosmosContainer { name \u0026#34;myContainer\u0026#34; partition_key [ \u0026#34;/id\u0026#34; ] CosmosDb.Hash add_index \u0026#34;/path\u0026#34; [ CosmosDb.Number, CosmosDb.Hash ] exclude_path \u0026#34;/excluded/*\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-3/","title":"Deploying to Azure","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll update the application to deploy the generated ARM template to Azure directly from Farmer.\n Farmer generates normal ARM templates. You use all of the standard mechanisms for deploying ARM templates such as through the portal, Powershell, .NET or Azure CLI etc. This tutorial shows you a simple way to deploy templates from your development machine directly from within F#.\n Install the Azure CLI If you haven\u0026rsquo;t done so already, install the Azure CLI on your machine.\nDeploy the template As Farmer emits standard ARM templates, you can use all the standard ARM template deployment tools at your disposal - whether that\u0026rsquo;s Visual Studio, Powershell, or the Azure CLI. In our case, we can also use Farmer\u0026rsquo;s API which wraps around the Azure CLI.\nModify the application you created at the end of quickstart #2 so that instead of writing the template to a file, we deploy it directly:\ndeployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters  Note that the Web Application and Storage Account names should be globally unique; they must be unique across Azure i.e. someone else can\u0026rsquo;t have another web app or storage account with the same name!\n Farmer will now create the ARM template, and also generate a batch / shell script which calls the Azure CLI. You\u0026rsquo;ll be prompted to login to Azure by the CLI, after which point it will create the named resource group in the location specified in the arm { } builder.\nWait until the process is completed and log into the Azure Portal. Navigate to the newly-created resource group and inspect the overview record list e.g.\nCongratulations - you\u0026rsquo;ve now created and deployed an ARM template entirely from F#!\nThe full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorageaccount\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key depends_on myStorageAccount.Name } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/3-ibuilder/","title":"3. The IBuilder interface","tags":[],"description":"","content":"Sometimes, ARM resources are captured at a level of abstraction that is too low for us to reason about. In such cases, we\nAn IBuilder is not only even easier to consume by users than the F# record above, but can create multiple IArmResource objects at once. This is especially useful for more complex resources that tend to come in groups of two or three together - for example, Server Farm and Web Apps, or Cosmos DB Accounts, Databases and Containers. An IBuilder encapsulates the logic needed to create and configure all the resources together.\n In this example, the Container Registry builder only creates a single resource.\n Step 3.1: The Configuration Record The first step is to create a simple configuration record that contains any data that is required to be captured by the user. Often, this may map nearly 1:1 with the IArmResource - normally the main difference will be that you do not need to provide the Location here, as Farmer will automatically provide that for you.\n// src/Farmer/Builders.ContainerRegistry.fs type ContainerRegistryConfig = { Name : ResourceName Sku : Sku AdminUserEnabled : bool } interface IBuilder with member this.DependencyName = this.Name member this.BuildResources location _ = [ { Name = this.Name Location = location Sku = this.Sku AdminUserEnabled = this.AdminUserEnabled } The IBuilder interface has two methods:\n DependencyName - this is the name of the resource. It\u0026rsquo;s used by Farmer when setting dependencies between multiple resources. BuildResources - this functions takes in two arguments: the location the resources should be deployed to, and a list of any existing resources that have been created so far. Normally, you can ignore the second argument. The method should return the list of IArmResource resources that must be created - as you can see, this is a relatively simple mapping. For more complex builders e.g. one which represent multiple IArmResources at once, your BuildResources function will emit a list of IArmResources.   It\u0026rsquo;s tempting to suggest simply applying IBuilder directly onto the IArmResource. You could probably do this, but the separation and clarity provided here is an important step, and gives freedom in the future to diverge the shapes of the builder and the resource.\n Step 3.2 Test out the IBuilder. You can finish this exercise by confirming that your IBuilder works correctly:\nopen Farmer.Builders.ContainerRegistry let registries = { Name = ResourceName \u0026#34;my-registry\u0026#34; Sku = ContainerRegistry.Basic AdminUserEnabled = true } let deployment = arm { location Location.WestEurope add_resource registries } deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34;  Ensure that the location of WestEurope has been correctly applied to the emitted ARM template json file!\n "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/data-lake/","title":"Data Lake","tags":[],"description":"","content":"Overview The Data Lake builder is used to create Azure Data Lake instances.\n Data Lake (Microsoft.DataLakeStore/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Cognitive Services instance.   sku Sets the SKU of the instance. Defaults to Consumption.   enable_encryption Turns on data lake encryption.    Example open Farmer open Farmer.Builders let myLake = dataLake { name \u0026#34;myDataLake\u0026#34; sku DataLake.Commitment_100TB enable_encryption } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/expressions/","title":"ARM Expressions","tags":[],"description":"","content":"ARM template expressions are a way of safely storing string values which contain expressions that are evaluated at deployment time by the Azure. ARM expressions can also contain a set of predefined functions supported by the ARM runtime. They can be passed back as outputs and used further downstream\nFarmer understands how to use ARM expressions and provides functionality to correctly wrap and unwrap them as raw strings into a JSON template.\n For manipulation of literal values that are known in your Farmer applications, you will not need to use ARM expressions. To manipulate such values, you can use standard F# and .NET capabilities.\n How do I use ARM expressions? Many Farmer builders contain pre-defined ARM expression that can be used for common tasks, such as passing a connection string from a storage account as a KeyVault secret, or a web application setting.\nAs an example, a Storage Account config contains a Key member that you can supply this to a web app as a setting:\nlet storageConfig = storageAccount { name \u0026#34;myStorageAccount\u0026#34; } let webAppConfig = webApp { name \u0026#34;myWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; storageConfig.Key } This will be written to the ARM template file as follows:\n\u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=myStorageAccount;AccountKey=\u0026#39;, listKeys(\u0026#39;myStorageAccount\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } Using ARM expressions means that you can deploy an application which is automatically configured at deployment time. This means that you never need to store an application secret such as a storage account key in source control, or even e.g. as a secret variable in your build / deployment process.\nReturning the value of ARM Expressions as outputs. ARM Expressions can also be passed back as outputs and used further downstream once your deployment is complete:\nlet template = arm { location Location.WestEurope add_resource storageConfig // Mark the storage_key as an output in the ARM template.  output \u0026#34;storage_key\u0026#34; storageConfig.Key } // Deploy the template. let outputs = template |\u0026gt; Deploy.execute template [] // Get the value of the storage_key. let key = outputs.[\u0026#34;storage_key\u0026#34;] Be aware though, that the value of the storage_key is visible as a plain text value in the output - so anyone with access to, for example, the Azure portal will be able to see the values of the storage key if they look at the deployment history.\n"},{"uri":"https://compositionalit.github.io/farmer/deployment-guidance/","title":"Deployment Guidance","tags":[],"description":"","content":"You can deploy Farmer templates in a number of ways, depending on how you would prefer to work with ARM templates and tooling.\nOption 1: \u0026ldquo;ARM templates are just a means to an end to me\u0026rdquo; If you don\u0026rsquo;t use ARM templates today, or don\u0026rsquo;t need to edit them directly, you can opt to do away with them completely. You\u0026rsquo;ll create Farmer applications which use a simple F# SDK to interact with Azure; Farmer will create ARM templates in the background for you transparently, so you\u0026rsquo;ll never see or interact with them.\nIn such a case, you can opt to deploy directly through Farmer. This mode provides an F# wrapper around the Azure CLI which captures your credentials during the deployment process.\nIf you\u0026rsquo;re looking to stay within F# and e.g. respond to outcomes from the deployment such as using deployment outputs, this is an excellent option because Farmer is just a dotnet application and the deployment call is a simple function call.\nAnother benefit of this is because Farmer is a simple .NET Standard library, you can use it natively within .NET build tools such as FAKE or CAKE.\nCombined Resource and Application Deployment Farmer can also optionally do more for you by handling the entire deployment process, including deployment of your application artifacts.\ngraph LR subgraph Azure Resource Group D(Azure App Service) end subgraph JSON C(ARM Template) -- REST API or Azure CLI -- D end subgraph .NET A(Farmer)-- resources emitted to -- C A -. your application deployed via ZIP Deploy.- D end  Watch this short video to see more!\n  Option 2: \u0026ldquo;I already have an ARM deployment strategy\u0026rdquo; If you already use ARM templates, you\u0026rsquo;ll probably already have a strategy for working with templates and deploying them to Azure, such as PowerShell, the Azure CLI or a build system such as Azure DevOps or Octopus Deploy. In such a case, you may want to use Farmer to generate, but not deploy, your ARM templates.\nOption 3: \u0026ldquo;I want to hand-craft my ARM templates\u0026rdquo; If you want to retain fine-grained control over ARM templates, you can use Farmer to create a one-off task to rapidly generate an ARM template which you then take ownership of. In this case, Farmer itself won\u0026rsquo;t be a part of your build / deploy chain, which will remain the same as today - you\u0026rsquo;ll use Farmer just as an edit-time task to create an ARM template itself which you will then manually modify.\nThe choice is yours.\nHow do I create a Service Principal? If you\u0026rsquo;re trying to deploy to Azure in an automated fashion, you may need to create a Service Principal account that has permissions in Azure to deploy ARM templates on your behalf.\nThe Azure CLI provides a simple way to create one using the az ad sp command:\naz ad sp create-for-rbac --name farmer-deploy This will provide output similar to the following:\n{ \u0026#34;appId\u0026#34;: \u0026#34;1181c21b-78f3-42b3-a26d-03ba75c7b674\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;farmer-deploy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;http://farmer-deploy\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;4aa3b120-f2b2-4ea9-941b-5891fef0ef11\u0026#34;, \u0026#34;tenant\u0026#34;: \u0026#34;aa7f7453-15af-4ab0-5d41-aeb4a25293bc\u0026#34; } The mapping from these fields to the credentials used in Farmer\u0026rsquo;s authenticate function are:\n   Azure CLI Farmer     appId appId   password secret   tenant tenantId    You should store these credentials in a secure store, such as your CI/CD service or e.g. Azure KeyVault and should avoid committing them into source control.\n"},{"uri":"https://compositionalit.github.io/farmer/quickstarts/template/","title":"The Farmer .NET Template","tags":[],"description":"","content":"Farmer comes with a .NET template that makes getting started easy.\nCreating a basic Farmer app The easiest way to create a Farmer app is to use the Farmer .NET Template.\ndotnet new -i Farmer.Template dotnet new Farmer  You only have to install the template once on your machine!\n This creates a new dotnet application solution and project that looks by default as follows:\nopen Farmer open Farmer.Builders let deployment = arm { location Location.NorthEurope } printf \u0026#34;Generating ARM template...\u0026#34; deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34; printfn \u0026#34;all done! Template written to output.json\u0026#34; From here, you can add resources in the normal manner.\nBasic configuration options You can configure the template using the following optional arguments.\nARM Template filename The name of the ARM template JSON file e.g. --armTemplate myTemplate\nLocation The location to create resources in e.g. --location WestUS\nDeploy Configuration You can also configure the Farmer template to deploy to Azure out of the box using the --ci option. This has two modes of operation:\nAzure DevOps deployment This comes with a ready-made devops YAML file designed for simple CI/CD, using Farmer to generate ARM templates and Azdo to deploy using its own ARM Template deployment process. You should supply the following arguments:\n \u0026ndash;ci: Tells the template to create a Farmer app for use with Azure Devops. \u0026ndash;azureSubscription: Set the full name of the Azure Subscription that has been already configured in Azdo that has permission to deploy templates to Azure. \u0026ndash;resourceGroup: Set the name of the resource group that you wish to deploy to.  Direct deployment If you prefer a deployment process that is not coupled to Azure Devops, you can create a service principle in Azure and use the generated credentials in Farmer. Farmer will use its own wrapper around the Azure REST API to deploy to Azure, reporting progress to the console.\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/4-creating-builder-syntax/","title":"4. Providing Builder syntax","tags":[],"description":"","content":"If you want to get the nice json-like syntax for your configuration record, you need to implement a separate class which contains a set of methods that act on the Configuration Record that you created previously - one for each keyword that you want.\n If you need have not built your own computation expression before, here are some resources to brush up:\n Office microsoft docs The \u0026ldquo;Computation Expressions\u0026rdquo; series Workshop   Step 4.1: Creating basic keywords We will not cover the inner details of creating a CE here. But to get started the only member you need to implement id Yield, which returns a minimal implementation of your resource.\n// Builder.ContainerRegistry.fs type ContainerRegistryBuilder() = /// Required - creates default \u0026#34;starting\u0026#34; values  member _.Yield _ = { Name = ResourceName.Empty Sku = Basic AdminUserEnabled = false } [\u0026lt;CustomOperation \u0026#34;name\u0026#34;\u0026gt;] /// Sets the name of the Azure Container Registry instance.  member _.Name (state:ContainerRegistryConfig, name) = { state with Name = ResourceName name } [\u0026lt;CustomOperation \u0026#34;sku\u0026#34;\u0026gt;] /// Sets the name of the SKU/Tier for the Container Registry instance.  member _.Sku (state:ContainerRegistryConfig, sku) = { state with Sku = sku } [\u0026lt;CustomOperation \u0026#34;enable_admin_user\u0026#34;\u0026gt;] /// Enables the admin user on the Azure Container Registry.  member _.EnableAdminUser (state:ContainerRegistryConfig) = { state with AdminUserEnabled = true } let containerRegistry = ContainerRegistryBuilder() Each keyword has a similar set of steps required:\n Create a member which takes in at least one argument, the current state object. The implement should perform some modification and return back the newly-updated state. Decorate the method with the CustomOperation attribute; the string value passed to it will become the keyword name. Use _ to separate words of the keyword e.g. enable_admin_user. Put a /// comment on the method for intellisense to guide users.  Now you can create members on the builder that appear as custom operators in your resource CE. In each member you build up the state of the resource configuration you created in the previous step.\n Don\u0026rsquo;t forget to assign an instance of the builder to a value so it is available for consumers!\n Parameterless keywords You can create parameterless keywords by simply only taking in the state argument e.g. enable_admin_user above.\nKeywords with multiple arguments You can take in multiple arguments by simply putting a comma after each additional argument. They will be consumed by the user with spaces.\nOverloaded keywords You can provide multiple overloads for a keyword. However, each overload must take in the same number of arguments. Do not re-apply the CustomOperation attribute - simply provide multiple methods with the same name.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/expressroute/","title":"ExpressRoute","tags":[],"description":"","content":"Overview An ExpressRoute circuit is a dedicated link to Azure to provide communication with Azure services without traversing the Internet. It requires some coordination with a networking provider for these circuits, so some information, such as the service provider and peering location must be obtained from Azure reference documentation. The ExpressRoute builder creates an ExpressRoute circuit and enables Azure private peering and Microsoft peering.\n ExpressRoute Namespace (Microsoft.Network/expressRouteCircuits)  Builder Keywords    Applies To Keyword Purpose     ExpressRoute service_provider Connectivity service provider from Azure reference documentation   ExpressRoute peering_location Connectivity peering location from Azure reference documentation   ExpressRoute tier Standard or Premium   ExpressRoute family Metered or Unlimited data   ExpressRoute bandwidth Bandwidth in Mbps for the circuit   ExpressRoute add_peering Peering details for the circuit - can add Azure Private and Microsoft peerings   Peering peering_type A network CIDR block of 4 IP addresses (/30) for the ExpressRoute primary circuit   Peering peer_asn Peer Autonomous System Number - this is a uniquely assigned number for the peer network, typically provided by the service provider in agreement with Microsoft   Peering azure_asn Azure Autonomous System Number - Microsoft oftent uses AS 12076 for Azure public, Azure private and Microsoft peering   Peering primary_prefix A network CIDR block of 4 IP addresses (/30) for the ExpressRoute primary circuit   Peering secondary_prefix A network CIDR block of 4 IP addresses (/30) for the ExpressRoute secondary circuit   Peering vlan A unique VLAN ID for the peering   Peering shared_key An optional shared key the service provider may specify for the peering    Example open Farmer open Farmer.Builders open Farmer.ExpressRoute let circuit = expressRoute { name \u0026#34;my-express-route\u0026#34; service_provider \u0026#34;Equinix\u0026#34; peering_location \u0026#34;New York\u0026#34; tier Premium family MeteredData bandwidth 1000\u0026lt;Mbps\u0026gt; add_peering ( peering { peering_type AzurePrivatePeering peer_asn 55277L azure_asn 12076 primary_prefix (IPAddressCidr.parse \u0026#34;10.254.12.0/30\u0026#34;) secondary_prefix (IPAddressCidr.parse \u0026#34;10.254.12.4/30\u0026#34;) vlan 2406 } ) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/eventhub/","title":"Event Hub","tags":[],"description":"","content":"Overview The Event Hub builder creates event hub namespaces, event hubs, consumer groups and authorization rules in a single builder.\n Event Hub Namespace (Microsoft.EventHub/namespaces) Event Hub (Microsoft.EventHub/namespaces/eventhubs) Consumer Group (Microsoft.EventHub/namespaces/eventhubs/consumergroups) Authorization Rule (Microsoft.EventHub/namespaces/eventhubs/AuthorizationRules\u0026quot;)   The Event Hub builder works in a similar fashion to the web app builder in that it automatically creates the host (in this case, the event hub namespace) when creating the event hub. If you wish to create multiple hubs in the same namespace, configure the namespace-level properties in the first event hub; subsequent event hubs should link to the namespace of the hub created by the first hub.\n Builder Keywords    Applies To Keyword Purpose     Namespace namespace_name Sets the name of the event hub namespace, if you are creating the namespace along with the hub.   Namespace sku Sets the SKU of the event hub namespace.   Namespace capacity Sets the capacity of the event hub namespace (see here for more details)   Namespace enable_zone_redundant Enables zone redundancy on the event hub namespace.   Namespace enable_auto_inflate Enables auto inflate throughput; you must supply the maximum throughput level.   Namespace disable_auto_inflate Disables auto inflate throughput.   Namespace disable_kafka Disables Kafka support.   Event Hub name Sets the name of the event hub.   Event Hub message_retention_days Sets the number of days to retain messages for on the event hub.   Event Hub partitions Sets the number of partitions on the event hub.   Event Hub add_consumer_group Creates a consumer group for the event hub.   Event Hub add_authorization_rule Adds a named authorization rule on the event hub.   Event Hub link_to_namespace Sets the name of an existing or already-defined event hub namespace that this event hub should link to.    Configuration Members    Member Purpose     DefaultKey Gets an ARM expression for the root namespace key of the Event Hub namespace.   GetKey Gets an ARM expression for a named key on this event hub.    Example open Farmer open Farmer.Builders let primaryHub = eventHub { namespace_name \u0026#34;allmyevents\u0026#34; sku EventHub.Standard disable_kafka enable_zone_redundant enable_auto_inflate 3 add_authorization_rule \u0026#34;FirstRule\u0026#34; [ EventHub.Listen; EventHub.Send ] add_authorization_rule \u0026#34;SecondRule\u0026#34; AllAuthorizationRights name \u0026#34;first-hub\u0026#34; partitions 2 message_retention_days 3 add_consumer_group \u0026#34;myGroup\u0026#34; } let secondHub = eventHub { name \u0026#34;second-hub\u0026#34; link_to_namespace \u0026#34;allmyevents\u0026#34; partitions 1 message_retention_days 1 } "},{"uri":"https://compositionalit.github.io/farmer/faq/","title":"FAQs","tags":[],"description":"","content":"How can I help? Try out Farmer and see what you think.\n Create as many issues as you can for both bugs, discussions and features Create suggestions for features and the most important elements you would like to see added  I have an Azure subscription, but I\u0026rsquo;m not an expert. I like the look of this - how do I \u0026ldquo;use\u0026rdquo; it?  Create an ARM template using the Farmer sample app. Follow the steps here to deploy the generated template into Azure. Log any issues or ideas that you find here.  How do I get Farmer to work from a continuous deployment (CD) process?  Look at some of the alternative strategies outlined here. Read up on ARM deployment strategies e.g. Azure Devops have guides here.  The Farmer .NET Template also has support for creating a Azure Devops-ready application from scratch.\nI don\u0026rsquo;t know F#. Would you consider writing a C# version of this? I\u0026rsquo;m afraid not. F# isn\u0026rsquo;t hard to learn (especially for simple DSLs such as this), and you can easily integrate F# applications as part of a dotnet solution, since F# is a first-class citizen of the dotnet core ecosystem. You can even create new resources in C# since the core abstractions of Farmer are two simple .NET interfaces.\nAre you trying to replace ARM templates? No, we\u0026rsquo;re not. Farmer generates ARM templates that can be used just as normal; Farmer can also be used simplify to make the process of getting started much simpler, or incorporated into your build pipeline as a way to avoid managing difficult-to-manage ARM templates and instead use them as the final part of your build / release pipeline.\nAre you trying to compete with Pulumi? No, we\u0026rsquo;re not. Farmer has (at least currently) a specific goal in mind, which is to lower the barrier to entry for creating and working with ARM templates that are non-complex. We\u0026rsquo;re not looking to create a cross-platform DSL to also support things like Terraform etc. or provide a stateful service store that Pulumi offers. Instead, Farmer is a simple way to continue to use ARM templates today but benefit from a more rapid authoring and maintenance process.\nThere\u0026rsquo;s no support for variables or parameters! Farmer intentionally has limited support for ARM parameters and variables. Read here to find out the alternatives.\nCan I add resources that are not supported by Farmer? Yes. You can use some adapters that Farmer provides to generate resources using basic .NET objects, or even paste ARM template JSON directly into Farmer and have that embedded inside!\nThe resource I need isn\u0026rsquo;t included! Create an issue on our github repository, ideally with a sample ARM template and a link to the official Microsoft documentation on the resource. We can\u0026rsquo;t promise we\u0026rsquo;ll look at it immediately, but raising the issue is an important first step to getting more resources supported.\nBut our organisation really needs that resource enhancement today! Drop us an email explaining what you need; we\u0026rsquo;re happy to discuss a commercial support arrangement to provide you with features that you need in a more timely fashion.\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/5-unit-testing/","title":"5. Unit Testing","tags":[],"description":"","content":"Usually I would be pro writing the tests before you implement all this but it is important to get a feel for the moving parts. At this point you may want to write some tests so you can iterate quickly on getting the structure of your ARM template correct.\nThe tests you will find in the project are black-box style tests that focus on the input of a resource and the output of the ARM template. If you want to create tests for your mapping functions that is fine but remember between the strong type system and making it difficult to have null values, those kind of tests seldom yield much benefit in F#.\nOf course, unit tests can only tell you so much when dealing with something as complex as Azure. Create a fsx file to run to check that your resource is deploying as expected.\n// container-registry.fsx #r \u0026#34;Newtonsoft.Json.dll\u0026#34; #r @\u0026#34;../Farmer/bin/Debug/netstandard2.0/Farmer.dll\u0026#34; open Farmer open Farmer.Resources.ContainerRegistry let myRegistry = containerRegistry { name \u0026#34;devonRegistry\u0026#34; sku ContainerRegistrySku.Basic enable_admin_user } let deployment = arm { location NorthEurope add_resource myRegistry output \u0026#34;registry\u0026#34; myRegistry.Name output \u0026#34;loginServer\u0026#34; myRegistry.LoginServer } deployment |\u0026gt; Deploy.execute \u0026#34;FarmerTest\u0026#34; Deploy.NoParameters |\u0026gt; printfn \u0026#34;%A\u0026#34; Create a Resource Group to run it, here I called it \u0026ldquo;FarmerTest\u0026rdquo;.\nRun dotnet fsi container-registry.fsx\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/functions/","title":"Functions","tags":[],"description":"","content":"Overview The Functions builder is used to create Azure Functions accounts. It abstracts the App Host and Service Plan into the same component, and will also create and configure a linked App Insights resource. In addition, it will automatically create a backing storage account required by the functions runtime.\n Web Site (Microsoft.Web/sites) Web Host (Microsoft.Web/serverfarms) Application Insights (Microsoft.Insights/components) Storage Accounts (Microsoft.Storage/storageAccounts)  Builder Keywords    Keyword Purpose     name Sets the name of the functions instance.   service_plan_name Sets the name of the service plan hosting the function instance.   link_to_service_plan Instructs Farmer to link this webapp to an existing service plan rather than creating a new one.   link_to_storage_account Do not create an automatic storage account; instead, link to a storage account that is created outside of this Functions instance.   https_only Disables http for this functions app so that only HTTPS is used.   app_insights_auto_name Sets the name of the automatically-created app insights instance.   app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   link_to_app_insights Instead of creating a new AI instance, configure this webapp to point to another AI instance that you are managing yourself.   use_runtime Sets the runtime of the Functions host.   use_extension_version Sets the extension version of the functions host.   operating_system Sets the operating system of the Functions host.   setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   settings Sets a list of app setting of the web app as tuples in the form of (\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;).   depends_on Sets a dependency for the web app.   enable_cors Enables CORS support for the app. Either specify AllOrigins or a list of valid URIs.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this functions app.   StorageAccountKey Gets the ARM expression path to the storage account key of this functions app.   AppInsightsKey Gets the ARM expression path to the app insights key of this functions app, if it exists.   DefaultKey Gets the ARM expression path for the default key of this functions app.   MasterKey Gets the ARM expression path for the master key of this functions app.    Example open Farmer open Farmer.Builders let myFunctions = functions { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; app_insights_off } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/iot-hub/","title":"IOT Hub","tags":[],"description":"","content":"Overview The IOT Hub builder creates IOT Hub and linked Provision Services.\n IOT Hubs (Microsoft.Devices/IotHubs) Provisioning Services (Microsoft.Devices/provisioningServices)  Builder Keywords    Keyword Purpose     name Specifies the name of the IOT Hub   sku Sets the SKU of the IOT Hub   capacity Sets the name of the capacity for the IOT Hub instance   partition_count Sets the name of the SKU/Tier for the IOT Hub instance   retention_days Sets the name of the SKU/Tier for the IOT Hub instance   enable_device_provisioning Sets the name of the SKU/Tier for the IOT Hub instance    Configuration Members    Member Purpose     GetKey Returns an ARM expression to retrieve the IOT Hub key for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.   GetConnectionString Returns an ARM expression to generate an IOT Hub connection string for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let hub = iotHub { name \u0026#34;yourhubname\u0026#34; sku IotHub.B1 capacity 2 partition_count 2 retention_days 3 enable_device_provisioning } let deployment = arm { location Location.NorthEurope add_resource hub output \u0026#34;iot_key\u0026#34; (hub.GetKey IotHub.IotHubOwner) output \u0026#34;iot_connection\u0026#34; (hub.GetConnectionString IotHub.RegistryReadWrite) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/keyvault/","title":"Key Vault","tags":[],"description":"","content":"Overview The KeyVault package contains three builders, for the different components used by KeyVault: One for access policies, one for secrets, and one for the overall keyvault container.\n KeyVault (Microsoft.KeyVault/vaults) Secrets (Microsoft.KeyVault/vaults/secrets)  Secret Builder The secret builder allows you to store secrets into key vault. Values for a secret are passed by Secure String parameters.\n   Keyword Purpose     name Sets the name of the secret.   value Sets the name of the secure string parameter that will contain the value of the secret.   content_type Sets the content type of the secret.   enable_secret Enables the secret.   disable_secret Disables the secret.   activation_date Sets the activation date of the secret.   expiration_date Sets the expiration date of the secret.   depends_on Provides dependencies of the key vault.    Access Policy Builder The Access Policy builder allows you to create access policies for key vault.\n   Keyword Purpose     object_id Sets the Object ID of the permission set.   application_id Sets the Application ID of the permission set.   key_permissions Sets the Key permissions of the permission set.   storage_permissions Sets the Storage permissions of the permission set.   secret_permissions Sets the Secret permissions of the permission set.   certificate_permissions Sets the Certificate permissions of the permission set.    Key Vault Builder The Key Vault builder contains access policies, secrets, and configuration information to create a full key vault account.\n   Keyword Purpose     name Sets the name of the vault.   sku Sets the sku of the vault.   tenant_id Sets the Tenant ID of the vault.   enable_vm_access Allows VM access to the vault.   disable_vm_access Disallows VM access to the vault.   enable_resource_manager_access Allows Resource Manager access to the vault.   disable_resource_manager_access Disallows Resource Manager access to the vault.   enable_disk_encryption_access Allows Azure Disk Encyption service access to the vault.   disable_disk_encryption_access Disallows Azure Disk Encyption service access to the vault.   enable_soft_delete Enables VM access to the vault.   enable_soft_delete_with_purge_protection Disables VM access to the vault.   uri Sets the URI of the vault.   enable_recovery_mode Sets the Creation Mode to Recovery.   disable_recovery_mode Sets the Creation Mode to Default.   add_access_policy Adds an access policy to the vault.   add_access_policies Adds access policies to the vault.   enable_azure_services_bypass Allows Azure traffic can bypass network rules.   disable_azure_services_bypass Disallows Azure traffic can bypass network rules.   allow_default_traffic Allow traffic if no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   deny_default_traffic Deny traffic when no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   add_ip_rule Adds an IP address rule. This can be an IPv4 address range in CIDR notation, such as \u0026lsquo;124.56.78.91\u0026rsquo; (simple IP address) or \u0026lsquo;124.56.78.0/24\u0026rsquo; (all addresses that start with 124.56.78).   add_vnet_rule Adds a virtual network rule. This is the full resource id of a vnet subnet, such as \u0026lsquo;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026rsquo;.   add_secret Adds a secret to the vault. This can either be a \u0026ldquo;full\u0026rdquo; secret config created using the Secret Builder, a string literal value which represents the parameter name, or a string literal with a resource and an expression based on that resource e.g. a storage account and the Key member.   add_secrets Adds multiple secrets to the vault. This can either be \u0026ldquo;full\u0026rdquo; secret configs created using the Secret Builder, string literal values which represents the parameter name.    Utilities  The KeyVault module comes with a set of utility functions to quickly create access policies if you do not wish to use the AccessPolicy builder, in the Farmer.KeyVault.AccessPolicy module which enable creating an access policy for a PrincipalId or an ObjectId which will have the GET Secret permission. In addition, the AccessPolicy module also contains helpers to search for users or groups in active directory (requires Azure CLI installed), as well as their Object IDs. These can be used to rapidly create Access Policies for specific users.  Example open Farmer open Farmer.Builders open System let policy = accessPolicy { object_id Guid.Empty application_id Guid.Empty certificate_permissions [ KeyVault.Certificate.List ] secret_permissions KeyVault.Secret.All key_permissions [ KeyVault.Key.List ] } let complexSecret = secret { name \u0026#34;myComplexSecret\u0026#34; content_type \u0026#34;application/text\u0026#34; enable_secret activation_date (DateTime.Today.AddDays -1.) expiration_date (DateTime.Today.AddDays 1.) } let vault = keyVault { name \u0026#34;MyVault\u0026#34; sku KeyVault.KeyVaultSku.Standard tenant_id Guid.Empty enable_disk_encryption_access enable_resource_manager_access enable_soft_delete_with_purge_protection disable_vm_access enable_recovery_mode add_access_policy policy enable_azure_services_bypass add_ip_rule \u0026#34;127.0.0.1\u0026#34; add_vnet_rule \u0026#34;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026#34; allow_default_traffic add_secret complexSecret add_secret \u0026#34;simpleSecret\u0026#34; add_secrets [ \u0026#34;firstSecret\u0026#34;; \u0026#34;secondSecret\u0026#34;] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/maps/","title":"Maps","tags":[],"description":"","content":"Overview The Maps builder creates Azure Maps accounts.\n Maps (Microsoft.Maps/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Maps account.   sku Sets the sku of the Azure Maps account.    Example open Farmer open Farmer.Builders let myMaps = maps { name \u0026#34;mymaps\u0026#34; sku Maps.S0 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/redis/","title":"Redis Cache","tags":[],"description":"","content":"Overview The Redis builder creates managed Redis Cache accounts.\n Redis (Microsoft.Cache/redis)  Builder Keywords    Keyword Purpose     name Sets the name of the Redis cache instance.   sku Sets the sku of the Redis cache instance.   capacity Sets the capacity level of the Redis cache instance, should be between 1-6 - see here.   enable_non_ssl_port Enabled access to the cache over the non-SSL port.   setting Allows you to set a Redis-cache specific setting at deployment-time    Configuration Members    Member Purpose     Key Gets an ARM expression for the primary key of the Redis cache instance.    Example open Farmer open Farmer.Builders.Redis let myCache = redis { name \u0026#34;myredis\u0026#34; sku Redis.Standard capacity 1 enable_non_ssl_port setting \u0026#34;maxclients\u0026#34; 256 setting \u0026#34;maxmemory-reserved\u0026#34; 2 setting \u0026#34;maxfragmentationmemory-reserved\u0026#34; 12 setting \u0026#34;maxmemory-delta\u0026#34; 2 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/signalr/","title":"SignalR","tags":[],"description":"","content":"Overview The SignalR builder creates SignalR services.\n SignalR Service (Microsoft.SignalRService/signalR)  Builder Keywords    Keyword Purpose     name Sets the name of the SignalR service.   sku Sets the sku of the SignalR service.   capacity Sets the capacity of the SignalR service. (optional)   allowed_origins Sets the allowed origins of the SignalR service. (optional)    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the primary connection string of the service. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let mySignalR = signalR { name \u0026#34;mysignalr\u0026#34; sku SignalR.Standard capacity 10 allowed_origins [ \u0026#34;https://github.com\u0026#34; ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/postgresql/","title":"PostgreSQL","tags":[],"description":"","content":"Overview The PostreSQL builder is used to create Azure Database Service for PostreSQL servers and databases. Every SQL PostgreSQL server you create will automatically create a SecureString parameter for the admin account password. If you wish to create a PostgreSQL database attached to an existing server, use the link_to_server keyword and supply the resource name of the existing server.\n PostgreSQL server (Microsoft.DBforPostgreSQL/servers)  Builder keywords    Applies To Keyword Purpose     Server server_name (string) Sets the name of the SQL server.   Server admin_username (string) Sets the admin username of the server.   Server geo_redundant_backup (bool) Enables/disables geo-redundant backup   Server enable_geo_redundant_backup Enables geo-redundant backup   Server disable_geo_redundant_backup Disables geo-redundant backup   Server storage_autogrow (bool) Enables/disables auto-grow storage   Server enable_storage_autogrow Enables auto-grow storage   Server disable_storage_autogrow Disables auto-grow storage   Server storage_size (int\u0026lt;Gb\u0026gt;) Sets the initial size of the storage available   Server backup_retention (int\u0026lt;Days\u0026gt;) Sets the number of days to keep backups   Server server_version (Version) Selects the PoistgreSQL version of the server   Server capacity (int\u0026lt;VCores\u0026gt;) Sets the number of cores for the server   Server tier (Sku) Sets the service tier of the server   Server db_name (string) Sets the name of a database to create - if not set, no database will be created   Server db_charset (string) Sets the charset of the created database, if db_name is set. Defaults to UTF8   Server db_collation (string) Sets the collation of the created database, if db_name is set. Defaults to English_United States.1252   Server enable_azure_firewall Enables firewall access to all Azure services   Server add_firewall_rule (name:string, start ip:string, end ip:string) Adds a firewall rule to the server    Example open Farmer open Farmer.Builders open Farmer.PostgreSQL let myPostgres = postgreSQL { admin_username \u0026#34;adminallthethings\u0026#34; server_name \u0026#34;aserverformultitudes42\u0026#34; capacity 4\u0026lt;VCores\u0026gt; storage_size 50\u0026lt;Gb\u0026gt; tier GeneralPurpose db_name \u0026#34;things\u0026#34; allow_azure_firewall } let template = arm { location Location.NorthEurope add_resource myPostgres } template |\u0026gt; Writer.quickWrite \u0026#34;postgres-example\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/search/","title":"Search","tags":[],"description":"","content":"Overview The Search builder creates storage accounts and their associated containers.\n Search (Microsoft.Search/searchServices)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Search instance.   sku Sets the sku of the Azure Search instance.   replicas Sets the replica count of the Azure Search instance.   partitions Sets the number of partitions of the Azure Search instance.    Configuration Members    Member Purpose     AdminKey Gets an ARM expression for the admin key of the search instance.   QueryKey Gets an ARM expression for the query key of the search instance.    Example open Farmer open Farmer.Builders let mySearch = search { name \u0026#34;isaacsSearch\u0026#34; sku Search.Basic } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/service-bus/","title":"Service Bus","tags":[],"description":"","content":"Overview The Service Bus builder creates service bus namespaces and their associated queues.\n Service Bus Namespaces (Microsoft.ServiceBus/namespaces)  Builder Keywords    Applies To Keyword Purpose     Queue name The name of the queue.   Queue lock_duration_minutes The length of time that a lock can be held on a message.   Queue max_delivery_count The maximum number of times a message can be delivered before dead lettering.   Queue duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for.   Queue enable_session Enables session support.   Queue enable_dead_letter_on_message_expiration Enables dead lettering of messages that expire.   Queue enable_partition Enables partition support on the queue.   Queue link_to_namespace Link this queue to an existing namespace instead of creating a new one.   Namespace sku The ServiceBusNamespaceSku e.g. Standard   Namespace namespace_name The name of the namespace that holds the queue.   Namespace depends_on Adds a resource that the service bus depends on.    Configuration Members    Member Purpose     NamespaceDefaultConnectionString Returns an ARM expression to retrieve the Primary Connection String of the service bus.   DefaultSharedAccessPolicyPrimaryKey Returns an ARM expression to retrieve the Primary Key of the service bus.    Example open Farmer open Farmer.Builders open Farmer.ServiceBus let myServiceBus = serviceBus { name \u0026#34;my-namespace\u0026#34; sku Standard add_queues [ queue { name \u0026#34;queueA\u0026#34; } queue { name \u0026#34;queueB\u0026#34; } ] add_topics [ topic { name \u0026#34;topicA\u0026#34; } topic { name \u0026#34;topicB\u0026#34; } ] } let deployment = arm { location Location.NorthEurope add_resource myServiceBus output \u0026#34;connectionString\u0026#34; myServiceBus.NamespaceDefaultConnectionString output \u0026#34;defaultSharedAccessPolicyPrimaryKey\u0026#34; myServiceBus.DefaultSharedAccessPolicyPrimaryKey } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/sql/","title":"SQL Azure","tags":[],"description":"","content":"Overview The SQL Azure module contains two builders - sqlServer, used to create SQL Azure servers, and sqlDb, used to create individual databases. It supports features such as encryption, firewalls and automatic pool creation. Every SQL Azure server you create will automatically create a SecureString parameter for the admin account password.\n SQL Azure server (Microsoft.Sql/servers)  SQL Server Builder Keywords    Keyword Purpose     server_name Sets the name of the SQL server.   add_firewall_rule Adds a custom firewall rule given a name, start and end IP address range.   enable_azure_firewall Adds a firewall rule that enables access to other Azure services.   admin_username Sets the admin username of the server.   elastic_pool_name Sets the name of the elastic pool, if required. If not set, Farmer will generate a name for you.   elastic_pool_sku Sets the sku of the elastic pool, if required. If not set, Farmer will default to Basic 50.   elastic_pool_database_min_max Sets the optional minimum and maximum DTUs for the elastic pool for each database.   elastic_pool_capacity Sets the optional disk size in MB for the elastic pool for each database.    SQL Server Configuration Members    Member Purpose     ConnectionString Gets a literal .NET connection string using the administrator username / password, given a database or database name. The password will be evaluated based on the contents of the password parameter supplied to the template at deploy time.    SQL Database Builder Keywords    Keyword Purpose     name Sets the name of the database.   sku Sets the sku of the database. If not set, the database is assumed to be part of an elastic pool which will be automatically created.   collation Sets the collation of the database.   use_encryption Enables transparent data encryption of the database.    Example open Farmer open Farmer.Builders open Sql let myDatabases = sqlServer { name \u0026#34;my_server\u0026#34; admin_username \u0026#34;admin_username\u0026#34; enable_azure_firewall elastic_pool_name \u0026#34;mypool\u0026#34; elastic_pool_sku PoolSku.Basic100 add_databases [ sqlDb { name \u0026#34;poolDb1\u0026#34; } sqlDb { name \u0026#34;poolDb2\u0026#34; } sqlDb { name \u0026#34;standaloneDb1\u0026#34;; sku DbSku.Basic } ] } let template = arm { location Location.NorthEurope add_resource myDatabases } template |\u0026gt; Writer.quickWrite \u0026#34;sql-example\u0026#34; template |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ \u0026#34;password-for-my_server\u0026#34;, \u0026#34;*****\u0026#34; ] "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/storage-account/","title":"Storage Account","tags":[],"description":"","content":"Overview The Storage Account builder creates storage accounts and their associated containers.\n Storage Accounts (Microsoft.Storage/storageAccounts) Storage Containers (blobServices/containers)  Builder Keywords    Keyword Purpose     name Specifies the name of the storage account   sku Sets the SKU of the storage account   add_public_container Adds a general-purpose public storage container   add_private_container Adds a general-purpose private storage container   add_blob_container Adds a general-purpose private blob container    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the storage account\u0026rsquo;s primary connection string. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let storage = storageAccount { name \u0026#34;isaacssuperstorage\u0026#34; sku Storage.Premium_LRS add_public_container \u0026#34;myPublicContainer\u0026#34; add_private_container \u0026#34;myPrivateContainer\u0026#34; add_blob_container \u0026#34;myBlobContainer\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/virtual-machine/","title":"Virtual Machine","tags":[],"description":"","content":"Overview The Virtual Machine builder creates a fully configured virtual machine and all its required child resources.\n Virtual Machines (Microsoft.Compute/virtualMachines) Virtual Networks (Microsoft.Network/virtualNetworks) IP Addresses (Microsoft.Network/publicIPAddresses) Network Interfaces (Microsoft.Network/networkInterfaces) Storage Accounts (Microsoft.Storage/storageAccounts)  In addition, every VM you create will add a SecureString parameter to the ARM template, whose name follows the pattern password-for-[virtual machine name].\nBuilder Keywords    Keyword Purpose     name Sets the name of the VM.   diagnostics_support Turns on diagnostics support using an automatically created created storage account.   diagnostics_support_external Turns on diagnostics support using an existing storage account.   vm_size Sets the size of the VM.   username Sets the admin username of the VM (note: the password is supplied as a securestring parameter to the generated ARM template).   operating_system Sets the operating system of the VM. A set of samples is provided in the CommonImages module.   os_disk Sets the size and type of the OS disk for the VM.   add_disk Adds a data disk to the VM with a specific size and type.   add_ssd_disk Adds a SSD data disk to the VM with a specific size.   add_slow_disk Adds a conventional (non-SSD) data disk to the VM with a specific size.   domain_name_prefix Sets the prefix for the domain name of the VM.   address_prefix Sets the IP address prefix of the VM.   subnet_prefix Sets the subnet prefix of the VM.    Configuration Members    Member Purpose     NicName Provides the resource name of the Network Interface Card (NIC)   VnetName Provides the resource name of the Virtual Network (VNet)   SubnetName Provides the resource name of the subnet   IpName Provides the resource name of the IP Address   Hostname Returns an ARM expression to retrieve the fully-qualified domain name from the virtual machine\u0026rsquo;s DNS settings.\u0026rdquo;    Example open Farmer open Farmer.Builders let myVm = vm { name \u0026#34;myFarmerVm\u0026#34; username \u0026#34;yourUsername\u0026#34; vm_size Vm.Standard_A2 operating_system Vm.WindowsServer_2012Datacenter os_disk 128 Vm.StandardSSD_LRS add_ssd_disk 128 add_slow_disk 512 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/web-app/","title":"Web App","tags":[],"description":"","content":"Overview The Web App builder is used to create Azure App Service accounts. It abstracts the Service Plan into the same component, and will also create and configure a linked App Insights resource. If you wish to create a website that connects to an existing service plan, use the link_to_service_plan keyword and provide the resource name of the service plan to connect to.\n Web Site (Microsoft.Web/sites) Web Host (Microsoft.Web/serverfarms) Application Insights (Microsoft.Insights/components) Site Extension (siteextensions)  Web App Builder Keywords    Applies To Keyword Purpose     Web App name Sets the name of the web app.   Web App link_to_service_plan Instructs Farmer to link this webapp to an existing service plan rather than creating a new one.   Web App app_insights_auto_name Sets the name of the automatically-created app insights instance.   Web App app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   Web App link_to_app_insights Instead of creating a new AI instance, configure this webapp to point to another AI instance that you are managing yourself.   Web App run_from_package Sets the web app to use \u0026ldquo;run from package\u0026rdquo; deployment capabilities.   Web App website_node_default_version Sets the node version of the web app.   Web App setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   Web App settings Sets a list of app setting of the web app as tuples in the form of (\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;).   Web App https_only Disables http for this webapp so that only HTTPS is used.   Web App enable_http2 Configures the webapp to allow clients to connect over http2.0.   Web App disable_client_affinity Stops the webapp from sending client affinity cookies.   Web App enable_websockets Configures the webapp to allow clients to connect via websockets.   Web App depends_on Sets a dependency for the web app.   Web App docker_image Sets the docker image to be pulled down from Docker Hub, and the command to execute as a second argument. Automatically sets the OS to Linux.   Web App docker_ci Turns on continuous integration of the web app from the Docker source repository using a webhook.   Web App docker_use_azure_registry Uses the supplied Azure Container Registry name as the source of the Docker image, instead of Docker Hub. You do not need to specify the full url, but just the name of the registry itself.   Web App enable_managed_identity Creates a system-assigned identity for the web app.   Web App disable_managed_identity Deletes the system-assigned identity for the web app.   Web App enable_cors Enables CORS support for the app. Either specify WebApp.AllOrigins or a list of valid URIs as strings.   Web App source_control Given a github repository URI and branch name, configures the web app to automatically deploy those files to the web app   Web App disable_source_control_ci Disables continuous integration from source control on push   Web App enable_source_control_ci Enables continuous integration from source control on push   Service Plan service_plan_name Sets the name of the service plan. If not set, uses the name of the web app postfixed with \u0026ldquo;-plan\u0026rdquo;.   Service Plan always_on Sets \u0026ldquo;Always On\u0026rdquo; flag.   Service Plan runtime_stack Sets the runtime stack.   Service Plan operating_system Sets the operating system. If Linux, App Insights configuration settings will be omitted as they are not supported by Azure App Service.   Service Plan sku Sets the sku of the service plan.   Service Plan worker_size Sets the size of the service plan worker.   Service Plan number_of_workers Sets the number of instances on the service plan.     Farmer also comes with a dedicated Service Plan builder that contains all of the above keywords that apply to a Service Plan.\nUse this builder if you wish to have an explicit and clear separation between your web app and service plan. Otherwise, it is recommended to use the service plan keywords that exist directly in the web app builder, and let Farmer handle the connections between them.\n Post-deployment Builder Keywords The Web App builder contains special commands that are executed after the ARM deployment is completed.\n   Keyword Purpose     zip_deploy Supplying a folder or zip file will instruct Farmer to upload the contents directly to the App Service once the ARM deployment is complete.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this web app.   ServicePlan Gets the Resource Name of the service plan for this web app.   AppInsights Gets the Resource Name of the service plan for the AI resource linked to this web app.   SystemIdentity Gets the system-created managed principal for the web app. It must have been enabled using enable_managed_identity.    Example open Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku WebApp.Sku.B1 always_on app_insights_off worker_size Medium number_of_workers 3 run_from_package } "},{"uri":"https://compositionalit.github.io/farmer/contributing/outputs-and-expressions/","title":"Outputs and ARM Expressions","tags":[],"description":"","content":"Outputs can be created in Farmer for any ARM Expression, Resource Name or any optional string. ARM Expressions are most useful in this case for referring to values that only exist at deployment time, such as connection strings.\n Creating ARM Expressions Farmer ARM expressions are in reality just wrapped strings, and are easy to create. For example, the code to create a Storage Key property is similar to this:\nlet buildKey accountName : ArmExpression = // Create the raw string of the expression  let rawValue = sprintf \u0026#34;concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=%s;AccountKey=\u0026#39;, listKeys(\u0026#39;%s\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)\u0026#34; accountName accountName // Wrap the raw value in an ARM Expression and return it  ArmExpression rawValue Notice that you do not wrap the expression in square brackets [ ]; Farmer will do this when writing out the ARM template.\nExtracting the value of an ARM Expression ARM expressions also have the following members on them:\n Map - standard map Bind - standard bind Value - Returns the raw string value Eval - Returns the string as a formatted ARM expression i.e. surround in []  "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/","title":"Adding A Resource","tags":[],"description":"","content":"This set of guided exercises shows the different steps required to create new ARM resources in Farmer. We\u0026rsquo;ll create a basic resource that can hook into the Farmer pipeline, by adding support to Farmer for the ContainerRegistry Azure resource. This will involve:\n Defining an type that implements IArmResource that maps directly to the ARM template output. Defining any domain types required to capture details on the resource. Defining a type that implements IBuilder and an associated computation expression that will be easier for users to consume than an F# record.  This will end up allowing us to define a resource that looks like this:\nlet myRegistry = containerRegistry { name \u0026#34;devonRegistry\u0026#34; sku ContainerRegistrySku.Basic enable_admin_user } let deployment = arm { location NorthEurope add_resource myRegistry } which generates JSON looking something like this:\n{ \u0026#34;name\u0026#34;: \u0026#34;devonRegistry\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;northeurope\u0026#34;, \u0026#34;tags\u0026#34;: {}, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Basic\u0026#34; }, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: true, }, \u0026#34;resources\u0026#34;: [] } Useful terminology  Resource: A resource is a single Azure service provided by ARM; in Farmer these resource models are created by implementing the IArmResource interface. Template: Represents an ARM template with parameters, outputs and zero, one or many resources. Location: An Azure Region where a service exists. Deployment: Represents the deployment of an ARM template to a specific Location and Resource Group name. Builder: In Farmer, an IBuilder represents provides the capability of creating a smart type that helps model a resource or a collection of resources into associated IArmResource objects required for constructing the ARM template. For example, Farmer\u0026rsquo;s WebApp builder provides a logical abstraction on top of several ARM resources: Web App, Server Farm and Application Insights.  Requirements  Minimum version is 2.5.0 of Azure CLI Azure account to test against  "},{"uri":"https://compositionalit.github.io/farmer/contributing/","title":"Contributing","tags":[],"description":"","content":"Thanks for thinking about contributing! Azure is a giant beast and help supporting more use-cases is always appreciated. To make it easier to contribute, we put together this little guide. Please take a few minutes to read through before starting work on a pull request (PR) to Farmer.\nThe process (don\u0026rsquo;t worry\u0026hellip; this is not waterfall)  Open an issue, or comment on an existing open issue covering the resource you would like to work on. Basically, a PR from you should not come as a surprise. Implement the 20% of features that cover 80% of the use cases. PR against the master branch from your fork. Add/update tests as required. Create a new *.md file with the name of your resource in the folder /content/api-overview/resources/. Eg. container-registry.md Add a description, keywords, and an example to the docs page. PRs need to pass build/test against both Linux \u0026amp; Windows build, and a review, before being merged in.  TODO There\u0026rsquo;s still more to document!\n Validation Outputs Dependencies Secure parameters Multiple resource builders Linking resources (one-to-many relationships) Post-deploy tasks  "},{"uri":"https://compositionalit.github.io/farmer/arm-vs-farmer/","title":"Farmer and ARM","tags":[],"description":"","content":"    Farmer ARM Template     Core ARM features     Repeatable deployments? Yes, Farmer runs on top of ARM Yes   ARM deployment mechanisms? All, plus easy-to-use F# deployment All   Variables support? Yes, native support in F# Yes   Parameters support? Yes, native support in F# or secure parameters Yes   Supported resources? All, including custom builders for 30+ popular resources All   Declarative model support? Yes Yes   Support for all ARM tools? Yes, Farmer runs on top of ARM Yes   Linked Template support? No - generally not required. Yes   Authoring     Easy to author? Yes No   Easy to read? Yes No   Documented? Yes, website and discoverable intellisense Limited, documented but often out-of-date   Editor support? Yes, any F# editor including VS Code, VS and Rider Limited, only VS Code has any support   Safety     Type-safe? Yes, full support from the F# compiler and type system Limited through VS Code extension and LSP   Validation support? Edit-time, run-time, deploy-time Deploy-time and limited edit-time   Flexibility     Link resources easily? Yes Not easily complex path expressions must be known   Compose resources together? Yes Not easily   Create multiple resources simultaneously? Yes No, each resource must be defined separately   Create resources in several ways? Yes, builders, records, functions or classes No, must use JSON   Full programming language? Yes, F# is a simple yet powerful programming language No, JSON with limited functions   Imperative model? Yes, F# supports imperative programming No, you must program in a declarative style   Interop and extensibility     Add your own ARM resources? Yes, plug-in model to add new ARM resources N/A   Create your own combinations of resources? Yes No, each resource must be defined separately   Use external libraries? Yes, use any NuGet packages during authoring and full .NET Core No, fixed set of functions   Use in .NET applications? Yes, Farmer is a .NET Core library and can be used in-proc No, JSON files    "},{"uri":"https://compositionalit.github.io/farmer/","title":"Farmer","tags":[],"description":"","content":"  Making repeatable Azure deployments easy! Farmer is an easy-to-learn library for rapidly authoring and deploying entire Azure architectures.\n Infrastructure-as-code, done right. Simple code snippets allow you to rapidly construct complex topologies. Idempotent deployments. Safely provision a template repeatedly and know that only changes will be applied. Cross-platform. Runs on .NET Core on Windows, Mac or Linux. Built on trusted technologies. Farmer uses Microsoft\u0026rsquo;s Azure Resource Manager (ARM) technology for deployments to Azure. Commercial support available. Contact us for support on how to start creating repeatable deployments. Easy to learn, easy to understand code through a simple, strongly-typed and pragmatic DSL.  Already using ARM templates? Farmer has you covered.\n Farmer is completely backwards compatible with ARM templates. Farmer generates standard ARM templates so you can continue to use existing deployment processes. Safely create dependencies between resources. Uses static typing to give confidence that your templates will work first time. Easily access common properties of resources. No more fighting to concatenate cryptic strings! Extensible API. Add new helpers and members as needed. Open source and free. Farmer is free to use and modify. We welcome contributions to the project!  Why not Azure Resource Manager? Farmer uses a simple DSL to declare resources and comes with helper functions to perform common tasks. Farmer templates are around 5-8 times smaller than ARM templates, meaning they are quicker and easier to author, understand and maintain. Read more on the comparison page.\nCreating a web application with a configured application insights and a linked storage account Farmer Templates These 22 lines of simple, readable and type-safe code are translated into 141 lines of JSON ARM template!\n// Create a storage account with a container let myStorageAccount = storageAccount { name \u0026#34;myTestStorage\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } // Create a web app with application insights that\u0026#39;s connected to the storage account. let myWebApp = webApp { name \u0026#34;myTestWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key depends_on myStorageAccount } // Create an ARM template let deployment = arm { location Location.NorthEurope add_resources [ myStorageAccount myWebApp ] } // Deploy it to Azure! deployment |\u0026gt; Writer.quickDeploy \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters Want to try it out? Follow our quickstart guide now! "},{"uri":"https://compositionalit.github.io/farmer/contributing/creating-multiple-resources/","title":"","tags":[],"description":"","content":""},{"uri":"https://compositionalit.github.io/farmer/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://compositionalit.github.io/farmer/tags/","title":"Tags","tags":[],"description":"","content":""}]