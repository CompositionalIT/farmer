[{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/application-gateway/","title":"Application Gateway","tags":[],"description":"","content":"Overview The Application Gateway builder is used to create Application Gateways.\n Application Gateways (Microsoft.Network/applicationGateways)  Application Gateway Builder Keywords The Application Gateway builder (appGateway) constructs Application Gateways.\n   Keyword Purpose     name Sets the name of the Application Gateway.   sku_capacity Sets the capacity for this SKU of Application Gateway.   add_identity Assigns a managed identity to the Application Gateway.   add_ip_configs Assigns one or more gateway IP configuration for the subnet where it should be created.   add_frontends Assigns one or more frontend IP configuration for a public or private IP for the services accessible through the gateway.   add_frontend_ports Assigns one or more frontend ports to listen   add_http_listeners Assigns one or more http listeners.   add_backend_address_pools Assigns one or more backend pools.   add_backend_http_settings_collection Assigns HTTP settings for the listener.   add_request_routing_rules Assigns routing rules between frontend IP configurations and ports and services in the backend pool.   add_probes Assigns health probes to ensure backend services are healthy or removed from the pool.    Complete Example This example creates an application gateway frontend with an NSG and a backend virtual network where application services would be running.\nlet myNsg = nsg { name \u0026#34;agw-nsg\u0026#34; add_rules [ securityRule { name \u0026#34;app-gw\u0026#34; description \u0026#34;GatewayManager\u0026#34; services [ NetworkService (\u0026#34;GatewayManager\u0026#34;, Range (65200us,65535us)) ] add_source_tag NetworkSecurity.TCP \u0026#34;GatewayManager\u0026#34; add_destination_any } securityRule { name \u0026#34;inet-gw\u0026#34; description \u0026#34;Internet to gateway\u0026#34; services [ \u0026#34;http\u0026#34;, 80 ] add_source_tag NetworkSecurity.TCP \u0026#34;Internet\u0026#34; add_destination_network \u0026#34;10.28.0.0/24\u0026#34; } securityRule { name \u0026#34;app-servers\u0026#34; description \u0026#34;Internal app server access\u0026#34; services [ \u0026#34;http\u0026#34;, 80 ] add_source_network NetworkSecurity.TCP \u0026#34;10.28.0.0/24\u0026#34; add_destination_network \u0026#34;10.28.1.0/24\u0026#34; } ] } let net = vnet { name \u0026#34;agw-vnet\u0026#34; build_address_spaces [ addressSpace { space \u0026#34;10.28.0.0/16\u0026#34; subnets [ subnetSpec { name \u0026#34;gw\u0026#34; size 24 network_security_group myNsg } subnetSpec { name \u0026#34;apps\u0026#34; size 24 network_security_group myNsg add_delegations [ SubnetDelegationService.ContainerGroups ] } ] } ] } let msi = createUserAssignedIdentity \u0026#34;agw-msi\u0026#34; let backendPoolName = ResourceName \u0026#34;agw-be-pool\u0026#34; let myAppGateway = let gwIp = gatewayIp { name \u0026#34;app-gw-ip\u0026#34; link_to_subnet net.Name net.Subnets.[0].Name } let frontendIp = frontendIp { name \u0026#34;app-gw-fe-ip\u0026#34; public_ip \u0026#34;agp-gw-pip\u0026#34; } let frontendPort = frontendPort { name \u0026#34;port-80\u0026#34; port 80 } let listener = httpListener { name \u0026#34;http-listener\u0026#34; frontend_ip frontendIp frontend_port frontendPort backend_pool backendPoolName.Value } let backendPool = appGatewayBackendAddressPool { name backendPoolName.Value add_backend_addresses [ backend_ip_address \u0026#34;10.28.1.4\u0026#34; backend_ip_address \u0026#34;10.28.1.5\u0026#34; ] } let healthProbe = appGatewayProbe { name \u0026#34;agw-probe\u0026#34; host \u0026#34;localhost\u0026#34; path \u0026#34;/\u0026#34; port 80 protocol Protocol.Http } let backendSettings = backendHttpSettings { name \u0026#34;bp-default-web-80-web-80\u0026#34; port 80 probe healthProbe protocol Protocol.Http request_timeout 10\u0026lt;Seconds\u0026gt; } let routingRule = basicRequestRoutingRule { name \u0026#34;web-front-to-services-back\u0026#34; http_listener listener backend_address_pool backendPool backend_http_settings backendSettings } appGateway { name \u0026#34;app-gw\u0026#34; sku_capacity 2 add_identity msi add_ip_configs [ gwIp ] add_frontends [ frontendIp ] add_frontend_ports [ frontendPort ] add_http_listeners [ listener ] add_backend_address_pools [ backendPool ] add_backend_http_settings_collection [ backendSettings ] add_request_routing_rules [ routingRule ] add_probes [ healthProbe ] depends_on myNsg depends_on net } arm { location Location.EastUS add_resources [ msi net myNsg myAppGateway ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/alert/","title":"App Insights - Alerts","tags":[],"description":"","content":"Overview Azure Application Insights allows you to monitor your application and send you alerts when it is either unavailable, experiencing failures, or suffering from performance issues.\n Application Insights Metric Alerts (Microsoft.Insights/metricAlerts)  Builder Keywords    Keyword Purpose     name Sets the name of Alert.   description Sets the description of the alert.   frequency How often the metric alert is evaluated   window The period of time that is used to monitor alert activity based on the threshold.   severity Alert severity   add_linked_resource Add target resource on which the alert is created/updated.   add_linked_resources Add the target resources on which the alert is created/updated.   single_resource_multiple_metric_criteria The rule criteria that defines the conditions of the alert rule.   single_resource_multiple_custom_metric_criteria The rule criteria that defines the conditions of the alert rule based on Application Insights custom metric or metric with custom namespace. Metric validation is disabled for such criteria, so it is possible to create an alert that watches metrics not yet emitted. More details are available here.   multiple_resource_multiple_metric_criteria The rule criterias that defines the conditions of the alert rule.   webtest_location_availability_criteria The rule criteria that defines the conditions of the alert rule. AppInsightsId * WebTestId * FailedLocationCount   add_action Add an action that are performed when the alert rule becomes active.    More detailed documentation: https://docs.microsoft.com/en-us/azure/templates/microsoft.insights/metricalerts?tabs=json#metricalertproperties\nExample Virtual machine alert:\nlet vm = vm { name \u0026#34;foo\u0026#34;; username \u0026#34;foo\u0026#34; } let vmAlert = alert { name \u0026#34;myVmAlert2\u0026#34; description \u0026#34;Alert if VM CPU goes over 80% for 15 minutes\u0026#34; frequency (System.TimeSpan.FromMinutes(5.0) |\u0026gt; IsoDateTime.OfTimeSpan) window (System.TimeSpan.FromMinutes(15.0) |\u0026gt; IsoDateTime.OfTimeSpan) add_linked_resource vm severity AlertSeverity.Warning single_resource_multiple_metric_criteria [ { MetricNamespace = vm.ResourceId.Type MetricName = MetricsName.PercentageCPU Threshold = 80 Comparison = GreaterThan Aggregation = Average }] } For the metric names and their aggregations, there is a huge list of options: https://docs.microsoft.com/en-us/azure/azure-monitor/essentials/metrics-supported\nDatabase alert:\nlet myAlert = alert { name \u0026#34;myDbAlert\u0026#34; description \u0026#34;Alert if DB DTU goes over 85% for 5 minutes\u0026#34; frequency (System.TimeSpan.FromMinutes(1.0) |\u0026gt; IsoDateTime.OfTimeSpan) window (System.TimeSpan.FromMinutes(5.0) |\u0026gt; IsoDateTime.OfTimeSpan) add_linked_resource resId severity AlertSeverity.Error single_resource_multiple_metric_criteria [ { MetricNamespace = resId.ResourceId.Type MetricName = MetricsName.SQL_DB_DTU Threshold = 85 Comparison = GreaterThan Aggregation = Average }] } Website down alert:\nlet ai = appInsights { name \u0026#34;ai\u0026#34; } let webtest = availabilityTest { ... } let aiId, webId = (ai :\u0026gt; IBuilder).ResourceId |\u0026gt; Managed, (webtest :\u0026gt; IBuilder).ResourceId |\u0026gt; Managed let webAlert = alert { name \u0026#34;myWebAlert\u0026#34; description \u0026#34;Alert if website is failing 5 mins on 3 locations\u0026#34; frequency (System.TimeSpan.FromMinutes(1.0) |\u0026gt; IsoDateTime.OfTimeSpan) window (System.TimeSpan.FromMinutes(5.0) |\u0026gt; IsoDateTime.OfTimeSpan) add_linked_resources [aiId; webId] severity AlertSeverity.Warning webtest_location_availability_criteria (aiId.ResourceId, webId.ResourceId, 3) } Custom metric alert based on Azure Application Insights:\nlet ai = appInsights { name \u0026#34;ai\u0026#34; } let customMetricAlert = alert { name \u0026#34;customMetricAlert\u0026#34; description \u0026#34;My Custom Metric Alert Description\u0026#34; frequency (System.TimeSpan.FromMinutes(1.0) |\u0026gt; IsoDateTime.OfTimeSpan) window (System.TimeSpan.FromMinutes(5.0) |\u0026gt; IsoDateTime.OfTimeSpan) add_linked_resource ai severity AlertSeverity.Error single_resource_multiple_custom_metric_criteria [ { MetricNamespace = None MetricName = Insights.MetricsName \u0026#34;MyCustomMetric\u0026#34; Threshold = 0 Comparison = GreaterThan Aggregation = Maximum } ] } Custom metric alert with custom metric namespace:\nlet ai = appInsights { name \u0026#34;ai\u0026#34; } let customMetricAlert = alert { name \u0026#34;customMetricAlert\u0026#34; description \u0026#34;My Custom Metric Alert Description\u0026#34; frequency (System.TimeSpan.FromMinutes(1.0) |\u0026gt; IsoDateTime.OfTimeSpan) window (System.TimeSpan.FromMinutes(5.0) |\u0026gt; IsoDateTime.OfTimeSpan) add_linked_resource ai severity AlertSeverity.Error single_resource_multiple_custom_metric_criteria [ { MetricNamespace = Some (ResourceType(\u0026#34;MyCustomNamespace\u0026#34;, \u0026#34;\u0026#34;)) MetricName = Insights.MetricsName \u0026#34;MyCustomMetric\u0026#34; Threshold = 0 Comparison = GreaterThan Aggregation = Maximum } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/availability-tests/","title":"App Insights - Availability Tests","tags":[],"description":"","content":"Overview The App Insights - Availability Tests builder is used to create Application Insights Availability Tests. You will need an Application Insights instance to run the tests. The tests can be just pinging the website and expecting response code of 200, or they can be recored Visual Studio WebTests as custom XML strings.\n Application Insights (Microsoft.Insights/webtests)  Builder Keywords    Keyword Purpose     name Sets the name of this Webtest instance.   link_to_app_insights Name or resource of the App Insight instance.   web_test AvailabilityTest.WebsiteUrl Uri to website, or AvailabilityTest.CustomWebtestXml string   locations List of locations where the site is pinged. These are not format of Farmer.Location but AvailabilityTest.TestSiteLocation.   timeout Timeout if the test is not responding. Default: 120 seconds.   frequency Frequency how often the test is run. Default: 900 seconds.    Example open Farmer open Farmer.Builders let ai = appInsights { name \u0026#34;ai\u0026#34; } let myAvailabilityTest = availabilityTest { name \u0026#34;avTest\u0026#34; link_to_app_insights ai timeout 60\u0026lt;Seconds\u0026gt; frequency 800\u0026lt;Seconds\u0026gt; locations [ AvailabilityTest.TestSiteLocation.NorthEurope AvailabilityTest.TestSiteLocation.WestEurope AvailabilityTest.TestSiteLocation.CentralUS AvailabilityTest.TestSiteLocation.UKSouth ] web_test ( \u0026#34;https://mywebsite.com\u0026#34; |\u0026gt; System.Uri |\u0026gt; AvailabilityTest.WebsiteUrl) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/azure-firewall/","title":"Azure Firewall","tags":[],"description":"","content":"Overview The Azure Firewall builder (azureFirewall) is used to create Azure Firewall instances.\n Azure Firewall (Microsoft.Network/azureFirewalls)  Builder Keywords    Resource Keyword Purpose     azureFirewall name Sets the name of the azure firewall   azureFirewall sku Sets the name and tier of the azure firewall sku   azureFirewall link_to_unmanaged_firewall_policy Configure the azure firewall to use an existing firewall policy   azureFirewall link_to_firewall_policy Configure the azure firewall to use a firewall policy deployed by Farmer   azureFirewall link_to_unmanaged_vhub Specify the existing virtual hub to which the azure firewall belongs   azureFirewall link_to_vhub Specify the virtual hub deployed by farmer to which the azure firewall belongs   azureFirewall public_ip_reservation_count Specify the number of Public IP addresses associated with the azure firewall   azureFirewall depends_on Specify resources deployed by farmer the azure firewall depends on    Example open Farmer open Farmer.Builders let firewall = azureFirewall { name \u0026#34;farmer_firewall\u0026#34; sku SkuName.AZFW_Hub SkuTier.Standard public_ip_reservation_count 2 link_to_unmanaged_vhub (virtualHubs.resourceId \u0026#34;unmanaged-vhub\u0026#34;) } let deployment = arm { location Location.NorthEurope add_resource firewall } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/aks-cluster/","title":"AKS Cluster","tags":[],"description":"","content":"Overview The AKS Cluster builder is used to create AKS clusters.\n Container Service (Microsoft.ContainerService/managedClusters)  AKS Builder Keywords The AKS builder (aks) constructs AKS clusters.\n   Keyword Purpose     name Sets the name of the AKS cluster.   dns_prefix Sets the DNS prefix of the AKS cluster.   enable_private_cluster Restricts the cluster\u0026rsquo;s Kubernetes API to only be accessible from private networks.   enable_rbac Enable Kubernetes Role-Based Access Control.   add_agent_pools Adds agent pools to the AKS cluster.   add_agent_pool Adds an agent pool to the AKS cluster.   add_identity Adds a managed identity to the the AKS cluster.   system_identity Activates the system identity of the AKS cluster.   kubelet_identity Assigns a user assigned identity to the kubelet user that pulls container images.   network_profile Sets the network profile for the AKS cluster.   linux_profile Sets the linux profile for the AKS cluster.   service_principal_client_id Sets the client id of the service principal for the AKS cluster.   service_principal_use_msi Enables the AKS cluster to use the managed identity service principal instead of an external client secret.   windows_username Sets the windows admin username for the AKS cluster.   add_api_server_authorized_ip_ranges Adds IP address CIDR ranges to be allowed Kubernetes API access.   addon A list with the configuration of all addons on the cluster (AciConnectorLinux, HttpApplicationRouting, KubeDashboard, IngressApplicationGateway, OmsAgent).    Agent Pool Builder keywords The Agent Pool builder (agentPool) constructs agent pools in the AKS cluster.\n   Keyword Purpose     name Sets the name of the agent pool.   count Sets the count of VM\u0026rsquo;s in the agent pool.   user_mode Sets the agent pool to user mode.   disk_size Sets the disk size for the VM\u0026rsquo;s in the agent pool.   max_pods Sets the maximum number of pods in the agent pool.   os_type Sets the OS type of the VM\u0026rsquo;s in the agent pool.   subnet Sets the name of a virtual network subnet where this AKS cluster should be attached.   vm_size Sets the size of the VM\u0026rsquo;s in the agent pool.   vnet Sets the name of a virtual network in the same region where this AKS cluster should be attached.    Kubenet Builder The Kubenet builder (kubenetNetworkProfile) creates Kubenet network profiles on the AKS cluster.\n   Keyword Purpose     load_balancer_sku SKU for the Load Balancer - defaults to \u0026lsquo;Standard\u0026rsquo;    CNI Builder The CNI builder (azureCniNetworkProfile) creates Azure CNI network profiles on the AKS cluster.\n   Keyword Purpose     docker_bridge Sets the docker bridge CIDR to a network other than the default 17.17.0.1/16.   dns_service Sets the DNS service IP - must be within the service CIDR, default is the second address in the service CIDR.   service_cidr Sets the service cidr to a network other than the default 10.224.0.0/16.   load_balancer_sku SKU for the Load Balancer - defaults to \u0026lsquo;Standard\u0026rsquo;    Basic Example The simplest cluster uses a system assigned managed identity and default settings for the node pool (size of 3).\nopen Farmer open Farmer.Builders open Farmer.ContainerService let myAks = aks { name \u0026#34;aks-cluster\u0026#34; service_principal_use_msi } Customizing agent pool and network profile let myAks = aks { name \u0026#34;k8s-cluster\u0026#34; dns_prefix \u0026#34;testaks\u0026#34; add_agent_pools [ agentPool { name \u0026#34;linuxPool\u0026#34; count 3 } ] linux_profile \u0026#34;aksuser\u0026#34; \u0026#34;public-key-here\u0026#34; service_principal_use_msi network_profile ( azureCniNetworkProfile { service_cidr \u0026#34;10.250.0.0/16\u0026#34; } ) } Using user asssigned identities and connecting to container registry // Create an identity for kubelet (used to connect to container registry) let kubeletMsi = createUserAssignedIdentity \u0026#34;kubeletIdentity\u0026#34; // Create an identity for the AKS cluster let clusterMsi = createUserAssignedIdentity \u0026#34;clusterIdentity\u0026#34; // Give the AKS cluster\u0026#39;s identity rights to assign a the kubelet MSI let assignMsiRoleNameExpr = ArmExpression.create($\u0026#34;guid(concat(resourceGroup().id, \u0026#39;{clusterMsi.ResourceId.Name.Value}\u0026#39;, \u0026#39;{Roles.ManagedIdentityOperator.Id}\u0026#39;))\u0026#34;) let assignMsiRole = { Name = assignMsiRoleNameExpr.Eval() |\u0026gt; ResourceName RoleDefinitionId = Roles.ManagedIdentityOperator PrincipalId = clusterMsi.PrincipalId PrincipalType = PrincipalType.ServicePrincipal Scope = ResourceGroup Dependencies = Set [ clusterMsi.ResourceId ] } // Create a container image registry let myAcr = containerRegistry { name \u0026#34;mycontainerregistry\u0026#34; } let myAcrResId = (myAcr :\u0026gt; IBuilder).ResourceId // Assign the AcrPull role on that registry to the identity used for kubelet. let acrPullRoleNameExpr = ArmExpression.create($\u0026#34;guid(concat(resourceGroup().id, \u0026#39;{kubeletMsi.ResourceId.Name.Value}\u0026#39;, \u0026#39;{Roles.AcrPull.Id}\u0026#39;))\u0026#34;) let acrPullRole = { Name = acrPullRoleNameExpr.Eval() |\u0026gt; ResourceName RoleDefinitionId = Roles.AcrPull PrincipalId = kubeletMsi.PrincipalId PrincipalType = PrincipalType.ServicePrincipal Scope = AssignmentScope.SpecificResource myAcrResId Dependencies = Set [ kubeletMsi.ResourceId ] } // Create the cluster and assign the cluster and kubelet identities. let myAks = aks { name \u0026#34;aks-cluster\u0026#34; add_identity clusterMsi service_principal_use_msi kubelet_identity kubeletMsi depends_on clusterMsi depends_on myAcr depends_on_expression assignMsiRoleNameExpr depends_on_expression acrPullRoleNameExpr } // A template to deploy the MSI\u0026#39;s, role assignemnts, container registry and AKS. let template = arm { add_resource kubeletMsi add_resource clusterMsi add_resource myAcr add_resource myAks add_resource assignMsiRole add_resource acrPullRole } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/template-generation/","title":"Generating templates","tags":[],"description":"","content":"Farmer supports several ways to \u0026ldquo;output\u0026rdquo; ARM templates.\nGenerating JSON as a string You can generate an ARM template as a plain string:\nlet json = deployment.Template |\u0026gt; Writer.toJson // prints out the JSON  printfn \u0026#34;%s\u0026#34; json Writing to a file You can write out the ARM template directly to a file, from which you can then deploy to Azure using whichever mechanism you already use e.g. Azure CLI, Powershell, REST API etc.\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myTemplate\u0026#34; Notice how we use F#\u0026lsquo;s pipe operator to \u0026ldquo;pipe\u0026rdquo; data from the template configuration into json before writing to a file.\nIntegrated deployment to Azure You can also turn over deployment of the template directly to Farmer. In this case, it orchestrates commands to the Azure CLI as required.\nlet response = deployment |\u0026gt; Deploy.tryExecute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters match response with | Ok outputs -\u0026gt; printfn \u0026#34;Success! Outputs: %A\u0026#34; outputs | Error error -\u0026gt; printfn \u0026#34;Failed! %s\u0026#34; error As you can see, the response of calling tryExecute is a Result object which is either Ok, in which case any outputs returned from the template are made available as a Map\u0026lt;string, string\u0026gt;, or an Error, which is the error returned by the Azure CLI. Alternatively, you can call execute which will throw an exception rather than return a Result.\n You must have the Azure CLI installed on your machine in order for Farmer to perform deployments for you.\n Authenticating to Azure Azure CLI stores a login token on your machine, and Farmer will check for this. If you aren\u0026rsquo;t logged in, Farmer will automatically start the interactive Azure CLI login process for you.\nFor automated deployments e.g. continuous deployment or through scripts etc., you\u0026rsquo;ll want to use an unattended deployment mode. Some CI systems such as Azure Devops come with an pre-authenticated Azure CLI terminal from which you can run an application that uses Farmer. Alternatively, you can create a service principal, and supply them to the Deploy.authenticate function before calling Deploy.execute.\nYou should use a secure mechanism for storing and supplying the credentials to Farmer. Do not commit them into source control!\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/app-insights/","title":"App Insights","tags":[],"description":"","content":"Overview The App Insights builder is used to create Application Insights accounts. Use this if you need a standalone AI instance; if you need one for a web app, the web app will create one by default and configure the application settings automatically.\n Application Insights (Microsoft.Insights/components)   This builder supports both \u0026ldquo;Classic\u0026rdquo; (standalone) and \u0026ldquo;Workspace Enabled\u0026rdquo; (Log Analytics-backed) instances of App Insights. See the log_analytics_workspace keyword to see how to create the latter type of instance.\n Builder Keywords    Keyword Purpose     name Sets the name of the App Insights instance.   disable_ip_masking Disable IP masking.   sampling_percentage Define sampling percentage (0-100)   log_analytics_workspace Use a Log Analytics workspace as the backing store for this AI instance. You can supply either a Farmer-generate Log AnalyticsWorkspaceConfig instance that exists in the same resource group, or a fully-qualified Resource ID path to that instance. This will also switch the AI instance over to creating a \u0026ldquo;workspace enabled\u0026rdquo; AI instance.    Configuration Members    Member Purpose     InstrumentationKey Gets the ARM expression path to the instrumentation key of this App Insights instance.   ConnectionString Gets the ARM expression path to the connection string of this App Insights instance.    Example open Farmer open Farmer.Builders let ai = appInsights { name \u0026#34;myAI\u0026#34; log_analytics_workspace myWorkspace // use to activate workspace-enabled AI instances. } "},{"uri":"https://compositionalit.github.io/farmer/about/","title":"About","tags":[],"description":"","content":"About Farmer Farmer is a .NET domain-specific-language (DSL) for rapidly generating Azure Resource Manager (ARM) templates. Farmer is commercially supported, open source and free-to-use.\nFor those of you working with Azure today, you may already be aware that one of the most useful features is the ability to generate entire infrastructure architectures as code via ARM Template files. These templates contain a declarative model that allows repeatable deployments and idempotent releases (among other things).\nWhat\u0026rsquo;s wrong with ARM? Unfortunately, ARM templates have some limitations caused by the fact that they must be authored in a verbose JSON dialect:\n They provide very limited type checking and support, which makes creating discovery and creation of template features difficult. Templates need a lot of boilerplate to be created for even relatively simple and common resources. It requires \u0026ldquo;embedded\u0026rdquo;, difficult-to-maintain stringly-typed code in order to achieve what might be trivial in a \u0026ldquo;proper\u0026rdquo; programming language, such as references, variables and parameters - or writing elements such as loops. The documentation for ARM templates is not always kept up-to-date, so understanding and learning how to properly use them can involve a lot of searching and trial-and-error.  In other words, whilst working with ARM templates that have already been created is relatively straightforward, the authoring of the templates themselves is time-consuming and error-prone.\nWhilst there have been some recent improvements to ARM - including tooling improvements in VS Code through an extension - we think that we can do much better than relying on tooling for a specific IDE, which means using something different than JSON when directly authoring ARM templates.\nWhat does Farmer do to fix this? Farmer templates are simple .NET Core applications which reference the Farmer NuGet package. This package contains a set of types that model Azure resources in a strongly-typed and succinct fashion, as well as functionality to create ARM templates from this model - and even deploy directly to Azure.\nWhat can I use Farmer for? Farmer currently has support for a large number of common resources including web apps, sql and storage, with more being added over time.\n"},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-1/","title":"Your first Farmer template","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll:\n create a web application with a fully-configured Application Insights instance create an ARM deployment object and assign the web app to it generate an ARM template  Creating a Farmer app Create an F# console application using the .NET SDK and add the Farmer package in an empty directory:\ndotnet new console -lang F# dotnet add package Farmer  Farmer also has a .NET template to get started even more quickly!\n Defining a Farmer web application Open Program.fs and delete all the contents.\n In Farmer, resources are defined using special code blocks that look somewhat json-esque, known as a \u0026ldquo;builder\u0026rdquo;. In these builders you can quickly and easily configure a resource using special keywords, but unlike json you also have edit-time safety.\n Create a Farmer web application using the webApp { } builder:\nopen Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } Create an ARM template deployment object, before setting the location for the overall resource group and adding the web app into it.\nlet deployment = arm { location Location.NorthEurope add_resource myWebApp } Generating the ARM template Now you need to generate the ARM template from the deployment object to an ARM json file.\nAdd the following code:\ndeployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; Run the application:\ndotnet run You should notice that the file myFirstTemplate.json has been created.\nThe generated ARM template contains the following resources:\n A web application A server farm An application insights instance  The resources will be correctly configured with the appropriate dependencies set.\nThe full application open Farmer open Farmer.Builders let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; } let deployment = arm { location Location.NorthEurope add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/1-the-farmer-pipline/","title":"1. The Farmer Pipeline","tags":[],"description":"","content":"This step will get you up and running by incorporating something quickly and easily into the Farmer pipeline that emits a valid Azure Container Registry.\nStep 1.1: Prototype and test using an fsx file Technically this step is not necessary but it is the quickest way to get a working deployment from which you can iterate upon.\nStart by looking at the sample azuredeploy.json file from the Azure Container Registry with Geo-replication Azure quickstart template and identifying the section of JSON that relates to the resource we want - in our case, the Microsoft.ContainerRegistry/registries resource.\n In VSCode, the use of #r \u0026quot;nuget:...\u0026quot; syntax can be enabled by going to Settings \u0026gt; F# \u0026gt; Fsi Extra Parameters and adding --langversion:preview to the FSharp.fsiExtraParameters list (.NET 5 only). VS2019 and Rider already support this feature natively. If you are not using .NET 5, manually build Farmer and reference the dll manually - see the samples folder for examples.\n // container-registry-prototype.fsx #r \u0026#34;nuget: farmer\u0026#34; open Farmer // A function called \u0026#34;registries\u0026#34; that takes in a name, sku and boolean flag for whether to enable the admin user. let registries name sku adminUserEnabled = $\u0026#34;\u0026#34;\u0026#34;{{ \u0026#34;name\u0026#34;: \u0026#34;{name}\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westeurope\u0026#34;, \u0026#34;tags\u0026#34;: {{ }}, \u0026#34;sku\u0026#34;: {{ \u0026#34;name\u0026#34;: \u0026#34;{sku}\u0026#34; }}, \u0026#34;properties\u0026#34;: {{ \u0026#34;adminUserEnabled\u0026#34;: %b{adminUserEnabled} }} }}\u0026#34;\u0026#34;\u0026#34; |\u0026gt; Resource.ofJson let deployment = arm { location Location.NorthEurope add_resource (registries \u0026#34;my-registry\u0026#34; \u0026#34;Basic\u0026#34; true) } deployment |\u0026gt; Writer.quickWrite \u0026#34;/test-output\u0026#34; // or push out for real to Azure!  // deployment // |\u0026gt; Deploy.execute \u0026#34;FarmerTest\u0026#34; Deploy.NoParameters // |\u0026gt; printfn \u0026#34;%A\u0026#34; Observe how we\u0026rsquo;ve pasted a minimal section of JSON and then tried to extract some of the candidates for parameterisation - in our case name, sku and adminUserEnabled, and how we\u0026rsquo;ve used the Resource.ofJson function to create an IArmResource for us to quickly allow us \u0026ldquo;into\u0026rdquo; the Farmer pipeline.\nTest out the JSON model you created and make sure it creates the resources in Azure you would expect. You can deploy with execute or you can use whatIf to see what the expected state would be.\nStep 1.2: Convert from JSON to an F# anonymous record For simple ARM resources, raw JSON may suffice, but normally you\u0026rsquo;ll want a little more control in order to programmatically choose whether to add / remove fields etc. during the export phase. The best way to do this is to replace the raw string export with an anonymous record:\nlet registries (name:string) (sku:string) (adminUserEnabled:bool) = {| name = name ``type`` = \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; apiVersion = \u0026#34;2019-05-01\u0026#34; location = \u0026#34;westeurope\u0026#34; tags = {| |} sku = {| name = sku |} properties = {| adminUserEnabled = adminUserEnabled |} |} |\u0026gt; Resource.ofObj Notice how the structure is the same, but is now implemented directly in F#.\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/arm-basics/","title":"ARM Basics","tags":[],"description":"","content":" Skip this section if you are already familiar with ARM Templates\n This won\u0026rsquo;t be an introduction to Azure Resource Manager or ARM templates. Instead let\u0026rsquo;s go through the main parts that are important for creating a new resource.\nThe main parts of ARM Templates can be broken into resources, outputs, variables, and parameters. Farmer has limited support for parameters and no support for variables, so we will not cover them.\nSo a generated ARM Template from Farmer will have the following structure.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#\u0026#34;, \u0026#34;contentVersion\u0026#34;: \u0026#34;1.0.0.0\u0026#34;, \u0026#34;outputs\u0026#34;: {}, \u0026#34;parameters\u0026#34;: {}, \u0026#34;resources\u0026#34;: [] } When building a new resource in Farmer you are providing the means for a user of Farmer to generate a new resource type, or configure a new property on an existing resource. These resources are added by Farmer to the resources array you can see above.\nWhen building up a resource it will have a schema that looks something like this.\n{ \u0026#34;name\u0026#34;: \u0026#34;my-example-resource\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westeurope\u0026#34;, \u0026#34;tags\u0026#34;: {}, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;S1\u0026#34; }, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: true, }, \u0026#34;resources\u0026#34;: [] } Your resource you create will have a type of service that it represents. Each service has many versions, represented by a date. Typically your builder will at first focus on adding properties to the properties field to configure a service to be deployed in a certain state.\nWhere can I find docs on ARM templates schemas themselves? There are three good sources to learning about specific ARM resources and what parts need to be used in creating an equivalent Farmer resource:\n Reference Docs: The reference documentation contains details on the schema for every resource and every version e.g. Container Registry reference. Sample Template: The Azure Quickstart Templates github repository contains many examples of real-world ARM templates e.g. Container Registry with Geo Replication sample. Reverse engineer: You can manually create a required resource in Azure, and then use Azure\u0026rsquo;s export ARM template functionality to create an ARM template. It\u0026rsquo;s important that you test out the exported template yourself before porting it to Farmer, because Azure sometimes exports invalid templates!  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/bing-search/","title":"Bing Search","tags":[],"description":"","content":"Overview The Bing Search builder is used to create Azure Bing Search instances.\n Bing Search (Microsoft.Bing/accounts, kind: Bing.Search.v7)  Builder Keywords    Keyword Purpose     name Sets the name of the Bing Search instance.   sku Sets the SKU of the instance. Defaults to F1 (free).   statistics Sets the statisticsEnabled property of the instance. Defaults to false    Configuration Members    Member Purpose     Key Gets the ARM expression path to the Key of this Bing Search instance.    Example open Farmer open Farmer.Builders let tags = [ \u0026#34;a\u0026#34;, \u0026#34;1\u0026#34;; \u0026#34;b\u0026#34;, \u0026#34;2\u0026#34; ] let translator = bingSearch { name \u0026#34;test\u0026#34; sku S0 add_tags tags statistics Enabled } let key : ArmExpression = translator.Key "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/bastion-host/","title":"Bastion Host","tags":[],"description":"","content":"Overview The Bastion Host builder creates a bastion host to access resources inside a virtual network. It also creates a static public IP for the bastion host.\n BastionHosts (Microsoft.Network/bastionHosts)  Builder Keywords    Applies To Keyword Purpose     BastionHost vnet Name of the virtual network the bastion host can access    Example #r \u0026#34;nuget:Farmer\u0026#34; open Farmer open Farmer.Builders arm { location Location.EastUS add_resources [ vnet { name \u0026#34;private-network\u0026#34; add_address_spaces [ \u0026#34;10.1.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;default\u0026#34; prefix \u0026#34;10.1.0.0/24\u0026#34; } subnet { name \u0026#34;AzureBastionSubnet\u0026#34; prefix \u0026#34;10.1.250.0/27\u0026#34; } ] } bastion { name \u0026#34;my-bastion-host\u0026#34; vnet \u0026#34;private-network\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/contributing/outputs-and-expressions/","title":"Outputs and ARM Expressions","tags":[],"description":"","content":"Outputs can be created in Farmer for any ARM Expression, Resource Name or any optional string. ARM Expressions are most useful in this case for referring to values that only exist at deployment time, such as connection strings.\n Creating ARM Expressions Farmer ARM expressions are in reality just wrapped strings, and are easy to create. For example, the code to create a Storage Key property is similar to this:\nlet buildKey accountName : ArmExpression = // Create the raw string of the expression  let rawValue = $\u0026#34;concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName={accountName};AccountKey=\u0026#39;, listKeys(\u0026#39;{accountName}\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)\u0026#34; // Wrap the raw value in an ARM Expression and return it  ArmExpression.create rawValue Notice that you do not wrap the expression in square brackets [ ]; Farmer will do this when writing out the ARM template.\nExtracting the value of an ARM Expression ARM expressions also have the following members on them:\n Map - standard map Bind - standard bind Value - Returns the raw string value Eval - Returns the string as a formatted ARM expression i.e. surround in []  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/expressions/","title":"ARM Expressions","tags":[],"description":"","content":"ARM template expressions are a way of safely storing string values which contain expressions that are evaluated at deployment time by the Azure. ARM expressions can also contain a set of predefined functions supported by the ARM runtime. They can be passed back as outputs and used further downstream\nFarmer understands how to use ARM expressions and provides functionality to correctly wrap and unwrap them as raw strings into a JSON template.\n For manipulation of literal values that are known in your Farmer applications, you will not need to use ARM expressions. To manipulate such values, you can use standard F# and .NET capabilities.\n How do I use ARM expressions? Many Farmer builders contain pre-defined ARM expression that can be used for common tasks, such as passing a connection string from a storage account as a KeyVault secret, or a web application setting.\nAs an example, a Storage Account config contains a Key member that you can supply to a web app as a setting:\nlet storageConfig = storageAccount { name \u0026#34;myStorageAccount\u0026#34; } let webAppConfig = webApp { name \u0026#34;myWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; storageConfig.Key } This will be written to the ARM template file as follows:\n\u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=myStorageAccount;AccountKey=\u0026#39;, listKeys(\u0026#39;myStorageAccount\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } Using ARM expressions means that you can deploy an application which is automatically configured at deployment time. This means that you never need to store an application secret such as a storage account key in source control, or even e.g. as a secret variable in your build / deployment process.\nReturning the value of ARM Expressions as outputs. ARM Expressions can also be passed back as outputs and used further downstream once your deployment is complete:\nlet template = arm { location Location.WestEurope add_resource storageConfig // Mark the storage_key as an output in the ARM template.  output \u0026#34;storage_key\u0026#34; storageConfig.Key } // Deploy the template. let outputs = template |\u0026gt; Deploy.execute template [] // Get the value of the storage_key. let key = outputs.[\u0026#34;storage_key\u0026#34;] Be aware though, that the value of the storage_key is visible as a plain text value in the output - so anyone with access to, for example, the Azure portal will be able to see the values of the storage key if they look at the deployment history.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/parameters/","title":"Parameters and Variables","tags":[],"description":"","content":"ARM templates support the idea both of parameterisation of templates and of the use of variables within a template for e.g. placeholders and re-using values.\nFarmer, by design, has only limited support for parameters and no support for variables. We don\u0026rsquo;t plan on adding rich support for either of these for the following reasons:\n We want to keep the Farmer codebase simple for maintainers We want to keep the Farmer API simple for users We want to keep the generated ARM templates as readable as possible We feel that instead of trying to embed conditional logic and program flow directly inside ARM templates in JSON, if you wish to parameterise your template that you should use a real programming language to do that: in this case, F#.  You can read more on this issue here\nSecure Parameters Farmer does support securestring parameters for e.g. SQL and Virtual Machine passwords - these are automatically generated based on the contents of the template rather than explicitly by yourself.\nFor example, assume the following Farmer SQL resource:\nlet db = sql { server_name \u0026#34;myserver\u0026#34; db_name \u0026#34;mydatabase\u0026#34; admin_username \u0026#34;mradmin\u0026#34; } This will generate an ARM template which looks as follows (irrelevant content is elided for clarity):\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#\u0026#34;, \u0026#34;parameters\u0026#34;: { \u0026#34;password-for-myserver\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;securestring\u0026#34; } }, \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2014-04-01-preview\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;myserver\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;administratorLogin\u0026#34;: \u0026#34;mradmin\u0026#34;, \u0026#34;administratorLoginPassword\u0026#34;: \u0026#34;[parameters(\u0026#39;password-for-myserver\u0026#39;)]\u0026#34;, }, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Sql/servers\u0026#34; } ] } Working with variables ARM templates allow you to declare variables inside a template to reuse a value across a template. ARM templates also allow the use of a custom set of a commands which are embedded within strings to generate program logic, using expressions which contain template functions. For example, to concatenate a string inside a ARM template made up of two variables and put into a third variable, you might use something like the following:\n{ \u0026#34;variables\u0026#34;: { \u0026#34;first\u0026#34;: \u0026#34;Hello\u0026#34;, \u0026#34;second\u0026#34;: \u0026#34;World\u0026#34;, \u0026#34;serverName\u0026#34;: \u0026#34;[concat(variables(\u0026#39;first\u0026#39;), \u0026#39; \u0026#39;, variables(\u0026#39;second\u0026#39;), \u0026#39;!\u0026#39;)]\u0026#34; } } In F#, you have access to the full power of .NET, rather than a limited set of weakly-typed functions:\nlet first = \u0026#34;Hello\u0026#34; let second = \u0026#34;World\u0026#34; let serverName = first + \u0026#34; \u0026#34; + second + \u0026#34;!\u0026#34; let dbName = $\u0026#34;{first} {second}!\u0026#34; let db = sql { server_name serverName db_name dbName admin_username \u0026#34;mradmin\u0026#34; } Rapidly creating multiple resources You can also use F# list comprehensions to rapidly create several resources of the same type:\n// Create five SQL servers and databases let myDatabases = [ for i in 1 .. 5 -\u0026gt; sql { server_name $\u0026#34;server{i}\u0026#34; db_name $\u0026#34;database{i}\u0026#34; admin_username \u0026#34;mradmin\u0026#34; } ] // Add all five databases to the deployment let deployment = arm { location Location.NorthEurope add_resources myDatabases } "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-2/","title":"Working with multiple resources","tags":[],"description":"","content":"Introduction In this quickstart, you\u0026rsquo;ll expand on the deployment authored in the previous quickstart as follows:\n add an Azure storage account add an application setting to the web app that references the storage account\u0026rsquo;s key set a dependency between the two resources  Creating a storage account Create a storage account by using the storageAccount builder.\nlet myStorage = storageAccount { name \u0026#34;yourfirststorage\u0026#34; }  Azure Storage Account names must be globally unique and between 3-24 alphanumeric lower-case characters!\n Referencing the storage account in the web app In this section, we will add an app setting to the web app and set the value to the storage account\u0026rsquo;s connection string.\n In F#, you need to define a value before you reference it, so make sure that you define the storage account above the web app.\n Add the storage account\u0026rsquo;s connection key to the webapp as an app setting.\nlet myWebApp = webApp { ... setting \u0026#34;storageKey\u0026#34; myStorage.Key } If you\u0026rsquo;re coming from a raw ARM template background, don\u0026rsquo;t worry about the need to set dependencies between the Storage Account and Web App - Farmer will automatically do this for you!\n Settings can be strings or (as in this case) an ARM expression, which is evaluated at deployment time.\n Adding the storage account to the deployment Add the storage account to the deployment using the same add_resource keyword as you did with myWebApp.\nAnalysing the ARM template Run the application:\ndotnet run You should notice that the template now contains a storage account. Also observe the dependency that has been created:\n{ \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2020-06-01\u0026#34;, \u0026#34;dependsOn\u0026#34;: [ \u0026#34;[resourceId(\u0026#39;Microsoft.Storage/storageAccounts\u0026#39;, \u0026#39;yourfirststorage\u0026#39;)]\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;Microsoft.Web/sites\u0026#34; } ] } Also observe the application setting that has been created:\n{ \u0026#34;appSettings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;storageKey\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[concat(\u0026#39;DefaultEndpointsProtocol=https;AccountName=yourfirststorage;AccountKey=\u0026#39;, listKeys(\u0026#39;yourfirststorage\u0026#39;, \u0026#39;2017-10-01\u0026#39;).keys[0].value)]\u0026#34; } ] } The full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorage\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Writer.quickWrite \u0026#34;myFirstTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/","title":"Quickstarts","tags":[],"description":"","content":"This section contains quickstarts to performing common tasks.\n Creating your first Farmer template Creating multiple resources Deploying to Azure The Farmer .NET Template  "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/2-iarm-resource/","title":"2. The IArmResource","tags":[],"description":"","content":"In this exercise, we\u0026rsquo;ll migrate our code from the previous step directly into the Farmer codebase.\nStep 2.1: Migrating to IArmResource Now that you know that your resource model produces the correct Json value when passed into Farmer, we can now create a proper type that contains the \u0026ldquo;parameterised\u0026rdquo; parts of the above function, such as name, sku and adminUserEnabled, and properly takes part in the Farmer pipeline, by implementing the IArmResource interface. This type is normally a full Record and should use types as required to capture e.g. SKUs or other elements that would benefit from typing (in the example above, sku is a string, but we will shortly replace that with a union type).\n// src/Farmer/Arm/ContainerRegistry.fs [\u0026lt;AutoOpen\u0026gt;] module Farmer.Arm.ContainerRegistry open Farmer // Create a reference to the full ARM registries type and version. let registries = ResourceType (\u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;2019-05-01\u0026#34;) // Temporarily define the SKU and other types alongside the IArmResource. type Sku = | Basic | Standard | Premium type Registries = { Name : ResourceName Location : Location Sku : Sku AdminUserEnabled : bool } interface IArmResource with member this.ResourceId = registries.resourceId this.Name member this.JsonModel = {| name = this.Name.Value ``type`` = \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; apiVersion = \u0026#34;2019-05-01\u0026#34; sku = {| name = this.Sku.ToString() |} location = this.Location.ArmValue tags = {||} properties = {| adminUserEnabled = this.AdminUserEnabled |} |} :\u0026gt; _ // upcast to obj Notice how we perform simple \u0026ldquo;serialization\u0026rdquo; of elements such as the SKU, but otherwise most fields are just copied across.\nThe biggest difference is that we have now also introduced the notion of ResourceType and ResourceId. A ResourceType allows you to specify the versioned ARM type that your resource implements; a ResourceId represents the qualified path to a specific, named resource. It contains at least the resource\u0026rsquo;s type and its name, but can also optionally include e.g. the resource group that the resource belongs to.\nStep 2.2: Generating the ARM values more quickly Because most ARM resources have a set of fields that are commonly used e.g. name, location etc., Farmer comes with a helper factory function to construct ARM JSON objects quickly and easily. Here\u0026rsquo;s a shortened version of JsonModel above:\n{| registries.Create(this.Name, this.Location) with sku = {| name = this.Sku.ToString() |} properties = {| adminUserEnabled = this.AdminUserEnabled |} |} :\u0026gt; _ // upcast to obj Now, the common fields will be generated for us through the registies.Create function; any custom fields (such as sku and properties) are then applied on top.\nStep 2.3: Move domain types out of the IArmBuilder.  You can skip this step if you\u0026rsquo;re just experimenting in e.g. a script.\n For now, we\u0026rsquo;ve created any associated types such as Sku directly above the file, but you\u0026rsquo;ll want to migrate these to a Farmer.ContainerRegistry module in Common.fs afterwards e.g.\n// src/Farmer/Common.fs namespace Farmer module ContainerRegistry = type Sku = | Basic | Standard | Premium Step 2.4: Test out the new Registries record in Farmer. You can test this again easily by passing an instance into a Farmer deployment like we did in the previous step:\nopen Farmer.Arm.ContainerRegistry let registries = { Name = ResourceName \u0026#34;my-registry\u0026#34; Location = Location.WestEurope Sku = ContainerRegistry.Basic AdminUserEnabled = true } let deployment = arm { location Location.NorthEurope add_resource registries } deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34;  Note that F# records must be completely filled at creation, so you must provide values for all four fields.\n You could now write a test to assert the Json structure. Most tests in the project though tend to test from the Farmer builders, which we will get to soon. You can stop right here if you want - what you\u0026rsquo;ve done so far allows you to create IArmResource objects which can be added to the Farmer pipeline. However, we will go further in the next exericse and make it even easier to create Container Registries by creating an IBuilder.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/basic-types/","title":"Basic Types","tags":[],"description":"","content":"Farmer often uses references to link resouces, when this is not possible, Farmer uses certain types to define links.\nResourceName A ResourceName represents a name of an ARM resource.\nResourceName \u0026#34;myapp\u0026#34; ResourceId A ResourceId identifies an ARM resource.\nThis is used when you want to link unmanaged resources to a deployment or have multiple deployment parts.\nA ResourceId can be created with the resourceId member of a ResourceType:\nlet subnet = Arm.Network.virtualNetworks.resourceId(ResourceName \u0026#34;\u0026#34;) or directly as a ResourceId:\nlet mySubnet = { Type = Arm.Network.subnets Name = ResourceName \u0026#34;my-vnet\u0026#34; ResourceGroup = Some(\u0026#34;myResourceGroup\u0026#34;) Subscription = None Segments = [ResourceName \u0026#34;mySubnet\u0026#34;] } These resource can be used i.e. in referencing a web app { } to a subnet.\nlet webApp = webApp { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; sku WebApp.Sku.B1 link_to_unmanaged_vnet mySubnet } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-apps/","title":"Container Apps","tags":[],"description":"","content":"Overview The Container Apps builder is used to create Azure Container Apps.\n Container Environment (Microsoft.Web/kubeEnvironments) Container App (Microsoft.Web/containerApps)  Turn on Resource Provider Before you deploy your container app, you need to turn on the Container Apps resource provider in your Azure subscription.\nGet sure you have the following providers registered: Microsoft.Kubernetes and Microsoft.ContainerService.\nContainer Environment Builder The Container Environment builder (containerEnvironment) defines settings for the Kubernetes envirionment that hosts the container apps.\n   Keyword Purpose     name Sets the name of the container environment.   app_insights_instance Specifies an App Insights instance. All apps will receive the instrumentation key as a setting, and Dapr will be configured to send logs there.   log_analytics_instance Specifies a Log Analytics workspace where container logs should be sent. If none is provided, one will automatically be created.   internal_load_balancer_state Sets whether an internal load balancer should be used for load balancing traffic to container app replicas.   add_container Adds a single container app to the environment.   add_containers Adds one or more container apps to the environment.   add_dapr_component Adds a dapr component to the environment.   add_dapr_components Adds one or more dapr component to the environment.   app_insights_instance Links an App Insights instance to this environment. All containers will be configured to use this AI instance, as well as DAPR.     Also supports Tagging and Dependencies.\n Container Apps Builder The Container Apps builder (containerApp) is used to define one or more container apps to add to the container environment.\n   Keyword Purpose     name Sets the name of the container app.   add_identity Adds a managed identity to the the container app.   ingress_state Activates or deactivates the ingress of the Azure Container App.   ingress_target_port Activates the ingress of the Azure Container App and sets the target port.   ingress_transport Activates the ingress of the Azure Container App and sets the transport mode.   system_identity Activates the system identity of the Azure Container App.   dapr_app_id Sets the dapr app id for the app.   dapr_app_port Sets the dapr app port for the app.   replicas Sets the minimum and maximum replicas to scale the container app.   active_revision_mode Indicates whether multiple version of a container app can be active at once.   add_registry_credentials Adds container image registry credentials for images in this container app, which are a list of server and usernames. Passwords are supplied as secure parameters.   reference_registry_credentials Adds container image registry credentials for images in this container app in the form of a list of Azure resource ids.   add_managed_identity_registry_credentials Adds container app registry managed identity credentials for images in this container app, which are a list of server and identities.   add_containers Adds a list of containers to this container app. All containers in the app share resources and scaling.   add_simple_container Adds a single container that references a public docker image and version.   add_secret_parameter Adds an application secret to the entire container app. This is passed as a secure parameter to the template, and an environment variable is automatically created which references the secret.   add_secret_parameters Adds application secrets to the entire container app. This is passed as secure parameters to the template, and environment variables are automatically created which reference the secret.   add_secret_expression As per add_secret_parameter, but the value is sourced from an ARM expression instead of as a parameter. Useful for e.g. storage keys etc.   add_secret_expressions As per add_secret_parameters, but the values are sourced from an ARM expressions instead of as parameters. Useful for e.g. storage keys etc.   add_env_variable Adds a static, plain text environment variable.   add_env_variables Adds static, plain text environment variables.   add_volumes Adds volumes to a container app so they are accessible to containers.    Scale Rules The Container App Builder supports a number of KEDA scale rules out of the box:\n   Scale Rule Keyword Purpose     add_http_scale_rule Adds a scale rule for HTTP concurrent requests.   add_cpu_scale_rule Adds a scale rule for CPU usage, either utilisation or average value.   add_memory_scale_rule Adds a scale rule for Memory usage, either utilisation or average value.   add_servicebus_scale_rule Adds a scale rule for service bus queues message count.   add_eventhub_scale_rule Adds a scale rule for event hub events.   add_queue_scale_rule Adds a scale rule for Azure Storage Queue length.   add_custom_scale_rule Adds a custom scale rule. Provide an object that matches the KEDA specification.     The Azure Storage Queue Scale Rule integration is \u0026ldquo;smart\u0026rdquo; - provide a reference to the storage account, queue name and length threshold; all appropriate settings and secrets will be automatically configured for you.\n Container Builder The Container builder (container) is used to define one or more containers for a container app.\n   Keyword Purpose     name Sets the name of the container.   public_docker_image Sets a public container image.   private_docker_image Sets a private container image.   cpu_cores Specifies the CPU cores allocated to the container (maximum 2.0).   memory Specifies the memory in gigabytes allocated to the container (maximum 4.0).   add_volume_mount Adds a volume mount on a container from a volume in the container app.    Dapr Component Builder The Dapr Component builder (daprComponent) is used to define one or more dapr components for a container environment. | Keyword | Purpose | |-|-| | name | Sets the name of the dapr component. | | component_type | Sets the dapr component type. | | ignore_errors | Sets whether component errors are ignored. | | init_timeout | Sets the initialization timeout. | | add_metadata | Adds a piece of metadata to the dapr component. | | add_secret_metadata | Adds a piece of metadata that references a secret to the dapr component. | | add_scope | Adds a scope, can either be a string or a reference to a container app. | | add_scopes | Adds one or more scopes, can either be strings or references to container apps. | | version | Sets the dapr component version. | | cron_binding | Helper for setting fields required for a cron binding | | azure_storage_queue_binding | Helper for setting fields required for an Azure Storage Queue binding | | azure_servicebus_queues_pubsub | Helper for setting fields required for an Azure Service Bus Queue |\nExample open Farmer open Farmer.Builders open Farmer.Arm let storageName = $\u0026#34;{Guid.NewGuid().ToString().[0..5]}containerqueue\u0026#34; let myStorageAccount = storageAccount { name storageName add_queue queueName add_file_share \u0026#34;certs\u0026#34; } containerEnvironment { name \u0026#34;my-container-app\u0026#34; add_containers [ containerApp { name \u0026#34;httpservice\u0026#34; activeRevisionsMode ActiveRevisionsMode.Single reference_registry_credentials [ ContainerRegistry.registries.resourceId \u0026#34;myazurecontainerregistry\u0026#34; ] add_volumes [ Volume.emptyDir \u0026#34;empty-v\u0026#34; Volume.azureFile \u0026#34;certs-v\u0026#34; (ResourceName \u0026#34;certs\u0026#34;) myStorageAccount.Name StorageAccessMode.ReadOnly ] add_containers [ container { name \u0026#34;myservice1\u0026#34; public_docker_image containerRegistryDomain containerRegistry \u0026#34;myimage1\u0026#34; version memory 0.2\u0026lt;Gb\u0026gt; add_volume_mounts [ \u0026#34;empty-v\u0026#34;, \u0026#34;/tmp\u0026#34; ] } container { name \u0026#34;myservice2\u0026#34; public_docker_image containerRegistryDomain containerRegistry \u0026#34;myimage2\u0026#34; version cpu_cores 0.5\u0026lt;VCores\u0026gt; memory 1.0\u0026lt;Gb\u0026gt; add_volume_mounts [ \u0026#34;certs-v\u0026#34;, \u0026#34;/certs\u0026#34; ] } ] replicas 1 5 ingress_target_port 80us ingress_transport Auto dapr_app_id \u0026#34;httpservice\u0026#34; add_http_scale_rule \u0026#34;http-rule\u0026#34; { ConcurrentRequests = 100 } } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/communication-services/","title":"Communication Services","tags":[],"description":"","content":"Overview The Communication Services builder is used to create Azure Communication Services instances.\n Communication Services (Microsoft.Communication/communicationServices)  Builder Keywords    Keyword Purpose     name Sets the name of the Communication Services instance.   data_location Sets the dataLocation property of the instance. Defaults to United States    Configuration Members    Member Purpose     Key Gets the ARM expression path to the Key of this Communication Services instance.   Key Gets the ARM expression path to the Connection String of this Communication Services instance.    Example open Farmer open Farmer.Builders let tags = [ \u0026#34;a\u0026#34;, \u0026#34;1\u0026#34;; \u0026#34;b\u0026#34;, \u0026#34;2\u0026#34; ] let cs = communicationService { name \u0026#34;test\u0026#34; add_tags tags data_location DataLocation.Australia } let key : ArmExpression = cs.Key "},{"uri":"https://compositionalit.github.io/farmer/tutorials/","title":"Tutorials","tags":[],"description":"","content":"This section contains tutorials for specific use-cases. Use these to help get ideas for how to model your Farmer resources!\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/dependencies/","title":"Dependencies","tags":[],"description":"","content":"ARM resources can depend on one another, and Farmer caters for this as well. Dependencies guarantee that when resources are created, Azure will provision them in the correct order so that e.g. a storage account is created before Azure tries to grab the storage account key / connection string for your web app setting.\nMuch of this work is done for you:\n Farmer creates multiple resources for you at the builder level, and will ensure that the appropriate dependencies are set for you - for example, when creating a SQL Azure instance, Farmer will automatically ensure that the database depends on the server. Farmer will generally identify dependencies correctly when you have a relationship between builders, such as setting the key of a storage account on a web app.  Automatic dependency detection In the sample below, the web app { } will automatically realise that it needs to depend on Storage Account based on the \u0026ldquo;owner\u0026rdquo; of Key expression that is supplied.\nlet myStorage = storageAccount { name \u0026#34;sampleaccount\u0026#34; } let myApp = webApp { name \u0026#34;myapp\u0026#34; setting \u0026#34;storage_key\u0026#34; myStorage.Key } Manually setting dependencies Normally, Farmer will do everything you need. However, there are some times when you may need to explicitly set a dependency:\n Farmer has not automatically detected the dependencies (please raise an issue if you notice this!). You\u0026rsquo;re setting a dependency on a resource that you\u0026rsquo;re creating yourself, outside of Farmer. You want to set a dependency even though there is no explicit coupling between two resources / builders.  Setting a dependency requires you to call the depends_on keyword on the target resource, providing a handle to the dependent resource.\nlet myStorage1 = storageAccount { name \u0026#34;sampleaccountFirst\u0026#34; } let myApp = webApp { name \u0026#34;myapp\u0026#34; depends_on myStorage1 } Here, we set up an explicit dependency on myApp for myStorage.\nAdding multiple dependencies at once You can also supply multiple dependencies at once as a list; this is useful if you are programmatically creating multiple resources.\n// Create five storage accounts let storageAccounts : IBuilder list = [ for letter in [ \u0026#39;a\u0026#39; .. \u0026#39;e\u0026#39; ] do storageAccount { name $\u0026#34;mystorage{letter}\u0026#34; } ] let myApp = webApp { name \u0026#34;myapp\u0026#34; depends_on storageAccounts // add them all to the web app as dependencies } Notice the extra type hint, : IBuilder list. This is required because F# does not, by default, allow you to implicitly treat a list of values as a supertype. In this case, a StorageAccountConfig list is not considered implicitly convertable to : IBuilder list (which is an interface that StorageAccountConfig implements). Therefore, we have to do it ourselves using the extra type declaration.\nYou can also use the :\u0026gt; (safe upcast) operator when declaring the StorageAccount:\nlet storageAccounts = [ // inferred as IBuilder list  for letter in [ \u0026#39;a\u0026#39; .. \u0026#39;e\u0026#39; ] do storageAccount { name $\u0026#34;mystorage%c\u0026#34; letter) } :\u0026gt; IBuilder ]  We\u0026rsquo;re looking at improving this situation in the future using F#\u0026lsquo;s \u0026ldquo;flexible types\u0026rdquo; feature.\n All builders that support dependencies support a number of depends_on overloads:\n A single, or a list of, Builders (as shown above) A single, or a list of, resources by their Name A single, or a list of, IArmResources  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/outputs/","title":"Outputs","tags":[],"description":"","content":"ARM templates also support the notion of outputs. Outputs can be used to provide your Farmer applications with values which were generated during the deployment process, to be used further downstream.\nFor example, you may wish to prime an Azure storage account with data post-creation. In this case, one way is to return back out the connection string of the storage account and use that to connect and upload your data.\nCreating and Consuming outputs Outputs are applied onto the arm { } builder using the output keyword.\nlet myStorage = storageAccount { name \u0026#34;sampleaccount\u0026#34; } let template = arm { add_resource myStorage output \u0026#34;storage_key\u0026#34; myStorage.Key } let outputs = template |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [] let connectionString = outputs.[\u0026#34;storage_key\u0026#34;] Outputs are returned back from the deployment as a simple Map\u0026lt;string, string\u0026gt;.\nAny ARM expression can be returned as an output, and you can create as many outputs as you wish.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-group/","title":"Container Group","tags":[],"description":"","content":"Overview The Container Group builder is used to create Azure Container Group instances.\n Container Group (Microsoft.ContainerInstance/containerGroups) Network Profile (Microsoft.Network/networkProfiles)  Container Group Builder The Container Group builder (containerGroup) defines a Container Group.\n   Keyword Purpose     name Sets the name of the container group.   add_instances Adds container instances to the group.   operating_system Sets the OS type (default Linux).   restart_policy Sets the restart policy (default Always)   public_dns Sets the DNS host label when using a public IP.   private_ip Indicates the container should use a system-assigned private IP address for use in a virtual network.   network_profile (deprecated) Name of a network profile resource for the subnet in a virtual network where the container group will attach.   vnet Resource ID of a virtual network where the container group will attach.   link_to_vnet Resource ID of an existing virtual network where the container group will attach.   subnet Name of the subnet in a virtual network where the container group will attach.   add_identity Adds a managed identity to the the container group.   link_to_identity Links an existent managed identity to the container group.   system_identity Activates the system identity of the container group.   add_registry_credentials Adds a container image registry credential with a secure parameter for the password.   reference_registry_credentials References credentials from a container image registry by resource ID.   add_managed_identity_registry_credentials Adds container image registry managed identity credentials for images in this container group.   add_tcp_port Adds a TCP port to be externally accessible.   add_udp_port Adds a UDP port to be externally accessible.   add_volumes Adds volumes to a container group so they are accessible to containers.   availability_zone Deploys a container group to a specific availability zone.   diagnostics_workspace Sends logs to a diagnostics workspace included in the same deployment.   diagnostics_workspace_key Sends logs to a diagnostics workspace by workspace ID and key.   link_to_diagnostics_workspace Sends logs to an existing diagnostics workspace referenced by resource ID.   dns_nameservers Specify DNS nameservers for the containers in a vnet-attached container group.   dns_options Specify DNS options (e.g. \u0026lsquo;ndots:2\u0026rsquo;) for the containers in a vnet-attached container group.   dns_search_domains Specify DNS search domains for the containers in a vnet-attached container group.   depends_on Specifies the resource or resource ID of resources that must exist before the container group is created.    Container Instance Builder The Container Instance builder (containerInstance) is used to define one or more containers to add to the group.\n   Keyword Purpose     name Sets the name of the container instance.   image Sets the container image.   command Sets the commands to execute within the container instance in exec form.   add_ports Sets the ports the container exposes.   cpu_cores Sets the maximum CPU cores the container may use.   memory Sets the maximum gigabytes of memory the container may use.   gpu Adds one or more GPUs to the container.   env_vars Sets a list of environment variables for the container.   add_volume_mount Adds a volume mount on a container from a volume in the container group.   probes Adds liveliness and readiness probes to a container.    Init Container Instance Builder The Init Container builder (initContainer) is used to define one or more init containers which must fully start before the rest of the containers in the group.\n   Keyword Purpose     name Sets the name of the init container.   image Sets the init container image.   command Sets the commands to execute within the init container in exec form.   env_vars Sets a list of environment variables for the init container.   add_volume_mount Adds a volume mount on an init container from a volume in the container group.    Network Profile Builder The Network Profile builder (networkProfile) is used to define a network profile to connect the container group to a subnet on a virtual network.\n   Keyword Purpose     name Name of the container network profile for connecting a container group to a virtual network.   vnet Resource name of the virtual network to connect (if created in the same deployment).   link_to_vnet Resource name of an existing virtual network to connect.   subnet Name of the subnet in the virtual network where the container group should attach.   ip_config Name of the IP configuration and subnet in the virtual network where the container group should attach.   add_ip_configs Adds multiple IP configurations to connect the container group to multiple subnets.    GPU Builder    Keyword Purpose     count the amount of GPUs attached to the container   sku SKU for the GPU    Liveness Probe Builder The Liveness Probe builder (liveness) is used to define a liveness probe for a container instance to determine if it is healthy.\n   Keyword Purpose     http Sets the http GET URI on a container liveliness check.   exec Sets a command to execute on a container liveliness check.   initial_delay_seconds Sets a delay after container startup before the first check - default is 0 seconds.   period_seconds Sets the period between running checks - default is 10 seconds.   failure_threshold Sets the number of times a check can fail before the container is considered unhealthy and will be restarted - default is 3.   success_threshold Sets the number of times a check must succeed before the container is considered healthy - default is 1.   timeout_seconds Sets the number of seconds a check is allowed to run before considering the check a failure - default is 1 second.    Readiness Probe Builder The Readiness Probe builder (readiness) is used to define a readiness probe for a container instance to determine if it is ready to accept requests.\n   Keyword Purpose     http Sets the http GET URI on a container readiness check.   exec Sets a command to execute on a container readiness check.   initial_delay_seconds Sets a delay after container startup before the readiness check - default is 0 seconds.   period_seconds Sets the period between running checks - default is 10 seconds.   failure_threshold Sets the number of times a check can fail before the container is considered unhealthy and will be restarted - default is 3.   success_threshold Sets the number of times a check must succeed before the container is considered healthy - default is 1.   timeout_seconds Sets the number of seconds a check is allowed to run before considering the check a failure - default is 1 second.    Example open Farmer open Farmer.Builders open Farmer.ContainerGroup let storage = storageAccount { name \u0026#34;mystorage\u0026#34; } let nginx = containerInstance { name \u0026#34;nginx\u0026#34; image \u0026#34;nginx:1.17.6-alpine\u0026#34; add_ports PublicPort [ 80us; 443us ] add_ports InternalPort [ 9090us; ] memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 1 env_vars [ EnvVar.create \u0026#34;CONTENT_PATH\u0026#34; \u0026#34;/www\u0026#34; EnvVar.createSecure \u0026#34;SECRET_PASSWORD\u0026#34; \u0026#34;shhhhhh!\u0026#34; EnvVar.createSecureExpression \u0026#34;STORAGE_CONN_STRING\u0026#34; storage.Key ] add_volume_mount \u0026#34;secret-files\u0026#34; \u0026#34;/config/secrets\u0026#34; add_volume_mount \u0026#34;source-code\u0026#34; \u0026#34;/src/farmer\u0026#34; probes [ liveliness { http \u0026#34;http://localhost:80/\u0026#34; initial_delay_seconds 15 } ] } let containerGroupUser = userAssignedIdentity { name \u0026#34;aciUser\u0026#34; } let containerGroupLoggingWorkspace = logAnalytics { name \u0026#34;webapplogs\u0026#34; } let managedIdentity = ManagedIdentity.Empty let group = containerGroup { name \u0026#34;webApp\u0026#34; operating_system Linux diagnostics_workspace LogType.ContainerInstanceLogs containerGroupLoggingWorkspace restart_policy AlwaysRestart add_identity containerGroupUser add_udp_port 123us add_instances [ nginx ] // Add registry credentials as a secure password  add_registry_credentials [ registry \u0026#34;mygregistry.azurecr.io\u0026#34; \u0026#34;registryuser\u0026#34; managedIdentity ] // or reference an Azure container registry to pull the credentials directly.  reference_registry_credentials [ ResourceId.create (Arm.ContainerRegistry.registries, ResourceName \u0026#34;my-gregistry\u0026#34;, \u0026#34;acr-resource-group\u0026#34;) ] add_volumes [ volume_mount.secret_string \u0026#34;secret-files\u0026#34; \u0026#34;secret1\u0026#34; \u0026#34;abcdefg\u0026#34; volume_mount.git_repo \u0026#34;source-code\u0026#34; (Uri \u0026#34;https://github.com/CompositionalIT/farmer\u0026#34;) ] } Private Virtual Network Example Attaching a container group to a virtual network requires adding a service delegation on a subnet indicating it is for container groups, adding a network profile to bind the container group interface to that subnet, and finally adding the container group itself with a private IP address.\nopen Farmer open Farmer.Builders let privateNetwork = vnet { name \u0026#34;private-vnet\u0026#34; add_address_spaces [ \u0026#34;10.30.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;ContainerSubnet\u0026#34; prefix \u0026#34;10.30.19.0/24\u0026#34; add_delegations [ SubnetDelegationService.ContainerGroups ] } ] } let aciProfile = networkProfile { name \u0026#34;vnet-aci-profile\u0026#34; vnet \u0026#34;private-vnet\u0026#34; subnet \u0026#34;ContainerSubnet\u0026#34; } let myContainer = container { name \u0026#34;helloworld\u0026#34; image \u0026#34;microsoft/aci-helloworld\u0026#34; add_ports PublicPort [ 80us ] } let group = containerGroup { name \u0026#34;webApp\u0026#34; operating_system Linux restart_policy AlwaysRestart add_instances [ myContainer ] network_profile \u0026#34;vnet-aci-profile\u0026#34; private_ip [TCP, 80us] } Execute container command example Modified from azure-cli example here: https://docs.microsoft.com/en-us/azure/container-instances/container-instances-start-command\nopen Farmer open Farmer.Builders open Farmer.ContainerGroup let wordcount = containerInstance { name \u0026#34;mycontainer1\u0026#34; image \u0026#34;mcr.microsoft.com/azuredocs/aci-wordcount:latest\u0026#34; memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 1 env_vars [ env_var \u0026#34;NumWords\u0026#34; \u0026#34;3\u0026#34; env_var \u0026#34;MinLength\u0026#34; \u0026#34;5\u0026#34; ] command_line [ \u0026#34;python\u0026#34;; \u0026#34;wordcount.py\u0026#34;; \u0026#34;http://shakespeare.mit.edu/romeo_juliet/full.html\u0026#34; ] } let group = containerGroup { name \u0026#34;wordcount\u0026#34; operating_system Linux restart_policy RestartOnFailure add_instances [ wordcount ] } Using an initContainer on startup An initContainer will run on container group startup before any of the containers are executed.\nIf there are any issues with the initContainer, it will remain in a \u0026lsquo;Creating\u0026rsquo; state indefinitely. Check for issues by viewing the logs for the init container(s):\naz container logs -g resource-group-name -n container-group-name --container-name init-container-name\nThe example below creates a volume mount that is shared between the initContainer and the container instances. It writes to a file so that the nginx container can serve that file once the group is running.\narm { location Location.WestEurope add_resources [ containerGroup { name \u0026#34;container-group-with-init\u0026#34; operating_system Linux restart_policy ContainerGroup.AlwaysRestart add_volumes [ volume_mount.empty_dir \u0026#34;html\u0026#34; ] add_init_containers [ initContainer { name \u0026#34;write-index-file\u0026#34; image \u0026#34;debian\u0026#34; add_volume_mount \u0026#34;html\u0026#34; \u0026#34;/usr/share/nginx/html\u0026#34; command_line [ \u0026#34;/bin/sh\u0026#34; \u0026#34;-c\u0026#34; \u0026#34;mkdir -p /usr/share/nginx/html \u0026amp;\u0026amp; echo \u0026#39;hello there\u0026#39; \u0026gt;\u0026gt; /usr/share/nginx/html/index.html\u0026#34; ] } ] add_instances [ containerInstance { name \u0026#34;nginx\u0026#34; image \u0026#34;nginx:alpine\u0026#34; add_volume_mount \u0026#34;html\u0026#34; \u0026#34;/usr/share/nginx/html\u0026#34; add_public_ports [ 80us; 443us ] memory 0.5\u0026lt;Gb\u0026gt; cpu_cores 0.2 } ] } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/container-registry/","title":"Container Registry","tags":[],"description":"","content":"Overview The Container Registry builder is used to create Azure Container Registry (ACR) instances.\n Container Registry (Microsoft.ContainerRegistry/registries)  Builder Keywords    Keyword Purpose     name Sets the name of the Container Registry instance.   sku Sets the SKU of the instance. Defaults to Basic.   enable_admin_user The value that indicates whether the admin user is enabled.    Configuration Members    Member Purpose     Password Gets the ARM expression path to the first admin password of this container registry if admin user was enabled.   Password2 Gets the ARM expression path to the second admin password of this container registry if admin user was enabled.   Username Gets the ARM expression path to the admin username of this container registry if admin user was enabled.    Example open Farmer open Farmer.Builders let myRegistry = containerRegistry { name \u0026#34;myRegistry\u0026#34; sku ContainerRegistry.Basic enable_admin_user } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cognitive-services/","title":"Cognitive Services","tags":[],"description":"","content":"Overview The Cognitive Services builder is used to create Azure Cognitive Services instances.\n Cognitive Services (Microsoft.CognitiveServices/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Cognitive Services instance.   sku Sets the SKU of the instance. Defaults to F0 (free).   api Specifies the Kind of api to use for the service instance. Defaults to AllInOne.    Configuration Members    Member Purpose     Key Gets the ARM expression path to the Key of this Cognitive Services instance.    Example open Farmer open Farmer.Builders let translator = cognitiveServices { name \u0026#34;mytranslator\u0026#34; sku CognitiveServices.F0 api CognitiveServices.AnomalyDetector } let key : ArmExpression = translator.Key BingSearch (obsolete) Starting from 1.4.0 BingSearch api is available as a part of bingSearch builder instead of cognitiveServices.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/","title":"API Overview","tags":[],"description":"","content":"API aims The key guiding principles of the Farmer API are (in order):\n Simplicity: Make it as easy as possible to do the most common tasks. Type safety: Where possible, use F#\u0026lsquo;s type system to make it impossible to create invalid templates. Flexibility: Provide users with the ability to override the defaults where needed.  Farmer Resources Farmer works on a simple, consistent process:\n You create Farmer resources, such as Storage Accounts and Web Apps. Each Farmer resource can represent one or many ARM resources. For example, a Farmer webApp resource represents both the Microsoft.Web/sites and Microsoft.Web/serverfarms resources. In addition, it optionally also provides simplified access to an Microsoft.Insights/components. You configure each resource using simple, human-readable custom keywords in a strongly-typed environment. You link together resources as required. Once you have created all resources, you bundle them up together into an ARM deployment resource. You then generate (and optionally deploy) an ARM template. The rest of your deployment pipeline stays the same.  The diagram below illustrates how Farmer resources map to ARM ones:\ngraph TD subgraph ARM Template classDef danger fill:orange; C(Microsoft.Web/serverfarms) -. dependency .-F D(Microsoft.Insights/components) -. dependency .-F E(Microsoft.Storage/storageAccounts) -. dependency .-F E -. storage key .- F E -. storage key .- G F(Microsoft.Web/sites) G(blobServices/containers) class C danger class D danger class E danger class F danger class G danger end subgraph Farmer A(webApp)-. depends on .-B B(storageAccount)-. key .-A end  In this example, we create a storage account and web app in Farmer, which maps five different ARM template resources. As you can see, resources in Farmer are declared at a higher level of abstraction than ARM template resources. This makes things much simpler to reason about, and quicker to author.\nAn example Farmer Resource All Farmer resources follow the same approach:\n You define a resource using a special \u0026ldquo;builder\u0026rdquo; that allows the use of custom keywords. This is known as an F# computation expression. Each builder is designed for a specific type of Azure resource e.g. websites, functions, virtual machines etc., and each has defaults set for the most common scenario. This resource is validated and converted into a Farmer configuration object, which contains the configuration for that resource including any defaults. This configuration is then added to an overarching Farmer ARM deployment object. The ARM deployment object is converted into an ARM template json file.  graph LR subgraph JSON C(ARM Template) end subgraph .NET A(Farmer Builder)--validation and defaults --B B(Farmer Configuration) --emitted to -- C end  Here\u0026rsquo;s an example web application.\nlet myWebApp = webApp { name \u0026#34;mystorage\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku Sku.B1 always_on app_insights_off worker_size WorkerSize.Medium number_of_workers 3 run_from_package }  The webApp { } builder defines the start and end of the definition of the web application. Within this builder, you use custom keywords to configure the web app, such as name and setting. Some keywords take arguments, but others e.g. always_on are simple declarative markers.   You can view details of all farmer resources in the resource guide.\n Putting it all together The diagram above can be shown in code as follows:\n/// An Azure Storage account with a container. let storage = storageAccount { name \u0026#34;astorageaccount\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } /// An Azure App Service with built-in App Insights. let app = webApp { name \u0026#34;awebapp\u0026#34; setting \u0026#34;storageKey\u0026#34; storage.Key // pull in the storage key to an app setting  depends_on storage // state that this web app depends on the storage account } /// An ARM deployment with both of the above resources attached let deployment = arm { location Location.NorthEurope add_resource storage add_resource app } // Write the ARM template out to myTemplate.json let filename = deployment.Template |\u0026gt; Writer.toJson |\u0026gt; Writer.toFile \u0026#34;myTemplate\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cosmos-db/","title":"Cosmos DB","tags":[],"description":"","content":"Overview The CosmosDb package containers two builders, used to create databases and containers.\n CosmosDB Account (Microsoft.DocumentDb/databaseAccounts) CosmosDB SQL (Microsoft.DocumentDB/databaseAccounts/sqlDatabases) CosmosDB MongoDB (Microsoft.DocumentDB/databaseAccounts/mongodbDatabases) CosmosDB SQL Container (Microsoft.DocumentDb/databaseAccounts/sqlDatabases/containers)   There is currently only support for document databases (the so-called \u0026ldquo;SQL API\u0026rdquo;), with support for Gremlin, Table and Cassandra data models planned.\n Cosmos DB Builder The CosmosDB builder abstracts the idea of account and database into one. If you wish to \u0026ldquo;re-use\u0026rdquo; an already-created Cosmos DB account, use link_to_account keyword - no account will be created and the database will be attached to the existing one.\n   Applies To Keyword Purpose     Database name Sets the name of the database.   Database link_to_account Instructs Farmer to link this database to an existing Cosmos DB account rather than creating a new one.   Database throughput Sets the throughput with either \u0026ldquo;provisioned throughput\u0026rdquo; or \u0026ldquo;serverless\u0026rdquo;.   Database add_containers Adds a list of containers to the database.   Account account_name Sets the name of the CosmosDB account.   Account api (not yet implemented) Sets the API and data model to use \u0026ndash; currently defaults to \u0026ldquo;Core (SQL)\u0026quot;.   Account enable_public_network_access Enables public network access for the account.   Account disable_public_network_access Disables public network access for the account.   Account consistency_policy Sets the consistency policy of the database.   Account failover_policy Sets the failover policy of the database.   Account free_tier Registers this server with the free pricing tier, if supported and allowed by Azure.    Cosmos Container Builder The container builder allows you to create and configure a specific container that is attached to a cosmos database.\n   Keyword Purpose     name Sets the name of the container.   partition_key Sets the partition key of the container.   add_index Adds an index to the container.   exclude_path Excludes a path from the container index.    Example open Farmer open Farmer.Builders let myCosmosDb = cosmosDb { name \u0026#34;isaacsappdb\u0026#34; account_name \u0026#34;isaacscosmosdb\u0026#34; throughput 400\u0026lt;CosmosDb.RU\u0026gt; // or throughput Serverless  failover_policy CosmosDb.NoFailover consistency_policy (CosmosDb.BoundedStaleness(500, 1000)) add_containers [ cosmosContainer { name \u0026#34;myContainer\u0026#34; partition_key [ \u0026#34;/id\u0026#34; ] CosmosDb.Hash add_index \u0026#34;/path\u0026#34; [ CosmosDb.Number, CosmosDb.Hash ] exclude_path \u0026#34;/excluded/*\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/quickstart-3/","title":"Deploying to Azure","tags":[],"description":"","content":"Introduction In this exercise, you\u0026rsquo;ll update the application to deploy the generated ARM template to Azure directly from Farmer.\n Farmer generates normal ARM templates. You use all of the standard mechanisms for deploying ARM templates such as through the portal, Powershell, .NET or Azure CLI etc. This tutorial shows you a simple way to deploy templates from your development machine directly from within F#.\n Install the Azure CLI If you haven\u0026rsquo;t done so already, install the Azure CLI on your machine.\nDeploy the template As Farmer emits standard ARM templates, you can use all the standard ARM template deployment tools at your disposal - whether that\u0026rsquo;s Visual Studio, Powershell, or the Azure CLI. In our case, we can also use Farmer\u0026rsquo;s API which wraps around the Azure CLI.\nModify the application you created at the end of quickstart #2 so that instead of writing the template to a file, we deploy it directly:\ndeployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters |\u0026gt; ignore  Note that the Web Application and Storage Account names should be globally unique; they must be unique across Azure i.e. someone else can\u0026rsquo;t have another web app or storage account with the same name!\n Farmer will now create the ARM template, and also generate a batch / shell script which calls the Azure CLI. You\u0026rsquo;ll be prompted to login to Azure by the CLI, after which point it will create the named resource group in the location specified in the arm { } builder.\nWait until the process is completed and log into the Azure Portal. Navigate to the newly-created resource group and inspect the overview record list e.g.\nCongratulations - you\u0026rsquo;ve now created and deployed an ARM template entirely from F#!\nThe full application open Farmer open Farmer.Builders let myStorageAccount = storageAccount { name \u0026#34;yourfirststorageaccount\u0026#34; } let myWebApp = webApp { name \u0026#34;yourFirstFarmerApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key } let deployment = arm { location Location.NorthEurope add_resource myStorageAccount add_resource myWebApp } deployment |\u0026gt; Deploy.execute \u0026#34;myResourceGroup\u0026#34; Deploy.NoParameters |\u0026gt; ignore "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/3-ibuilder/","title":"3. The IBuilder interface","tags":[],"description":"","content":"Sometimes, ARM resources are captured at a level of abstraction that is too low for us to reason about. In such cases, we may wish to use the IBuilder interface. An IBuilder is not only even easier to consume by users than the F# record we looked at in the previous exercise, but can create multiple IArmResource objects at once. This is especially useful for more complex resources that tend to come in groups of two or three together - for example, Server Farm and Web Apps, or Cosmos DB Accounts, Databases and Containers. An IBuilder encapsulates the logic needed to create and configure all the resources together.\n In this example, the Container Registry builder only creates a single resource.\n Step 3.1: The Configuration Record The first step is to create a simple configuration record that contains any data that is required to be captured by the user. Often, this may map nearly 1:1 with the IArmResource - normally the main difference will be that you do not need to provide the Location here, as Farmer will automatically provide that for you.\n// src/Farmer/Arm/ContainerRegistry.fs let registries = ResourceType (\u0026#34;Microsoft.ContainerRegistry/registries\u0026#34;, \u0026#34;2019-05-01\u0026#34;) // src/Farmer/Builders.ContainerRegistry.fs type ContainerRegistryConfig = { Name : ResourceName Sku : Sku AdminUserEnabled : bool } interface IBuilder with member this.ResourceId = registries.resourceId this.Name member this.BuildResources location = [ { Name = this.Name Location = location Sku = this.Sku AdminUserEnabled = this.AdminUserEnabled } ] The IBuilder interface has two members:\n ResourceId - a field that is the identifying path of the resource (including resource type, version, and name). It\u0026rsquo;s used by Farmer when setting dependencies between multiple resources and for emitting the appropriate JSON. If you builder has several ARM resources, it should return the \u0026ldquo;main\u0026rdquo; resource in the builder that others would depend upon. BuildResources - a function takes the location that the resources should be deployed to, and should return the list of IArmResource resources that must be created - this is normally a relatively simple mapping. For more complex builders e.g. one which represent multiple IArmResource objects, your BuildResources function will emit a list of IArmResources.   It\u0026rsquo;s tempting to suggest simply applying IBuilder directly onto the IArmResource. You could probably do this, but the separation and clarity provided here is an important step, and gives freedom in the future to diverge the shapes of the builder and the underlying resource.\n Step 3.2 Test out the IBuilder. You can finish this exercise by confirming that your IBuilder works correctly:\nopen Farmer.Builders.ContainerRegistry let registries = { Name = ResourceName \u0026#34;my-registry\u0026#34; Sku = ContainerRegistry.Basic AdminUserEnabled = true } let deployment = arm { location Location.WestCentralUS add_resource registries } deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34;  Ensure that the location of WestCentralUS has been correctly applied to the emitted ARM template json file!\n "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/cdn/","title":"CDN","tags":[],"description":"","content":"Overview The CDN builder is used to create Azure Content Delivery Network instances.\n CDN Profile (Microsoft.Cdn/profiles) CDN Endpoint (Microsoft.Cdn/profiles/endpoints) CDN Custom Domain (Microsoft.Cdn/profiles/endpoints/customDomains)  There are three builders available:\n The CDN builder, which maps to a CDN profile. The Endpoint builder, which creates endpoints and custom domains. Endpoints are created within a CDN. The CDN Rule builder, which creates CDN rules with conditions and actions that can be added to an endpoint  CDN Builder Keywords    Keyword Purpose     name Sets the name of the CDN instance.   sku Sets the SKU of the CDN instance. Defaults to Standard Akamai.   add_endpoints Adds several endpoints to the CDN.    Endpoint Builder Keywords    Keyword Purpose     name Sets the name of the endpoint instance. If you do not set this, a name is generated based on the origin.   origin Sets the address of the origin and is used to auto-generate the endpoint name if none if supplied.   depends_on Sets dependencies on this endpoint.   add_compressed_content Adds a set of content types to compress.   query_string_caching_behaviour Specifies the Query String Caching Behaviour.   enable_http Enables HTTP delivery on the endpoint.   disable_http Disables HTTP delivery on the endpoint.   enable_https Enables HTTPS delivery on the endpoint.   disable_https Disables HTTPS delivery on the endpoint.   custom_domain Sets the custom domain name to use on the endpoint.   optimise_for Optimises delivery for a specific type of content.   add_rule Adds a single rule to the endpoint delivery policy.   add_rules Adds multiple rule to the endpoint delivery policy.    CDN Rule Builder Keywords    Keyword Purpose     name Sets the name of the rule.   order Sets the order of rule.   when_device_type Adds device type condition.   when_http_version Adds http version condition.   when_request_cookies Adds request cookies condition.   when_post_argument Adds post argument condition.   when_query_string Adds query string condition.   when_remote_address Adds remote address condition.   when_request_body Adds request body condition.   when_request_header Adds request header condition.   when_request_method Adds request method condition.   when_request_protocol Adds request protocol condition.   when_request_url Adds request URL condition.   when_url_file_extension Adds URL file extension condition.   when_url_file_name Adds URL file name condition.   when_url_path Adds URL path condition.   cache_expiration Adds cache expiration action.   cache_key_query_string Adds cache key query string action.   modify_request_header Adds modify request header action.   modify_response_header Adds modify response header action.   url_rewrite Adds URL rewrite action.   url_redirect Adds URL redirect action.     Storage Accounts and Web Apps have special support for CDN endpoints. You can supply a storage account or web app builders directly as the origin.\n Example let isaacWebApp = webApp { name \u0026#34;isaacsuperweb\u0026#34; app_insights_off } let isaacStorage = storageAccount { name \u0026#34;isaacsuperstore\u0026#34; } let isaacRule = cdnRule { name \u0026#34;isaacsuperrule\u0026#34; order 1 when_request_header \u0026#34;issac\u0026#34; Contains [\u0026#34;great\u0026#34;] ToLowercase modify_response_header Append \u0026#34;issac\u0026#34; \u0026#34;super\u0026#34; } let isaacCdn = cdn { name \u0026#34;isaacsupercdn\u0026#34; add_endpoints [ endpoint { origin isaacStorage optimise_for Cdn.OptimizationType.LargeFileDownload } endpoint { origin isaacWebApp disable_http } endpoint { name \u0026#34;custom-endpoint-name\u0026#34; origin \u0026#34;mysite.com\u0026#34; add_compressed_content [ \u0026#34;text/plain\u0026#34;; \u0026#34;text/html\u0026#34;; \u0026#34;text/css\u0026#34; ] query_string_caching_behaviour Cdn.BypassCaching add_rule isaacRule } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/dns-resolver/","title":"DNS Resolver","tags":[],"description":"","content":"Overview The DNS resolver resource provides a DNS endpoint for resources that have IP connectivity to a virtual network but aren\u0026rsquo;t directly attached to it such as VPN or ExpressRoute clients. It also provides outbound DNS resolution to enable resources in the virtual network to resolve DNS using external DNS servers, such as an on-premise DNS.\n DNS Resolver (Microsoft.Network/dnsResolvers) DNS Resolver Inbound Endpoint (Microsoft.Network/dnsResolvers/inboundEndpoints) DNS Resolver Outbound Endpoint (Microsoft.Network/dnsResolvers/outboundEndpoints) DNS Forwarding Ruleset (Microsoft.Network/dnsForwardingRulesets) DNS Forwarding Rules (Microsoft.Network/dnsForwardingRulesets/forwardingRules) DNS Forwarding Virtual Network Links (Microsoft.Network/dnsForwardingRulesets/virtualNetworkLinks)  DNS Resolver Builder Keywords    Applies To Keyword Purpose     dnsResolver name Sets the name of the DNS resolver.   dnsResolver vnet Sets the virtual network where the of the DNS resolver is attached.   dnsResolver link_to_vnet Links the resolver to an existing virtual network.   dnsResolver inbound_subnet If set, an inbound endpoint will be generated for this subnet with dynamic IP allocation. The subnet can only contain DNS resolver resources.   dnsResolver add_inbound_endpoints Add inbound endpoints to subnets and specify static or dynamic IP allocation.   dnsResolver outbound_subnet If set, an outbound endpoint will be generated for this subnet. The subnet can only contain DNS resolver resources.   dnsResolver add_outbound_endpoints Add outbound endpoints to additional subnets.   dnsResolver depends_on Deploy this DNS resolver after another resource is successfully deployed.   dnsResolver add_tag Adds a tag to this resource.   dnsResolver add_tags Adds a set of tags to this resource.   dnsInboundEndpoint name Sets the name of the DNS resolver inbound endpoint.   dnsInboundEndpoint dns_resolver Add the inbound endpoint to a DNS resolver in the same deployment.   dnsInboundEndpoint link_to_dns_resolver Links to an existing DNS resolver.   dnsInboundEndpoint subnet Specify a subnet in this deployment where the inbound endpoint will be added.   dnsInboundEndpoint link_to_subnet Create the inbound endpoint in an existing subnet.   dnsInboundEndpoint add_dynamic_ip Adds a dynamically assigned IP for the inbound endpoint in the subnet.   dnsInboundEndpoint add_static_ip Adds a statically assigned IP for the inbound endpoint in the subnet.   dnsInboundEndpoint depends_on Deploy this DNS inbound endpoint after another resource is successfully deployed.   dnsInboundEndpoint add_tag Adds a tag to this resource.   dnsInboundEndpoint add_tags Adds a set of tags to this resource.   dnsOutboundEndpoint name Sets the name of the DNS resolver outbound endpoint.   dnsOutboundEndpoint dns_resolver Add the outbound endpoint to a DNS resolver in the same deployment.   dnsOutboundEndpoint link_to_dns_resolver Links to an existing DNS resolver.   dnsOutboundEndpoint subnet Specify a subnet in this deployment where the outbound endpoint will be added.   dnsOutboundEndpoint link_to_subnet Create the outbound endpoint in an existing subnet.   dnsOutboundEndpoint depends_on Deploy this DNS outbound endpoint after another resource is successfully deployed.   dnsOutboundEndpoint add_tag Adds a tag to this resource.   dnsOutboundEndpoint add_tags Adds a set of tags to this resource.   dnsForwardingRuleset name Sets the name of the DNS forwarding ruleset.   dnsForwardingRuleset add_resolver_outbound_endpoints Applies this ruleset to one or more DNS resolver outbound endpoints in the same deployment.   dnsForwardingRuleset add_rules Adds one or more rules to forward DNS domain resolution to a DNS endpoint (IP and port).   dnsForwardingRuleset add_vnet_links Links this ruleset to one or more virtual networks to provide DNS resolution to resources in that virtual network. It does not need to be the same vnet where the resolver is created, but it must be in the same region.   dnsForwardingRuleset depends_on Deploy this DNS forwarding ruleset after another resource is successfully deployed.   dnsForwardingRuleset add_tag Adds a tag to this resource.   dnsForwardingRuleset add_tags Adds a set of tags to this resource.   dnsForwardingRule name Sets the name of the DNS forwarding rule.   dnsForwardingRule forwarding_ruleset_id Adds the rule an a forwarding ruleset defined in the same deployment.   dnsForwardingRule domain_name Specifies the domain to which the rules apply. A trailing dot \u0026lsquo;.\u0026rsquo; will be appended if not added since forwarding rules require it.   dnsForwardingRule state Enable or disable a rule.   dnsForwardingRule add_target_dns_servers Specify one or more DNS servers by IP and port as System.Net.IPEndPoint objects. These will be used to resolve requests for the domain_name in this rule.    Example - Inbound Endpoint To provide a private resolver for resources in a virtual network, add a subnet that is delegated to DNS resolvers and specify that as the inbound_subnet on a dnsResolver resource.\n#r \u0026#34;nuget: Farmer\u0026#34; open Farmer open Farmer.Builders open Farmer.Network arm { add_resources [ vnet { name \u0026#34;mynet\u0026#34; add_address_spaces [ \u0026#34;100.72.2.0/24\u0026#34; ] add_subnets [ subnet { name \u0026#34;resolver-subnet\u0026#34; prefix \u0026#34;100.72.2.240/28\u0026#34; add_delegations [ SubnetDelegationService.DnsResolvers ] } ] } dnsResolver { name \u0026#34;my-dns-resolver\u0026#34; vnet \u0026#34;mynet\u0026#34; inbound_subnet \u0026#34;resolver-subnet\u0026#34; } ] } Example - Outbound Endpoint and Ruleset To resolve DNS in a virtual network with a route to an on-premise DNS server (e.g. a vNet with a VPN gateway to on-premise), add a subnet that is delegated to DNS resolvers and specify that as the outbound_subnet on a dnsResolver resource. Define rules for the domains that should be forwarded to the on-premise DNS servers.\n#r \u0026#34;nuget: Farmer\u0026#34; open Farmer open Farmer.Builders open Farmer.Network arm { add_resources [ vnet { name \u0026#34;mynet\u0026#34; add_address_spaces [ \u0026#34;100.72.2.0/24\u0026#34; ] add_subnets [ subnet { name \u0026#34;resolver-subnet\u0026#34; prefix \u0026#34;100.72.2.240/28\u0026#34; add_delegations [ SubnetDelegationService.DnsResolvers ] } ] } dnsResolver { name \u0026#34;my-dns-resolver\u0026#34; vnet \u0026#34;mynet\u0026#34; add_outbound_endpoints [ dnsOutboundEndpoint { name \u0026#34;outbound-dns\u0026#34; link_to_subnet ( Farmer.Arm.Network.subnets.resourceId ( ResourceName \u0026#34;mynet\u0026#34;, ResourceName \u0026#34;resolver-subnet\u0026#34; ) ) } ] } dnsForwardingRuleset { name \u0026#34;route-dns-requests\u0026#34; depends_on [ Farmer.Arm.Network.virtualNetworks.resourceId (ResourceName \u0026#34;mynet\u0026#34;) ] add_resolver_outbound_endpoints [ // list of outbound endpoint IDs. These must be in a subnet that  // can reach the endpoint IPs for rules in this ruleset.  Farmer.Arm.Dns.dnsResolverOutboundEndpoints.resourceId ( ResourceName \u0026#34;my-dns-resolver\u0026#34;, ResourceName \u0026#34;outbound-dns\u0026#34; ) ] add_vnet_links [ // List of vnet IDs that will resolve domains using this ruleset.  Farmer.Arm.Network.virtualNetworks.resourceId (ResourceName \u0026#34;mynet\u0026#34;) ] add_rules [ // List of rule sets for domains in the on-premise network.  dnsForwardingRule { name \u0026#34;rule-1\u0026#34; domain_name \u0026#34;example.com\u0026#34; state Enabled add_target_dns_servers [ // On-premise DNS servers IP addresses and ports.  System.Net.IPEndPoint.Parse(\u0026#34;192.168.100.74:53\u0026#34;) System.Net.IPEndPoint.Parse(\u0026#34;192.168.100.75:53\u0026#34;) ] } ] } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/dashboard/","title":"Dashboard","tags":[],"description":"","content":"Overview Dashboards are a focused and organized view of your cloud resources in the Azure portal. Use dashboards as a workspace where you can monitor resources and quickly launch tasks for day-to-day operations.\n Microsoft.Portal dashboards (Microsoft.Portal/dashboards)  Builder Keywords    Keyword Purpose     name Sets the name of the dashboard.   title Sets the visible title of the dashboard. Default: Same as name   metadata Sets the metadata for the dashboard. Pre-defined DashboardMetadata objects: EmptyMetadata, CustomMetadata and Cache24h   add_markdown_part Create markdown lens part for the dashboard   add_video_part Create video part for the dashboard   add_virtual_machine_icon Create virtual machine status part for the dashboard   add_metrics_chart Create metrics results part for the resource given in parameters   add_webtest_results_part Create webtest results part for the dashboard   add_monitor_chart Create metrics results part for the resource given in parameters   add_custom_lens Create your own lens part for the dashboard    Example This example generally follows the simple example of https://docs.microsoft.com/en-us/azure/azure-portal/azure-portal-dashboards-structure\nopen Farmer open Farmer.Builders let vm = vm { name \u0026#34;foo\u0026#34;; username \u0026#34;foo\u0026#34; } let vmId = (vm :\u0026gt; IBuilder).ResourceId let dash = dashboard { name \u0026#34;myDashboard\u0026#34; title \u0026#34;Monitoring\u0026#34; depends_on vm add_markdown_part ( { x = 0; y = 0; rowSpan = 2; colSpan = 3 }, { title = \u0026#34;\u0026#34;; subtitle = \u0026#34;\u0026#34;; content = \u0026#34;## Azure Virtual Machines Overview\\r\\nNew team members should watch this video to get familiar with Azure Virtual Machines.\u0026#34; } ) add_markdown_part ( { x = 3; y = 0; rowSpan = 4; colSpan = 8 }, { title = \u0026#34;Test VM Dashboard\u0026#34;; subtitle = \u0026#34;Contoso\u0026#34;; content = \u0026#34;This is the team dashboard for the test VM we use on our team. Here are some useful links:\\r\\n\\r\\n1. [Getting started](https://www.contoso.com/tsgs)\\r\\n1. [Troubleshooting guide](https://www.contoso.com/tsgs)\\r\\n1. [Architecture docs](https://www.contoso.com/tsgs)\u0026#34; } ) add_video_part ( { x = 3; y = 0; rowSpan = 4; colSpan = 8 }, { title = \u0026#34;\u0026#34;; subtitle = \u0026#34;\u0026#34;; url = \u0026#34;https://www.youtube.com/watch?v=YcylDIiKaSU\u0026amp;list=PLLasX02E8BPCsnETz0XAMfpLR1LIBqpgs\u0026amp;index=4\u0026#34; } ) add_metrics_chart ( { x = 0; y = 4; rowSpan = 3; colSpan = 11 }, { interval = (System.TimeSpan(1,0,0) |\u0026gt; IsoDateTime.OfTimeSpan); metrics = [ Farmer.Arm.Dashboard.ChartResources.PercentageCPU ]; resourceId = vmId } ) add_virtual_machine_icon ({ x = 9; y = 7; rowSpan = 2; colSpan = 2 }, vmId) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/databricks-workspace/","title":"Databricks Workspace","tags":[],"description":"","content":"Overview The Databricks Workspace builder is used to create Azure Databricks Workspaces.\n Workspace (Microsoft.Databricks/workspaces)  Builder Keywords    Keyword Purpose     name Sets the name of the workspace.   sku Sets the pricing tier of the workspace. Defaults to Standard Tier.   encrypt_with_key_vault Given a key vault builder / resourceid / vault name, and the name of a key, activates the use of Key Vault for the key store.   encrypt_with_databricks Specifies to use DataBricks itself for key encryption.   encrypt_with Allows you to programmatically specify whether to use key vault or data bricks encryption.   key_vault_key_version Specifies the version of the key vault key to use; if this is not specified, the latest version of the key is used.   allow_public_ip Whether to use public IP addresses for cluster virtual machines. Defaults to Enabled.   attach_to_vnet Given a Resource Id / Name / VNet Config, and Public \u0026amp; Private Subnets, attaches the workspace to the VNet specified.   managed_resource_group_id Sets the name of the resource group that will be created by the workspace. Optional.    Example open Farmer open Farmer.Builders let myVault = keyVault { name \u0026#34;my-vault\u0026#34; } let myWorkspace = databricksWorkspace { name \u0026#34;my-databricks-workspace\u0026#34; sku Databricks.Sku.Standard encrypt_with_key_vault myVault \u0026#34;workspace-encryption-key\u0026#34; attach_to_vnet \u0026#34;databricks-vnet\u0026#34; \u0026#34;databricks-pub-snet\u0026#34; \u0026#34;databricks-priv-snet\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/deployment-script/","title":"Deployment Script","tags":[],"description":"","content":"Overview The Deployment Script builder is used to execute Azure CLI scripts as part of an ARM deployment.\n Deployment Script (Microsoft.Resources/deploymentScripts)  Builder Keywords    Keyword Purpose     name Sets the name of the deployment script resource.   arguments List of arguments to pass to the script.   cleanup_on_success The script will only be cleaned up on success to allow for inspection of failures.   cli Specifies the CLI runtime, default is az cli.   content Sets script content for the resource.   env_vars Defines environment variables in the script environment.   force_update_tag A tag that cn be changed to force a resource update so the script is run again.   identity Sets the user assigned identity for the deployment script resource (must be a contributor in the resource group).   primary_script_uri Sets a URI to download script content.   retention_interval Sets the hours to retain the script runtime infrastructure to run again quickly.   script_content Sets script content for the resource.   supporting_script_uris Sets a URI to download additional content for the script.   timeout Sets the maximum amount of time to allow the script to run.   depends_on Specifies the resource or resource ID of resources that must exist before script execution.   add_tags Adds tags to the script runtime resource.   add_tag Adds a tag to the script runtime resource.    Example open Farmer open Farmer.Builders /// The deployment script must run under an identity with any necessary permissions /// to perform the commands in the script. Also must be a contributor in the /// resource group. let scriptIdentity = userAssignedIdentity { name \u0026#34;script-user\u0026#34; } /// The script identity must be a contributor over this resource group. let scriptRole = role_assignment (ArmExpression.create(\u0026#34;guid(resourceGroup().id)\u0026#34;).Eval()) Roles.Contributor scriptIdentity.PrincipalId /// Define the parameters, identity, and content for the script let getDateScript = deploymentScript { name \u0026#34;custom-script\u0026#34; identity scriptIdentity force_update_tag (System.DateTime.Now.ToString(\u0026#34;o\u0026#34;)) /// Format output as JSON and pipe to $AZ_SCRIPTS_OUTPUT_PATH to make it available as an output variable.  content \u0026#34;\u0026#34;\u0026#34;printf \u0026#34;{\u0026#39;date\u0026#39;:\u0026#39;%s\u0026#39;\u0026#34;} \u0026#34;`date`\u0026#34; \u0026gt; $AZ_SCRIPTS_OUTPUT_PATH \u0026#34;\u0026#34;\u0026#34; } /// The deployment runs the script and gets any output variables. let template = arm { location Location.EastUS add_resource scriptIdentity add_resource scriptRole add_resource getDateScript output \u0026#34;date\u0026#34; \u0026#34;[reference(\u0026#39;custom-script\u0026#39;).outputs.date]\u0026#34; } Example with dependent resource let storage = storageAccount { name \u0026#34;storagewithstuff\u0026#34; add_public_container \u0026#34;public\u0026#34; } /// The deployment script can run azure CLI commands against resources in the /// same deployment by using \u0026#39;run_after\u0026#39; and referencing those resources. let script = deploymentScript { name \u0026#34;write-files\u0026#34; script_content \u0026#34;echo \u0026#39;hello world\u0026#39; \u0026gt; hello \u0026amp;\u0026amp; az storage blob upload --account-name storagewithstuff -f hello -c public -n hello\u0026#34; run_after (ResourceId.create (storageAccounts, storage.Name.ResourceName)) } let template = arm { location Location.EastUS add_resource storage add_resource script } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/dns/","title":"DNS Zone","tags":[],"description":"","content":"Overview The DNS Zone module contains two types of builders - dnsZone, used to create DNS Zones, and ___Record (like cnameRecord, aRecord, ..), used to create DNS Records sets. It supports most record types (except CAA) and has specific builders for every record type.\n DNS Zone (Microsoft.Network/dnsZones) A Record (Microsoft.Network/dnsZones/A) AAAA Record (Microsoft.Network/dnsZones/AAAA) CNAME Record (Microsoft.Network/dnsZones/CNAME) TXT Record (Microsoft.Network/dnsZones/TXT) MX Record (Microsoft.Network/dnsZones/MX) NS Record (Microsoft.Network/dnsZones/NS) PTR Record (Microsoft.Network/dnsZones/PTR) SOA Record (Microsoft.Network/dnsZones/SOA) SRV Record (Microsoft.Network/dnsZones/SRV)  SOA records You can only have one SOA record and it is always created alongside a DNS zone, whether you specify it or not.\nYou can use the builder provided by Farmer to edit any of its properties. You should not, however, edit the host as this is set automatically by Azure.\nIdeally it just wouldn\u0026rsquo;t be exposed, however contrary to the official documentation Azure rejects the ARM record if it is absent. For this reason if you wish to use the SOA builder it is recommended to first deploy your DNS Zone without it, copy the generated SOA host from the portal and then finally paste it into the Farmer builder\u0026rsquo;s host parameter.\nNS Records An NS record is automatically added to every DNS zone at the apex (@) containing the name of the Azure DNS servers assigned to the zone.\nYou can modify certain properties of it, but not others.\nIf you wish to create a new NS record set, you must give it a name field.\nTODO The following items are currently unsupported:\n CAA records Virtual network support for Private Zones Tags  DNS Zone Builder Keywords    Keyword Purpose     name Sets the name of the domain.   depends_on Deploy this DNS zone after another resource is successfully deployed.   zone_type Sets the zone type.   add_records Adds DNS Zone records (see below).    Each Record type has its own custom builder. All builders share the following common keywords:\n   Keyword Purpose     name Sets the name of the record set (default to @).   depends_on Deploy this DNS record after another resource is successfully deployed.   ttl Sets the time-to-live of the record set.   zone_type When set to Private changes the resource type from Microsoft.Network/dnsZone/x to Microsoft.Network/privateDnsZone/x. (default to Public)   link_to_dns_zone Add the record to a DNS zone in the same deployment.   link_to_unmanaged_dns_zone Add the record to an existing DNS zone.    In addition, each record builder has its own custom keywords:\nA Record Builder Keywords    Keyword Purpose     add_ipv4_addresses Add IPv4 addresses to this record set.   target_resource A reference to an azure resource from where the dns resource value is taken.    AAAA Record Builder Keywords    Keyword Purpose     add_ipv6_addresses Add IPv6 addresses to this record set.   target_resource A reference to an azure resource from where the dns resource value is taken.    CNAME Record Builder Keywords    Keyword Purpose     cname Sets the canonical name for this CNAME record.   target_resource A reference to an azure resource from where the dns resource value is taken.    TXT Record Builder Keywords    Keyword Purpose     add_values Add TXT values to this record set.    MX Record Builder Keywords    Keyword Purpose     add_values Add MX values to the record set.    NS Record Builder Keywords    Keyword Purpose     add_nsd_names Add NS values to this record set. (Subdomain NameServers)   add_nsd_reference Reference NS records from another DNS Zone. (Subdomain NameServers)    PTR Record Builder Keywords    Keyword Purpose     add_ptrd_names Add PTR names to this record set.    SRV Record Builder Keywords    Keyword Purpose     name The service and protocol must be specified as part of the record set name, prefixed with underscores.   add_values Add Farmer.DNS.SrvRecord values to this record set.    SOA Record Builder Keywords    Keyword Purpose     host Sets the host name for the record   email Sets the email for the record   expire_time Sets the expire time name for the record in seconds   minimum_ttl Sets the minimum time to live for the record in seconds   refresh_time Sets the refresh time for the record in seconds   retry_time Sets the retry time for the record in seconds   serial_number Sets the serial number for the record    Configuration Members    Member Purpose     NameServers Gets the ARM expression path to the NameServers. When evaluated, will return a JSON array as string.    Example #r \u0026#34;nuget: Farmer\u0026#34; open Farmer open Farmer.Builders let dns = dnsZone { name \u0026#34;farmer.com\u0026#34; zone_type Dns.Public add_records [ cnameRecord { name \u0026#34;www2\u0026#34; ttl 3600 cname \u0026#34;farmer.github.com\u0026#34; } aRecord { name \u0026#34;aName\u0026#34; ttl 7200 add_ipv4_addresses [ \u0026#34;192.168.0.1\u0026#34;; \u0026#34;192.168.0.2\u0026#34; ] } aaaaRecord { name \u0026#34;aaaaName\u0026#34; ttl 7200 add_ipv6_addresses [ \u0026#34;2001:0db8:85a3:0000:0000:8a2e:0370:7334\u0026#34; ] } txtRecord { name \u0026#34;txtName\u0026#34; ttl 3600 add_values [ \u0026#34;v=spf1 include:spf.protection.outlook.com -all\u0026#34; ] } mxRecord { name \u0026#34;mxName\u0026#34; ttl 7200 add_values [ 0, \u0026#34;farmer-com.mail.protection.outlook.com\u0026#34;; 1, \u0026#34;farmer2-com.mail.protection.outlook.com\u0026#34;; ] } soaRecord { name \u0026#34;soaName\u0026#34; host \u0026#34;ns1-09.azure-dns.com.\u0026#34; ttl 3600 email \u0026#34;test.microsoft.com\u0026#34; serial_number 1L minimum_ttl 300L refresh_time 3600L retry_time 300L expire_time 2419200L } srvRecord { name \u0026#34;_sip._tcp.name\u0026#34; ttl 3600 add_values [ { Priority = Some 100 Weight = Some 1 Port = Some 5061 Target = Some \u0026#34;farmer.online.com.\u0026#34;} ] } ] } let deployment = arm { location Location.NorthEurope add_resource dns } deployment |\u0026gt; Writer.quickWrite \u0026#34;dns-example\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/data-lake/","title":"Data Lake","tags":[],"description":"","content":"Overview The Data Lake builder is used to create Azure Data Lake instances.\n Data Lake (Microsoft.DataLakeStore/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Cognitive Services instance.   sku Sets the SKU of the instance. Defaults to Consumption.   enable_encryption Turns on data lake encryption.    Example open Farmer open Farmer.Builders let myLake = dataLake { name \u0026#34;myDataLake\u0026#34; sku DataLake.Commitment_100TB enable_encryption } "},{"uri":"https://compositionalit.github.io/farmer/arm-vs-farmer/","title":"Farmer and ARM","tags":[],"description":"","content":"    Farmer ARM Template     Core ARM features     Repeatable deployments? Yes, Farmer runs on top of ARM Yes   ARM deployment mechanisms? All, plus easy-to-use F# deployment All   Variables support? Yes, native support in F# Yes   Parameters support? Yes, native support in F# or secure parameters Yes   Supported resources? All, including custom builders for ~50 popular resources All   Declarative model support? Yes Yes   Support for all ARM tools? Yes, Farmer runs on top of ARM Yes   Linked Template support? No - generally not required. Yes   Authoring     Easy to author? Yes No   Easy to read? Yes No   Documented? Yes, website and discoverable intellisense Limited, documented but often out-of-date   Editor support? Yes, any F# editor including VS Code, VS and Rider Limited, only VS Code has any support   Safety     Type-safe? Yes, full support from the F# compiler and type system Limited through VS Code extension and LSP   Validation support? Edit-time, run-time, deploy-time Deploy-time and limited edit-time   Flexibility     Link resources easily? Yes Not easily complex path expressions must be known   Compose resources together? Yes Not easily   Create multiple resources simultaneously? Yes No, each resource must be defined separately   Create resources in several ways? Yes, builders, records, functions or classes No, must use JSON   Full programming language? Yes, F# is a simple yet powerful programming language No, JSON with limited functions   Imperative model? Yes, F# supports imperative programming No, you must program in a declarative style   Interop and extensibility     Add your own ARM resources? Yes, plug-in model to add new ARM resources N/A   Create your own combinations of resources? Yes No, each resource must be defined separately   Use external libraries? Yes, use any NuGet packages during authoring and full .NET Core No, fixed set of functions   Use in .NET applications? Yes, Farmer is a .NET Core library and can be used in-proc No, JSON files    "},{"uri":"https://compositionalit.github.io/farmer/quickstarts/template/","title":"The Farmer .NET Template","tags":[],"description":"","content":"Farmer comes with a .NET template that makes getting started easy.\nCreating a basic Farmer app The easiest way to create a Farmer app is to use the Farmer .NET Template.\ndotnet new -i Farmer.Template dotnet new Farmer  You only have to install the template once on your machine!\n This creates a new dotnet application solution and project that looks by default as follows:\nopen Farmer open Farmer.Builders let deployment = arm { location Location.NorthEurope } printf \u0026#34;Generating ARM template...\u0026#34; deployment |\u0026gt; Writer.quickWrite \u0026#34;output\u0026#34; printfn \u0026#34;all done! Template written to output.json\u0026#34; From here, you can add resources in the normal manner.\nBasic configuration options You can configure the template using the following optional arguments.\nARM Template filename The name of the ARM template JSON file e.g. --armTemplate myTemplate\nLocation The location to create resources in e.g. --location WestUS\nDeploy Configuration You can also configure the Farmer template to deploy to Azure out of the box using the --ci option. This has two modes of operation:\nAzure DevOps deployment This comes with a ready-made devops YAML file designed for simple CI/CD, using Farmer to generate ARM templates and Azdo to deploy using its own ARM Template deployment process. You should supply the following arguments:\n \u0026ndash;ci: Tells the template to create a Farmer app for use with Azure Devops. \u0026ndash;azureSubscription: Set the full name of the Azure Subscription that has been already configured in Azdo that has permission to deploy templates to Azure. \u0026ndash;resourceGroup: Set the name of the resource group that you wish to deploy to.  Direct deployment If you prefer a deployment process that is not coupled to Azure Devops, you can create a service principal in Azure and use the generated credentials in Farmer. Farmer will use its own wrapper around the Azure REST API to deploy to Azure, reporting progress to the console.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/diagnosticsetting/","title":" Diagnostic Settings ","tags":[],"description":"","content":"Overview The Diagnostic Settings builder is used to create diagnostic settings instances to send platform logs and metrics to different destinations (storage, event hub and log analytics). Support for Farmer builders and external resources is supported.\n Diagnostic Settings (providers/diagnosticSettings)  Builder Keywords    Keyword Purpose     name Sets the name of the Diagnostic Settings resource.   metrics_source The resource that will be used for the source of logging and metrics information. Can be any Builder, or you can supply a ResourceId for an external resource.   capture_metrics Specifies the list of Metrics to capture from the source resource.   capture_logs Specifies the list of Log Categories to capture from the source resource.   add_destination Adds a destination for all logs and metrics, either a storage account, log analytics workspacce, event hub or a Resource ID pointing to any valid Resource for those three resource types.   event_hub_destination_name Allows you to override the event hub name to use.   loganalytics_output_type If a Log Analytics Workspace is specified as output, specifies whether to use the default Azure Diagnostics grouping or a dedicated grouping for logging and metrics.    Example The example below illustrates how to create a web application and set up a diagnostics setting against it, whilst setting up three destinations for the diagnostics (storage, event hub and log analytics). Also notice the using of the Logging. namespace, which contains all documented Logging categories.\nopen Farmer open Farmer.Builders open Farmer.DiagnosticSettings let data = storageAccount { name \u0026#34;isaacsuperdata\u0026#34; } let hub = eventHub { name \u0026#34;isaacsuperhub\u0026#34; } let logs = logAnalytics { name \u0026#34;isaacsuperlogs\u0026#34; } let web = webApp { name \u0026#34;isaacdiagsuperweb\u0026#34;; app_insights_off } let mydiagnosticSetting = diagnosticSettings { name \u0026#34;myDiagnosticSetting\u0026#34; metrics_source web add_destination data add_destination logs add_destination hub loganalytics_output_type Dedicated capture_metrics [ \u0026#34;AllMetrics\u0026#34; ] capture_logs [ Logging.Web.Sites.AppServicePlatformLogs Logging.Web.Sites.AppServiceAntivirusScanAuditLogs ] } let deployment = arm { add_resources [ data; web; hub; logs; mydiagnosticSetting ] } "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/4-creating-builder-syntax/","title":"4. Providing Builder syntax","tags":[],"description":"","content":"If you want to get the nice json-like syntax for your configuration record, you need to implement a separate class which contains a set of methods that act on the Configuration Record that you created previously - one for each keyword that you want.\n If you need have not built your own computation expression before, here are some background resources for you:\n Office microsoft docs The \u0026ldquo;Computation Expressions\u0026rdquo; series Workshop   Step 4.1: Creating basic keywords We will not cover the inner details of creating a Computation Expression (CE) here. For now, just know that a CE is a basic class (yes, like a C# class) that is very similar to an immutable fluent API you might see in C#, except that in F# you can expose each fluent method as what looks like a new keyword.\nTo get started the only member you need to implement is the Yield method, which returns the \u0026ldquo;default\u0026rdquo; value of your record (i.e. before any fluent methods or keywords have been called).\n// Builder.ContainerRegistry.fs type ContainerRegistryBuilder() = /// Required - creates default \u0026#34;starting\u0026#34; values  member _.Yield _ = { Name = ResourceName.Empty Sku = Basic AdminUserEnabled = false } [\u0026lt;CustomOperation \u0026#34;name\u0026#34;\u0026gt;] /// Sets the name of the Azure Container Registry instance.  member _.Name (state:ContainerRegistryConfig, name) = { state with Name = ResourceName name } [\u0026lt;CustomOperation \u0026#34;sku\u0026#34;\u0026gt;] /// Sets the name of the SKU/Tier for the Container Registry instance.  member _.Sku (state:ContainerRegistryConfig, sku) = { state with Sku = sku } [\u0026lt;CustomOperation \u0026#34;enable_admin_user\u0026#34;\u0026gt;] /// Enables the admin user on the Azure Container Registry.  member _.EnableAdminUser (state:ContainerRegistryConfig) = { state with AdminUserEnabled = true } Each keyword has a similar set of steps required:\n Create a member which takes in at least one argument - the current state object, which represents your configuration record. The implementation should perform some update to the state and return back the newly-updated state. Don\u0026rsquo;t worry about \u0026ldquo;where\u0026rdquo; the state goes - the F# CE will \u0026ldquo;thread\u0026rdquo; the state between calls for you. Decorate the method with the CustomOperation attribute; the string value passed to it will become the keyword. Use _ to separate words of the keyword e.g. enable_admin_user. Put a /// comment on the method for intellisense to guide users.  Now you can create members on the builder that appear as custom operators in your resource CE. In each member you build up the state of the resource configuration you created in the previous step.\nStep 4.2 Consuming builders Firstly, create a single static instance of the ContainerRegistryBuilder class that you just made:\nlet containerRegistry = ContainerRegistryBuilder() Now, you can create Container Registries anywhere using the keyword syntax:\n/// myRegistry is of type ContainerRegistryConfig let myRegistry = containerRegistry { name \u0026#34;my-registry\u0026#34; sku Basic enable_admin_user } Parameterless keywords You can create parameterless keywords by simply only taking in the state argument e.g. enable_admin_user above.\nKeywords with multiple arguments You can take in multiple arguments by simply putting a comma after each additional argument. They will be consumed by the user with spaces.\nOverloaded keywords You can provide multiple overloads for a keyword. However, each overload must take in the same number of arguments. Do not re-apply the CustomOperation attribute - simply provide multiple methods with the same name.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/dedicated-hosts/","title":"Dedicated Hosts","tags":[],"description":"","content":"Overview The hostGroup and host builders create dedicated hosts in azure and their parent resource, a host group, to efficiently manage a physical host resource in Azure. Dedicated hosts are the same physical servers used in our data centers, provided as a resource. To learn more about dedicated hosts, reference the Azure Docs\n Host Group (Microsoft.Compute/hostGroups) Host (Microsoft.Compute/hostGroups/hosts)  Builder Keywords    Applies To Keyword Purpose     hostGroup name Name of the host group resource   hostGroup add_availability_zone Assign a zone to the host group.   hostGroup support_automatic_placement Feature flag for automatic placement of the VMs   hostGroup platform_fault_domain_count How many fault domains to support, depends on the region.   host name Name of the host resource   host license_type The licenses to bring the hosts, i.e. WindowsHybrid, WindowsPerpetual   host auto_replace_on_failure Feature flag whether to auto replace the host on failure   host sku name of the sku for the dedicated hosts. Valid sku\u0026rsquo;s vary by subscription, consult the Dedicated Host documentation   host platform_fault_domain Fault domain to assign the host   host parent_host_group Name of the host group to assign the hosts to    Example #r \u0026#34;nuget:Farmer\u0026#34; open Farmer open Farmer.Builders arm { location Location.EastUS add_resources [ hostGroup { name \u0026#34;myhostgroup\u0026#34; support_automatic_placement true add_availability_zone \u0026#34;1\u0026#34; platform_fault_domain_count 2 } host { name \u0026#34;myhost\u0026#34; parent_host_group (ResourceName \u0026#34;myHostGroup\u0026#34;) platform_fault_domain 2 sku \u0026#34;Fsv2-Type2\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/route-tables/","title":"Route Tables","tags":[],"description":"","content":"Overview The routeTable builder creates a route table to efficiently change default routing traffic between Azure subnets, virtual networks, and on-premises networks. To learn more about routeTables, reference the Azure Docs\n RouteTable (Microsoft.Network/routeTables) Route (Microsoft.Network/routeTables/routes)  Builder Keywords    Applies To Keyword Purpose     routeTable name Name of the NAT Gateway resource   routeTable disableBgpRoutePropagation Whether to disable the routes learned by BGP on that route table   routeTable add_routes The routes to be added to this route table   route name Name of the route resource   route addressPrefix The destination CIDR to which the route applies   route nextHopType The type of Azure hop the packet should be sent to   route nextHopIpAddress The IP address packets should be forwarded to. Only allowed in routes where the next hop type is VirtualAppliance   route hasBgpOverride Whether the route overrides overalpping BGP routes regardless of LPM    Example #r \u0026#34;nuget:Farmer\u0026#34; open Farmer open Farmer.Builders arm { location Location.EastUS add_resources [ routeTable { name \u0026#34;myroutetable\u0026#34; add_routes [ route { name \u0026#34;myroute\u0026#34; addressPrefix \u0026#34;10.10.90.0/24\u0026#34; nextHopIpAddress \u0026#34;10.10.67.5\u0026#34; } route { name \u0026#34;myroute2\u0026#34; addressPrefix \u0026#34;10.10.80.0/24\u0026#34; } route { name \u0026#34;myroute3\u0026#34; addressPrefix \u0026#34;10.2.31.0/24\u0026#34; nextHopType (Route.HopType.VirtualAppliance None) } route { name \u0026#34;myroute4\u0026#34; addressPrefix \u0026#34;10.2.31.0/24\u0026#34; nextHopType ( Route.HopType.VirtualAppliance( Some(System.Net.IPAddress.Parse \u0026#34;10.2.31.2\u0026#34;) ) ) } ] } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/nat-gateway/","title":"NAT Gateway","tags":[],"description":"","content":"Overview The natGateway builder creates a NAT Gateway to efficiently manage the SNAT traffic used by resources in a virtual network. By default, it creates a single static public IP for the NAT Gateway, but more IP addresses or prefixes of groups of addresses can be specified.\n NatGateway (Microsoft.Network/natGateways)  Builder Keywords    Applies To Keyword Purpose     natGateway name Name of the NAT Gateway resource   natGateway idle_timeout Timeout after which connections that have seen no traffic will be disconnected to free SNAT ports.    Example #r \u0026#34;nuget:Farmer\u0026#34; open Farmer open Farmer.Builders arm { location Location.EastUS add_resources [ natGateway { name \u0026#34;my-nat-gateway\u0026#34; } vnet { name \u0026#34;my-net\u0026#34; add_address_spaces [ \u0026#34;10.100.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;my-services\u0026#34; prefix \u0026#34;10.100.12.0/24\u0026#34; nat_gateway (Farmer.Arm.Network.natGateways.resourceId \u0026#34;my-nat-gateway\u0026#34;) } ] } ] } "},{"uri":"https://compositionalit.github.io/farmer/tutorials/traditional-ea/","title":"Traditional Enterprise Application to the Azure Cloud, managed via Farmer","tags":[],"description":"","content":"Introduction This tutorial shows how to create the basic infrastructure of an enterprise application (for example, migrating old on-premises application to cloud) and then how to build the supporting services for that.\nA traditional enterprise application has database and a server. Farmer supportrs both Microsoft SQL Server and PostgreSQL. This tutorial uses Microsoft version. For the server, we use a Virtual Machine (VM) which is basically your server in the cloud.\n  Virtual Machine and SQL Server\n  Creating the deployment template First we need a template project and a script for the deployment code. Create a new deployment application:\n Create a directory for your new application and enter it. Using the dotnet SDK, create a new console application: dotnet new console -lang F#. Install FAKE (which will be using to deploy the database) and Farmer:  dotnet add package Farmer dotnet add package Fake.Sql.SqlPackage dotnet add package Fake.DotNet.Cli dotnet add package Fake.Core.Target Then modify the Program.fs to have the following code:\nopen System open Fake.Core open Fake.Sql open Farmer open Farmer.Builders open Farmer.TrafficManager open Farmer.NetworkSecurity let execContext = Context.FakeExecutionContext.Create false \u0026#34;build.fsx\u0026#34; [ ] Context.setExecutionContext (Context.RuntimeContext.Fake execContext) let runOrDefault args = try match args with | [| target |] -\u0026gt; Target.runOrDefault target | _ -\u0026gt; Target.runOrDefault \u0026#34;All\u0026#34; 0 with e -\u0026gt; printfn \u0026#34;%A\u0026#34; e 1 let mutable dbConnectionString = \u0026#34;\u0026#34; // to transfer over Fake-tasks.  /// Create Remote desktop file for VM let createRemoteDesktopFile machineName (ip:string) loginName = if ip.Contains \u0026#34;/\u0026#34; then Console.WriteLine $\u0026#34;Invalid ip: {ip}\u0026#34; else let content = $\u0026#34;full address:s:{ip}:3389\\r\\nusername:s:{machineName}\\{loginName}\\r\\nprompt for credentials:i:1\\r\\nadministrative session:i:1\u0026#34; System.IO.File.WriteAllText(machineName + \u0026#34;.rdp\u0026#34;, content) /// Here we will instert the Farmer code to deploy infrastructure Target.create \u0026#34;Infrastructure\u0026#34; (fun _ -\u0026gt; let deployEnvironment = \u0026#34;Test\u0026#34; // \u0026#34;Prod\u0026#34;  let deployName = \u0026#34;TestResourceGroup\u0026#34; let deployLocation = Location.WestEurope let envInfo = deployEnvironment.ToLower() printfn $\u0026#34;Deploying {envInfo} {deployName} to {deployLocation}\u0026#34; // ---- \u0026lt; Azure SQL \u0026gt; ----------  // Todo: Insert DB Server code  // ---- \u0026lt;/Azure SQL \u0026gt; ----------  // ---- \u0026lt; Virtual Machines + NSG \u0026gt; ----------  // Todo: Insert VM code  // ---- \u0026lt;/Virtual Machines + NSG \u0026gt; ----------  // Todo: Insert Farmer deployment  // Todo: More resources will follow here...  () ) /// Here we will inster the FAKE task to deploy the database to SQL Server Target.create \u0026#34;DeployDatabase\u0026#34; (fun _ -\u0026gt; // Todo: Deploy database code  () ) Target.create \u0026#34;All\u0026#34; (fun _ -\u0026gt; ()) open Fake.Core.TargetOperators let dependencies = [ \u0026#34;Infrastructure\u0026#34; ==\u0026gt; \u0026#34;DeployDatabase\u0026#34; ==\u0026gt; \u0026#34;All\u0026#34; ] [\u0026lt;EntryPoint\u0026gt;] let main args = runOrDefault args Now, if you run dotnet build and dotnet run, you should see that the both targets, Infrastructure and DeployDatabase, are being called.\nCreating the database server with an empty database Creating SQL Server database: Replace // Todo: Insert DB Server code with:\nlet dbServerName = \u0026#34;my-db-server321\u0026#34;.ToLower() let databaseName = \u0026#34;my_database\u0026#34; let dbUsername = \u0026#34;ServerAdmin\u0026#34; let dbPasswordKey = $\u0026#34;password-for-{dbServerName}{envInfo}\u0026#34; let dbPassword = Environment.environVarOrFail $\u0026#34;db-password-{envInfo}\u0026#34; let getMyIp = (new System.Net.WebClient()).DownloadString(\u0026#34;https://api.ipify.org\u0026#34;); let sqlFirewallRules = // List of SQL firewall IPs to open:  [ \u0026#34;Deployment_Farmer_Ip\u0026#34;, getMyIp // \u0026#34;Office-ip-2021-09-03\u0026#34;, \u0026#34;123.123.123.123\u0026#34;  ] let database = sqlServer { name $\u0026#34;{dbServerName}{envInfo}\u0026#34; admin_username dbUsername enable_azure_firewall add_firewall_rules (sqlFirewallRules |\u0026gt; List.map(fun (name,ip) -\u0026gt; name,ip,ip)) add_databases [ sqlDb { sku Sql.DtuSku.S1; name $\u0026#34;{databaseName}{deployEnvironment}\u0026#34; } ] } Youc could add\ngeo_replicate({ DbSku = Some Sql.DtuSku.S1 // Some different than the primary location:  Location = Location.NorthEurope NameSuffix = \u0026#34;-geo\u0026#34;}) \u0026hellip; to geo-replicate the SQL Server database to have a backup on a different location.\nRelevant Farmer API documentation:\n SQL Server PostgreSql  Creating virtual machine(s) Virtual Machine will be created as a list with shared Network Security Group (NSG). This allows you to configure the firewall rules once and apply them to all your machines.\nNext, replace the // Todo: Insert VM code with:\nlet nsgName = $\u0026#34;myNSG{deployEnvironment}\u0026#34; let vmNamePrefix, vmCount = $\u0026#34;MyVm{deployEnvironment}\u0026#34;, 1 let vmUsername = \u0026#34;MyAdmin\u0026#34; let vmPassword = Environment.environVarOrFail $\u0026#34;vm-password-{envInfo}\u0026#34; let vmHttpPorts = [443] /// Open http ports  let httpsRule = securityRule { name $\u0026#34;{vmNamePrefix}HttpsRule\u0026#34; services (vmHttpPorts |\u0026gt; List.map(fun p -\u0026gt; NetworkService (\u0026#34;http\u0026#34;, uint16 p |\u0026gt; Port))) add_source_tag NetworkProtocol.TCP \u0026#34;Internet\u0026#34; add_destination_any } /// Open https port  let httpRule = securityRule { name $\u0026#34;{vmNamePrefix}HttpRule\u0026#34; services [NetworkService (\u0026#34;http\u0026#34;, uint16 80 |\u0026gt; Port)] add_source_tag NetworkProtocol.TCP \u0026#34;Internet\u0026#34; add_destination_any } /// Allowed ports for VM:  let vmIpRules = // rule name, ip address, allow RDP  [ \u0026#34;Deployment_Farmer_Ip\u0026#34;, getMyIp, true // \u0026#34;Office-ip-2021-09-03\u0026#34;, \u0026#34;123.123.123.123\u0026#34;, false  ] |\u0026gt; List.map(fun (nm, ip, remote) -\u0026gt; securityRule { name nm services (seq { // yield \u0026#34;CustomServicePortToOpen\u0026#34;, 12345;  if remote then yield \u0026#34;rdp\u0026#34;, 3389; }) add_source_address NetworkProtocol.TCP ip add_destination_any }) let networkSecurityGroup = nsg { name nsgName add_rules (httpsRule :: httpRule :: vmIpRules) } let createVm (vmName:string) = vm { name vmName network_security_group networkSecurityGroup username vmUsername os_disk 128 Vm.StandardSSD_LRS system_identity vm_size Vm.VMSize.Standard_DS1_v2 operating_system Vm.WindowsServer_2019Datacenter ip_allocation PublicIpAddress.Static } let vms = [ 1.. vmCount] |\u0026gt; List.map(fun idx -\u0026gt; createVm($\u0026#34;{vmNamePrefix}{idx}\u0026#34;)) let vmPwdKeys = [ 1.. vmCount] |\u0026gt; List.map(fun idx -\u0026gt; $\u0026#34;password-for-{vmNamePrefix}{idx}\u0026#34;, vmPassword) You could merge the sqlFirewallRules and vmIpRules, but this depends on your setup.\nRelevant Farmer API documentation:\n Virtual Machine  Farmer deployment of the resources Next, replace the // Todo: Insert Farmer deployment with:\nlet deployment = arm { location deployLocation add_resource database add_resource networkSecurityGroup add_resources (virtualMachines |\u0026gt; List.map(fun vm -\u0026gt; vm :\u0026gt; IBuilder)) output \u0026#34;db-connStr\u0026#34; (database.Databases |\u0026gt; Seq.tryHead |\u0026gt; Option.map(fun db -\u0026gt; database.ConnectionString db.Name)) outputs (virtualMachines |\u0026gt; List.filter (fun vm -\u0026gt; vm.PublicIpAddress.IsSome) |\u0026gt; List.mapi (fun idx vm -\u0026gt; $\u0026#34;{vmNamePrefix}{idx+1}\u0026#34;, vm.PublicIpAddress.Value)) } // To check the ARM generated:  deployment |\u0026gt; Writer.quickWrite \u0026#34;myTemplate\u0026#34; // To check the changes in Azure:  //let changes = deployment |\u0026gt; Deploy.whatIf deployName ([dbPasswordKey, dbPassword] @ vmPwdKeys)  //System.IO.File.WriteAllText(@\u0026#34;Changes.txt\u0026#34;, changes)  //let outputs = Map.empty\u0026lt;string,string\u0026gt;  let outputs = deployment |\u0026gt; Deploy.execute deployName ([dbPasswordKey, dbPassword] @ vmPwdKeys) Console.ForegroundColor \u0026lt;- ConsoleColor.Blue if outputs.ContainsKey \u0026#34;db-connStr\u0026#34; then let connStr = outputs.[\u0026#34;db-connStr\u0026#34;] dbConnectionString \u0026lt;- connStr.Replace(\u0026#34;=tcp:\u0026#34;, \u0026#34;=\u0026#34;) virtualMachines |\u0026gt; List.iteri(fun idx _ -\u0026gt; if outputs.ContainsKey $\u0026#34;vmIP{idx+1}\u0026#34; then Console.WriteLine ($\u0026#34;VM{idx+1} IP: \u0026#34; + outputs.[$\u0026#34;vmIP{idx+1}\u0026#34;]) createRemoteDesktopFile $\u0026#34;{vmNamePrefix}{idx+1}\u0026#34; outputs.[$\u0026#34;vmIP{idx+1}\u0026#34;] vmUsername ) Console.ResetColor() Before you can run this script, you have to set the environment varialbles of passwords for VM and DB.\nThe complexity rules for VM-password: Supplied password must be between 8-123 characters long and must satisfy at least 3 of password complexity requirements from the following:\n Contains an uppercase character Contains a lowercase character Contains a numeric digit Contains a special character Control characters are not allowed  To set environment variables you can do e.g.:\nset vm-password-test=... set db-password-test=... Because the deployments are repeateable, you can already dotnet build and dotnet run the script.\nDeploying the Database Schema A typical way to store, version-control, manage and compare Microsoft SQL Server database schemas is the SQL Server Data Tools (SSDT). Given a connection string, SSDT will create a local snapshot of a database, copying all of the tables, views, stored procedures, etc. into your source code repository as .sql-files. The .sql-files will be in a \u0026ldquo;.sqlproj\u0026rdquo; project that is compiled into a .dacpac-file.\nYou can get SSDT for Visual Studio 2019 or Azure Data Studio via the SQL Database Projects Extension.\nFor non-Windows machine you can build a dacpac file by creating a normal .fsproj class library, and changing it to use Sdk \u0026lt;Project Sdk=\u0026quot;MSBuild.Sdk.SqlProj/1.16.2\u0026quot;\u0026gt; as described in here with more details.\nFarmer has deployed an empty database for you (or updated the existing settings), but now you would want to insert/update the database schema, tables, procedures, etc.\nA way to install the dacpac-file to created database (or do a schema comparison), is using FAKE.\nLet\u0026rsquo;s replace the part // Todo: Deploy database code with:\n// You need the .dacpac file:  let dacPacPath = System.IO.Path.Combine [|__SOURCE_DIRECTORY__ ;\u0026#34;find_your_dacpac_file_path\u0026#34; ; \u0026#34;database.dacpac\u0026#34; |] if not (System.IO.File.Exists dacPacPath) then failwithf \u0026#34;DacPac file not found: %s\u0026#34; dacPacPath else let connectionString = let conn = dbConnectionString if conn.StartsWith \u0026#34;\\\u0026#34;\u0026#34; \u0026amp;\u0026amp; conn.EndsWith \u0026#34;\\\u0026#34;\u0026#34; then conn.Substring(1, conn.Length-2) else conn printfn \u0026#34;Deploying db connection: %s\u0026#34; connectionString // Example of custom parameters for SQLPROJ deployment:  // let demodata = if deployEnvironment = \u0026#34;Test\u0026#34; then \u0026#34;True\u0026#34; else \u0026#34;False\u0026#34;  SqlPackage.deployDb (fun args -\u0026gt; { args with //Action = SqlPackage.DeployAction.Report \u0026#34;database-diff.xml\u0026#34; //This would only show diff. The default action: Deploy  Source = dacPacPath; Destination = connectionString // Variables = [ \u0026#34;DeployDemoData\u0026#34;, demodata ]  AdditionalSqlPackageProperties = [ \u0026#34;IgnorePermissions\u0026#34;, \u0026#34;true\u0026#34; \u0026#34;IgnoreUserSettingsObjects\u0026#34;, \u0026#34;true\u0026#34; \u0026#34;IgnoreLoginSids\u0026#34;, \u0026#34;true\u0026#34; \u0026#34;IgnoreRoleMembership\u0026#34;, \u0026#34;true\u0026#34; // Depending on your dacpac, you might want to exclude some objects:  \u0026#34;ExcludeObjectTypes\u0026#34;, \u0026#34;Users;Logins;RoleMembership;ServerRoleMembership;Permissions\u0026#34;; ] Timeout = Some 240 }) |\u0026gt; ignore What next? There is a Todo: More resources will follow here... for you to continue infrastructure development with Farmer. Other resources that are useful:\n Application Insights, to attach monitoring: alerts, dashboards, availability tests.  let ai = appInsights { name $\u0026#34;{deployName}{deployEnvironment}AppInsights\u0026#34; }  Azure Traffic Manager is a DNS-based traffic load balancer. It means you can route the traffic to globally different regions and there is no performance hit of the traditional load balancer routing the traffic. The traffic manager will route the traffic to your VMs.  let dependsOnIps = virtualMachines |\u0026gt; List.filter(fun vm -\u0026gt; vm.PublicIpId.IsSome) |\u0026gt; List.map(fun vm -\u0026gt; vm.PublicIpId.Value) let trafficMgr = trafficManager { name $\u0026#34;TrafficManager2392{deployEnvironment}\u0026#34; // has to be unique name  depends_on dependsOnIps depends_on (virtualMachines |\u0026gt; List.map(fun vm -\u0026gt; vm :\u0026gt; IBuilder)) add_endpoints (virtualMachines |\u0026gt; List.filter(fun vm -\u0026gt; vm.PublicIpAddress.IsSome) |\u0026gt; List.mapi(fun i (vm) -\u0026gt; TrafficManager.endpoint { name vm.Name weight 1 priority (i+1) target_external (vm.PublicIpAddress.Value.Eval()) deployLocation })) enable_traffic_view routing_method RoutingMethod.Priority // Set your routing method here  dns_ttl 60\u0026lt;Seconds\u0026gt; monitor_protocol Https monitor_port 443 }  Azure DNS: The benefit of Azure DNS comes when you want to have a version history of your domain name settings, you want to programmatically manage the DNS to e.g. automatically verify SSL-certifiaction renewal, and route the traffic to Azure Traffic Manager.  let dnsZoneName = \u0026#34;mydomain321.com\u0026#34; // Your domain here  let dns = dnsZone { name dnsZoneName zone_type Dns.Public depends_on trafficMgr add_records [ txtRecord { ttl 3600 add_values [ // Check your current domain with: nslookup -type=txt mydomain.com  //\u0026#34;asdf=1234\u0026#34;  ] } //cnameRecord {  // name \u0026#34;subsite\u0026#34;  // ttl 3600  // cname \u0026#34;www.internet.com\u0026#34;  //}  // add mx and cname records from your current DNS...  yield! [ \u0026#34;\u0026#34;; \u0026#34;de\u0026#34;; \u0026#34;es\u0026#34;; \u0026#34;fr\u0026#34;; \u0026#34;www\u0026#34; ] |\u0026gt; List.fold(fun gathered nm -\u0026gt; if nm = \u0026#34;\u0026#34; then aRecord { ttl 60 link_to_dns_zone (Arm.Dns.zones.resourceId dnsZoneName) target_resource trafficMgr } :: gathered else cnameRecord { name nm depends_on (gathered |\u0026gt; List.head) link_to_dns_zone (Arm.Dns.zones.resourceId dnsZoneName) ttl 3600 target_resource trafficMgr } :: gathered) [] ] }  Azure CDN will mirror your public static files to a global fast content delivery network. If you reference the files from that, you will get faster delivery and release some resources from your server(s)/VM(s).  let contentDelivery = cdn { name $\u0026#34;{deployName}{deployEnvironment}Cdn\u0026#34; sku Cdn.Sku.Standard_Verizon add_endpoints [ endpoint { name (dnsZoneName.Replace(\u0026#34;.com\u0026#34;, \u0026#34;com\u0026#34;).Replace(\u0026#34;.\u0026#34;,\u0026#34;-\u0026#34;)) // add_compressed_content [ \u0026#34;text/plain\u0026#34;; ... ] // Custom mime-types  enable_http enable_https query_string_caching_behaviour Cdn.QueryStringCachingBehaviour.IgnoreQueryString optimise_for Cdn.GeneralWebDelivery origin dnsZoneName } ] } After adding these, you have to modify the deployment, e.g.:\nlet deployment = arm { location deployLocation add_resource ai // added  add_resource contentDelivery //added  add_resource dns //added  add_resource trafficMgr //added  add_resource database add_resource networkSecurityGroup add_resources (virtualMachines |\u0026gt; List.map(fun vm -\u0026gt; vm :\u0026gt; IBuilder)) output \u0026#34;db-connStr\u0026#34; (database.Databases |\u0026gt; Seq.tryHead |\u0026gt; Option.map(fun db -\u0026gt; database.ConnectionString db.Name)) outputs (virtualMachines |\u0026gt; List.filter (fun vm -\u0026gt; vm.PublicIpAddress.IsSome) |\u0026gt; List.mapi (fun idx vm -\u0026gt; $\u0026#34;{vmNamePrefix}{idx+1}\u0026#34;, vm.PublicIpAddress.Value)) output \u0026#34;appInsights-InstrumentationKey\u0026#34; ai.InstrumentationKey //added, outputs.[\u0026#34;appInsights-InstrumentationKey\u0026#34;], you need this to send events to AI  output \u0026#34;dns-nameServers\u0026#34; dns.NameServers //added, outputs.[\u0026#34;dns-nameServers\u0026#34;], you need these to register your domain.  }   Supporting resources\n  Relevant Farmer API documentation:\n DNS Traffic Manager CDN AppInsights - Dashboards AppInsights - Alerts AppInsights - AvailabilityTests  Connecting the VMs If you want to manually connect VMs, this script already created remote desktop connection files for you. If you want to automatically run scripts in VMs, you can do it e.g. with Invoke-AzVMRunCommand, but you need to have Azure Cli installed and connected (powershell -ExecutionPolicy Unrestricted -Command \u0026quot;Connect-AzAccount -Force):\nlet runShell = fun (command, args) -\u0026gt; try let P = System.Diagnostics.Process.Start(command, (args : string)) if (P = null) then ( printf \u0026#34;\\r\\n\\r\\nFailed: %s\\r\\n\u0026#34; command ) P.WaitForExit(); if P.ExitCode \u0026lt;\u0026gt; 0 then failwith (\u0026#34;Command failed, try running manually: \u0026#34; + command + \u0026#34; \u0026#34; + args) with | :? System.ComponentModel.Win32Exception -\u0026gt; printf \u0026#34;\\r\\n\\r\\nFailed: %s\\r\\n\u0026#34; command reraise () Console.WriteLine (\u0026#34;VM installation started at \u0026#34; + DateTime.Now.ToLongTimeString()) Console.ForegroundColor \u0026lt;- ConsoleColor.DarkGray virtualMachines |\u0026gt; List.iter (fun (vm) -\u0026gt; Console.WriteLine ($\u0026#34;Installing VM: {vm.Name.Value} \u0026#34; + DateTime.Now.ToLongTimeString()) let installVMCmd = \u0026#34;Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope Process; Install-Module -Name Az.Compute \u0026#34; + \u0026#34;-Scope CurrentUser -Force -AllowClobber; Import-Module Az.Compute;\u0026#34; + $\u0026#34;Invoke-AzVMRunCommand -ResourceGroupName \u0026#39;{deployName}\u0026#39; -Name \u0026#39;{vm.Name.Value}\u0026#39; \u0026#34; + \u0026#34;-CommandId \u0026#39;RunPowerShellScript\u0026#39; -ScriptPath \u0026#39;./installStuff.ps1\u0026#39; -Parameter @{{myScriptParam1=\u0026#39;hello\u0026#39;;myScriptParam2=\u0026#39;hello2\u0026#39;}}\u0026#34; Console.ForegroundColor \u0026lt;- ConsoleColor.DarkGray runShell(\u0026#34;powershell\u0026#34;,$\u0026#34;-ExecutionPolicy Unrestricted -Command \\\u0026#34;{installVMCmd}\\\u0026#34;\u0026#34;) ) Console.ResetColor() Console.WriteLine (\u0026#34;VM installation complete at \u0026#34; + DateTime.Now.ToLongTimeString()) You have the installStuff.ps1 locally, and then Invoke-AzVMRunCommand will transfer it to the VM automatically and execute the commands. The path it transfers the script will be something like C:\\Packages\\Plugins\\Microsoft.CPlat.Core.RunCommandWindows\\(version)\\Downloads\\script0.ps1. Example of the file content what you could have in your installStuff.ps1:\n# Do whatever installations here... # Some parameters: param ($myScriptParam1, $myScriptParam2) # Some variables: $httpPortToOpen = 80 $httpsPortsToOpen = 443,12345 # Save current directory pushd # Install Nuget Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force #Show file extensions reg add HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced /v HideFileExt /t REG_DWORD /d 0 /f #Install chocolatey iex ((new-object net.webclient).DownloadString(\u0026#39;https://chocolatey.org/install.ps1\u0026#39;)) #Install dotnet cd ${Env:ALLUSERSPROFILE}\\chocolatey\\bin .\\choco.exe install dotnet -y #Go back to original directory Pop-Location #Open Windows firewall ports netsh advfirewall firewall add rule name=\u0026#34;Open Port HTTP $httpPortToOpen\u0026#34; dir=in action=allow protocol=TCP localport=$httpPortToOpen Foreach ($httpPortToOpen in $httpPortsToOpen) { netsh advfirewall firewall add rule name=\u0026#34;Open Port HTTPS $httpsPortToOpen\u0026#34; dir=in action=allow protocol=TCP localport=$httpsPortToOpen } #...and so on... Keep the security in mind when installing stuff to your VMs. Happy managing!\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/webapp-deploy/","title":"Deploy an ASP.NET app","tags":[],"description":"","content":"Introduction This tutorial shows how to create the infrastructure required to host a ASP.NET web app, and how to automatically deploy that application with Farmer. We\u0026rsquo;ll cover the following steps:\n Creating and configuring a basic ASP.NET web application. Creating a web app in Farmer. Deploying the web app through Farmer.    Full code available here\n   Note: Your web application can be a C# web application - it does not need to be written in F#!\n Creating the ASP.NET web application Create a brand new ASP.NET web application:\n Create a directory for your new application and enter it. Using the dotnet SDK, create a new application: dotnet new mvc. Notice that inside the project file (either csproj or fsproj), the Project SDK is already set to Microsoft.NET.Sdk.Web. This is more-or-less required for hosting in Azure. Locally publish the application to a directory called deploy: dotnet publish -c Release -o deploy.   dotnet publish puts all built files and outputs into a single folder, and adds a web.config as required for e.g. Azure, as long as your Project SDK is set correctly.\n Create the Web App Create a new Farmer application which contains a web app.\nopen Farmer open Farmer.Builders let webapplication = webApp { name \u0026#34;\u0026lt;web app name goes here\u0026gt;\u0026#34; } Configure Web App to deploy your ASP.NET application let webapplication = webApp { ... zip_deploy @\u0026#34;\u0026lt;path_to_your_deploy_folder\u0026gt;\u0026#34; } That\u0026rsquo;s it! Deploy the web app by adding it to an ARM builder and deploy it to a resource group of your choosing. During the deployment process, you will notice the following:\nRunning ZIP deploy for \u0026lt;path_to_your_deploy_folder\u0026gt;\n Farmer will automatically zip up the contents of the folder for you.\n "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/event-grid/","title":"Event Grid","tags":[],"description":"","content":"Overview The Event Grid is a simple but powerful builder that links events from Azure services such as Storage and App Service to one or many subscribers which can consume the events. The event grid builder supports a degree of type safety - all system events are provided from a strongly-typed list, and events are directly linked to specific builders - so, for example, you cannot accidentally subscribe to Storage Account events if the event publisher is a Web App. It supports the following ARM resources.\n Topics (Microsoft.EventGrid/systemTopics) Subscriptions (Microsoft.EventGrid/systemTopics/eventSubscriptions)  Builder Keywords    Keyword Purpose     topic_name The name of the topic that will be created.   source Optional, defaults to the current resource group. The source of the events. See below for the full list of builder configurations that are supported.   add_queue_subscriber Adds a new storage queue subscriber. Requires the storage account config that will receive the events, the queue name and the list of events to subscribe to.   add_webhook_subscriber Adds a new web hook (HTTP) subscriber. Requires the web app config that will receive the event, associated URI local path and the list of events to subscribe to. Also contains an overload that takes in a Web App name and the full Uri of the web hook.   add_eventhub_subscriber Adds a new event hub subscriber. Requiresthe event hub builder config that will receive the events and the list of events to subscribe to.   add_function_subscriber Adds a new Azure Functions subscriber. Requires the function app, the handler name and the list of events to subscribe to.    Supported Sources Farmer supports the following Event Grid sources using Farmer builders:\n   Builder Events namespace      StorageAccount SystemEvents.Storage    WebApp SystemEvents.AppServer    KeyVault SystemEvents.KeyVault    SignalR SystemEvents.SignalR    Maps SystemEvents.Maps    ContainerRegistry SystemEvents.ContainerRegistry    ServiceBus SystemEvents.ServiceBus    IotHub SystemEvents.IotHub    EventHub SystemEvents.EventHub     Suported Destinations  EventHub (add_eventhub_subscriber), StorageQueue (add_queue_subscriber), WebHook (add_webhook_subscriber), ServiceBus Queue (add_servicebus_queue_subscriber), ServiceBus Topic (add_servicebus_topic_subscriber).  Example The following sample creates a source storage account that emits events on the event grid topic, whilst two destinations are created: an event hub and a storage queue, each listening for different events.\nopen Farmer open Farmer.Builders let queueName = \u0026#34;events\u0026#34; let storageSource = storageAccount { name \u0026#34;isaacstorageacc\u0026#34;; add_private_container \u0026#34;data\u0026#34; } let destionationHub = eventHub { name \u0026#34;isaachub\u0026#34;; namespace_name \u0026#34;isaacns\u0026#34; } let destinationStorage = storageAccount { name \u0026#34;destinationstorage\u0026#34;; add_queue queueName; add_private_container \u0026#34;events\u0026#34; } let eventHubGrid = eventGrid { topic_name \u0026#34;isaacHubTopic\u0026#34; source storageSource add_eventhub_subscriber destionationHub [ SystemEvents.Storage.BlobCreated; SystemEvents.Storage.BlobDeleted ] add_queue_subscriber destinationStorage queueName [ SystemEvents.Storage.BlobCreated ] } let template = arm { add_resources [ storageSource eventHubGrid destinationStorage destionationHub ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/express-route/","title":"ExpressRoute","tags":[],"description":"","content":"Overview An ExpressRoute circuit is a dedicated link to Azure to provide communication with Azure services without traversing the Internet. It requires some coordination with a networking provider for these circuits, so some information, such as the service provider and peering location must be obtained from Azure reference documentation. The ExpressRoute builder creates an ExpressRoute circuit and enables Azure private peering and Microsoft peering.\n ExpressRoute Namespace (Microsoft.Network/expressRouteCircuits)  ExpressRoute Builder (expressRoute)    Keyword Purpose     service_provider Connectivity service provider from Azure reference documentation   peering_location Connectivity peering location from Azure reference documentation   tier Standard or Premium   family Metered or Unlimited data   bandwidth Bandwidth in Mbps for the circuit   add_authorizations Adds names of authorization keys to be created on the new circuit.   add_peerings Adds peering details for the circuit - can add Azure Private and Microsoft peerings    ExpressRoute Peering Builder (peering) | Applies To | Keyword | Purpose | |-|-| | peering_type | A network CIDR block of 4 IP addresses (/30) for the ExpressRoute primary circuit | | peer_asn | Peer Autonomous System Number - this is a uniquely assigned number for the peer network, typically provided by the service provider in agreement with Microsoft | | azure_asn | Azure Autonomous System Number - Microsoft oftent uses AS 12076 for Azure public, Azure private and Microsoft peering | | primary_prefix | A network CIDR block of 4 IP addresses (/30) for the ExpressRoute primary circuit | | secondary_prefix | A network CIDR block of 4 IP addresses (/30) for the ExpressRoute secondary circuit | | vlan | A unique VLAN ID for the peering | | shared_key | An optional shared key the service provider may specify for the peering |\nConfiguration Members    Member Purpose     ServiceKey An ARM expression path to get the service key on the newly created circuit.   AuthorizationKey  An ARM expression path to get an authorization key by name.    Example open Farmer open Farmer.Builders open Farmer.ExpressRoute let circuit = expressRoute { name \u0026#34;my-express-route\u0026#34; service_provider \u0026#34;Equinix\u0026#34; peering_location \u0026#34;New York\u0026#34; tier Premium family MeteredData bandwidth 1000\u0026lt;Mbps\u0026gt; add_authorizations [ \u0026#34;authkey1\u0026#34; ] add_peerings [ peering { peering_type AzurePrivatePeering peer_asn 55277L azure_asn 12076 primary_prefix (IPAddressCidr.parse \u0026#34;10.254.12.0/30\u0026#34;) secondary_prefix (IPAddressCidr.parse \u0026#34;10.254.12.4/30\u0026#34;) vlan 2406 } ] } arm { add_resource circuit output \u0026#34;er-service-key\u0026#34; circuit.ServiceKey output \u0026#34;auth-key\u0026#34; (er.AuthorizationKey \u0026#34;authkey1\u0026#34;) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/event-hub/","title":"Event Hub","tags":[],"description":"","content":"Overview The Event Hub builder creates event hub namespaces, event hubs, consumer groups and authorization rules in a single builder.\n Event Hub Namespace (Microsoft.EventHub/namespaces) Event Hub (Microsoft.EventHub/namespaces/eventhubs) Consumer Group (Microsoft.EventHub/namespaces/eventhubs/consumergroups) Authorization Rule (Microsoft.EventHub/namespaces/eventhubs/AuthorizationRules\u0026quot;)   The Event Hub builder works in a similar fashion to the web app builder in that it automatically creates the host (in this case, the event hub namespace) when creating the event hub. If you wish to create multiple hubs in the same namespace, configure the namespace-level properties in the first event hub; subsequent event hubs should link to the namespace of the hub created by the first hub.\n Builder Keywords    Applies To Keyword Purpose     Namespace namespace_name Sets the name of the event hub namespace, if you are creating the namespace along with the hub.   Namespace sku Sets the SKU of the event hub namespace.   Namespace capacity Sets the capacity of the event hub namespace (see here for more details)   Namespace enable_zone_redundant Enables zone redundancy on the event hub namespace.   Namespace enable_auto_inflate Enables auto inflate throughput; you must supply the maximum throughput level.   Namespace disable_auto_inflate Disables auto inflate throughput.   Event Hub name Sets the name of the event hub.   Event Hub message_retention_days Sets the number of days to retain messages for on the event hub.   Event Hub partitions Sets the number of partitions on the event hub.   Event Hub add_consumer_group Creates a consumer group for the event hub. The default consumer group $Default gets created automatically.   Event Hub add_authorization_rule Adds a named authorization rule on the event hub.   Event Hub link_to_namespace Sets the name of an existing or already-defined event hub namespace that this event hub should link to.   Event Hub capture_to_storage Activates Event Hub data capture to a Storage Account. Takes in a storage account or resource name, and the container to write events to.    Configuration Members    Member Purpose     DefaultKey Gets an ARM expression for the root namespace key of the Event Hub namespace.   GetKey Gets an ARM expression for a named key on this event hub.    Example open Farmer open Farmer.Builders let storage = storageAccount { name \u0026#34;isaacssuperstorage\u0026#34; } let primaryHub = eventHub { namespace_name \u0026#34;allmyevents\u0026#34; sku EventHub.Standard enable_zone_redundant enable_auto_inflate 3 add_authorization_rule \u0026#34;FirstRule\u0026#34; [ EventHub.Listen; EventHub.Send ] add_authorization_rule \u0026#34;SecondRule\u0026#34; AllAuthorizationRights name \u0026#34;first-hub\u0026#34; partitions 2 message_retention_days 3 add_consumer_group \u0026#34;myGroup\u0026#34; } let secondHub = eventHub { name \u0026#34;second-hub\u0026#34; link_to_namespace \u0026#34;allmyevents\u0026#34; partitions 1 message_retention_days 1 capture_to_storage myStorageAccount \u0026#34;mycontainer\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/5-unit-testing/","title":"5. Unit Testing","tags":[],"description":"","content":"Usually I would be pro writing the tests before you implement all this but it is important to get a feel for the moving parts. At this point you may want to write some tests so you can iterate quickly on getting the structure of your ARM template correct.\nThe tests you will find in the project are black-box style tests that focus on the input of a resource and the output of the ARM template. If you want to create tests for your mapping functions that is fine but remember between the strong type system and making it difficult to have null values, those kind of tests seldom yield much benefit in F#.\nOf course, unit tests can only tell you so much when dealing with something as complex as Azure. Create a fsx file to run to check that your resource is deploying as expected.\n// container-registry.fsx #r \u0026#34;Newtonsoft.Json.dll\u0026#34; #r @\u0026#34;../Farmer/bin/Debug/netstandard2.0/Farmer.dll\u0026#34; open Farmer open Farmer.Resources.ContainerRegistry let myRegistry = containerRegistry { name \u0026#34;devonRegistry\u0026#34; sku ContainerRegistrySku.Basic enable_admin_user } let deployment = arm { location NorthEurope add_resource myRegistry output \u0026#34;registry\u0026#34; myRegistry.Name output \u0026#34;loginServer\u0026#34; myRegistry.LoginServer } deployment |\u0026gt; Deploy.execute \u0026#34;FarmerTest\u0026#34; Deploy.NoParameters |\u0026gt; printfn \u0026#34;%A\u0026#34; Create a Resource Group to run it, here I called it \u0026ldquo;FarmerTest\u0026rdquo;.\nRun dotnet fsi container-registry.fsx\n"},{"uri":"https://compositionalit.github.io/farmer/contributing/create-pull-requests/","title":"Creating Pull Requests","tags":[],"description":"","content":" This article is not a detailed guide on how to create a pull request (PR). See here to learn more about how to work with pull requests on GitHub.\n The purpose of this article is to illustrate the main checklists you must go through before a PR will be considered for inclusion in Farmer. If you are new to Farmer, F# or GitHub - don\u0026rsquo;t worry. The team will be happy to support you getting your feature over the line.\nThese are the following checks we\u0026rsquo;ll normally put in place:\n1. Create an issue first! Except for small pull requests, create an issue to discuss the feature. The last thing we want is for someone to spend hours of their time on a feature only for someone else to have started work on something similar, or for the admins of the project to reject it for whatever reason e.g. does not fit with the project etc. Creating an issue does not take long and will help save time for everyone.\n2. Create Documentation Every PR to Farmer must have some documentation with it. If you modify a resource and add a new keyword, it must be added to the appropriate docs page.\n3. Write Unit Tests Every PR to Farmer should have at least one test associated with it. If no tests are added, you can expect at least a request for one or explanation as to why one is not necessary.\n4. Write Release Notes Every PR to Farmer must include an entry to the RELEASE_NOTES.md file under the next release. Briefly explain the feature and ideally link to the PR number e.g.\n5. Adhere to Coding Standards Here are some (very basic!) standards for the project:\n Follow the coding style of the existing source. Use 4 spaces for indentation. As a last resort, adhere to official style guide as a basis.  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/network-interface/","title":"Network Interface","tags":[],"description":"","content":"Overview The networkInterface builder allows you to create network interfaces (NIC) so that Azure virtual machine (VM) can communicate with internet, Azure, and on-premises resources. To learn more about routeServer, reference to Azure Docs\n NetworkInterface (Microsoft.Network/networkInterfaces)  Builder Keywords    Applies To Keyword Purpose     networkInterface name Name of the network interface resource   networkInterface link_to_subnet Link to existing subnet. If not provided, need to specify the subnet name and prefix for a new subnet   networkInterface subnet_name Sets the name of the vnet subnet for network interface   networkInterface subnet_prefix Sets the prefix of the vnet subnet for network interface   networkInterface link_to_vnet Link to existing vnet or to vnet managed by Farmer   networkInterface add_static_ip Use static ip for the network interface. If not provided, ip will be dynamically allocated   networkInterface accelerated_networking_flag The accelerated networking flag for the network interface. Default is false   networkInterface ip_forwarding_flag The ip forwarding flag for the network interface. Default is false    Example #r \u0026#34;nuget:Farmer\u0026#34; open Farmer open Farmer.Builders open Farmer.Builders.NetworkInterface arm { location Location.EastUS add_resources [ vnet { name \u0026#34;test-vnet\u0026#34; add_address_spaces [ \u0026#34;10.0.0.0/16\u0026#34; ] } networkInterface { name \u0026#34;my-network-interface\u0026#34; subnet_name \u0026#34;my-subnet\u0026#34; subnet_prefix \u0026#34;10.0.100.0/24\u0026#34; link_to_vnet (virtualNetworks.resourceId \u0026#34;test-vnet\u0026#34;) add_static_ip \u0026#34;10.0.100.10\u0026#34; accelerated_networking_flag false ip_forwarding_flag false } ] } Example using existing vnet and subnet with dynamic ip allocation #r \u0026#34;nuget:Farmer\u0026#34; open Farmer open Farmer.Builders open Farmer.Builders.NetworkInterface arm { location Location.EastUS add_resources [ networkInterface { name \u0026#34;my-network-interface\u0026#34; link_to_subnet \u0026#34;test-subnet\u0026#34; link_to_vnet \u0026#34;test-vnet\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/route-server/","title":"Route Server","tags":[],"description":"","content":"Overview The routeServer builder creates a route server to simplify dynamic routing between your network virtual appliance (NVA) and your virtual network. To learn more about routeServer, reference the Azure Docs\n RouteServer (Microsoft.Network/virtualHubs) BGPConnection (Microsoft.Network/virtualHubs/bgpConnections)  Builder Keywords    Applies To Keyword Purpose     routeServer name Name of the route server resource   routeServer sku Sets the tier of the route server   routeServer allow_branch_to_branch_traffic The allowBranchToBranchTraffic flag for the route server. Default is false   routeServer routing_preference The routingPreference for the route server. Default is ExpressRoute   routeServer link_to_vnet Link to existing vnet or to vnet managed by Farmer   routeServer subnet_prefix Sets the subnetPrefix of the vnet for route server   routeServer add_bgp_connections The BGP connections to be added to the route server   routeServerBGPConnection name Name of the BGP connection   routeServerBGPConnection peer_ip The peer IP of the BGP connection   routeServerBGPConnection peer_asn The peer Asn of the BGP connection   routeServerBGPConnection depends_on Depend on another resource before deploying this bgp connection    Example #r \u0026#34;nuget:Farmer\u0026#34; open Farmer open Farmer.Builders arm { location Location.EastUS add_resources [ vnet { name \u0026#34;test-vnet\u0026#34; add_address_spaces [ \u0026#34;10.0.0.0/16\u0026#34; ] } routeServer { name \u0026#34;my-route-server\u0026#34; sku RouteServer.Sku.Standard subnet_prefix \u0026#34;10.0.12.0/24\u0026#34; link_to_vnet (virtualNetworks.resourceId \u0026#34;test-vnet\u0026#34;) add_bgp_connections [ routeServerBGPConnection { name \u0026#34;my-bgp-conn\u0026#34; peer_ip \u0026#34;10.0.1.85\u0026#34; peer_asn 65000 } ] } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/functions/","title":"Functions","tags":[],"description":"","content":"Overview The Functions builder is used to create Azure Functions accounts. It abstracts the App Host and Service Plan into the same component, and will also create and configure a linked App Insights resource. In addition, it will automatically create a backing storage account required by the functions runtime.\n Web Site (Microsoft.Web/sites) Web Host (Microsoft.Web/serverfarms) Application Insights (Microsoft.Insights/components) Storage Accounts (Microsoft.Storage/storageAccounts)  Builder Keywords    Keyword Purpose     name Sets the name of the functions instance.   service_plan_name Sets the name of the service plan hosting the function instance.   link_to_service_plan Instructs Farmer to link this webapp to an existing service plan rather than creating a new one.   link_to_unmanaged_service_plan Instructs Farmer to link this Functions instance to an existing service plan that is externally managed, rather than creating a new one.   link_to_storage_account Do not create an automatic storage account; instead, link to a storage account that is created outside of this Functions instance but within this Farmer template.   link_to_unmanaged_storage_account Do not create an automatic storage account; instead, link to an existing storage account that was created external to Farmer.   https_only Disables http for this functions app so that only HTTPS is used.   ftp_state Allows to enable or disable FTP and FTPS.   app_insights_name Sets the name of the automatically-created app insights instance.   app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   link_to_app_insights Instead of creating a new AI instance, configure this webapp to point to another AI instance that you are managing yourself.   link_to_unmanaged_app_insights Instructs Farmer to link this functions instance to an existing app insights instance that is externally managed, rather than creating a new one.   use_runtime Sets the runtime of the Functions host.   use_extension_version Sets the extension version of the functions host.   operating_system Sets the operating system of the Functions host.   setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   secret_setting Sets a \u0026ldquo;secret\u0026rdquo; app setting of the function. You must supply the \u0026ldquo;key\u0026rdquo;, whilst the value will be supplied as a secure parameter or an ARM expression.   settings Sets a list of app setting of the web app as tuples in the form of (\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;).   connection_string Creates a connection string whose value is supplied as secret parameter, or as an ARM expression in the tupled form of (\u0026ldquo;key\u0026rdquo;, expr).   connection_strings Creates a set of connection strings whose values will be supplied as secret parameters.   depends_on Sets dependencies for the web app.   enable_cors Enables CORS support for the app. Either specify AllOrigins or a list of valid URIs.   enable_cors_credentials Allows CORS requests with credentials.   add_identity Adds a managed identity to the the Function App.   system_identity Activates the system identity of the Function App.   always_on Stops the app from sleeping if idle for a few minutes of inactivity.   worker_process Specifies whether to set the app to 32 or 64 Bitness.   publish_as Specifies whether to publish function as code or as a docker container.   add_slot Adds a deployment slot to the app   add_slots Adds multiple deployment slots to the app   health_check_path Sets the path to your functions health check endpoint, which Azure load balancers will ping to determine which instances are healthy.   add_allowed_ip_restriction Adds an \u0026lsquo;allow\u0026rsquo; rule for an ip   add_denied_ip_restriction Adds an \u0026lsquo;deny\u0026rsquo; rule for an ip   link_to_vnet Enable the VNET integration feature in azure where all outbound traffic from the function with be sent via the specified subnet. Use this operator when the given VNET is in the same deployment   link_to_unmanaged_vnet Enable the VNET integration feature in azure where all outbound traffic from the function with be sent via the specified subnet. Use this operator when the given VNET is not in the same deployment    Post-deployment Builder Keywords The Functions builder contains special commands that are executed after the ARM deployment is completed.\n   Keyword Purpose     zip_deploy Supplying a folder or zip file will instruct Farmer to upload the contents directly to the Azure Functions once the ARM deployment is complete.   zip_deploy_slot Supplying a folder or zip file will instruct Farmer to upload the contents directly to the named slot of the Azure Functions once the ARM deployment is complete.    Key Vault integration The Function builder comes with special integration into KeyVault. By activating KeyVault integration, the function builder can automatically link to, or even create, a full KeyVault instance. All Secret or ARM Expression-based Settings (e.g. a setting that links to the Key of a Storage Account) will automatically be redirected to KeyVault. The value will be stored in KeyVault and the system identity will be activated and provided into the KeyVault with GET permissions. Lastly, Function app settings will remain in place, using the Azure Functions built-in KeyVault redirection capabilities.\nThe following keywords exist on the function:\n   Member Purpose     use_keyvault Tells the function app to create a brand new KeyVault for this Function\u0026rsquo;s secrets.   link_to_keyvault Tells the function to use an existing Farmer-managed KeyVault which you have defined elsewhere. All secret settings will automatically be mapped into KeyVault.   link_to_unmanaged_keyvault Tells the web app to use an existing non-Farmer managed KeyVault which you have defined elsewhere. All secret settings will automatically be mapped into KeyVault.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this functions app.   StorageAccountKey Gets the ARM expression path to the storage account key of this functions app.   AppInsightsKey Gets the ARM expression path to the app insights key of this functions app, if it exists.   DefaultKey Gets the ARM expression path for the default key of this functions app.   MasterKey Gets the ARM expression path for the master key of this functions app.    Example open Farmer open Farmer.Builders let myFunctions = functions { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; app_insights_off } Example of a Premium Functions app let servicePlan = servicePlan { name \u0026#34;myServicePlan\u0026#34; sku WebApp.Sku.EP1 // Elastic Premium 1  max_elastic_workers 25 } let functionsApp = functions { name \u0026#34;myFunctionsApp\u0026#34; link_to_service_plan servicePlan } let deployment = arm { add_resources [ servicePlan; functionsApp ] } "},{"uri":"https://compositionalit.github.io/farmer/deployment-guidance/","title":"Deployment Guidance","tags":[],"description":"","content":"You can deploy Farmer templates in a number of ways, depending on how you would prefer to work with ARM templates and tooling.\nOption 1: \u0026ldquo;ARM templates are just a means to an end to me\u0026rdquo; If you don\u0026rsquo;t use ARM templates today, or don\u0026rsquo;t need to edit them directly, you can opt to do away with them completely. You\u0026rsquo;ll create Farmer applications which use a simple F# SDK to interact with Azure; Farmer will create ARM templates in the background for you transparently, so you\u0026rsquo;ll never see or interact with them.\nIn such a case, you can opt to deploy directly through Farmer. This mode provides an F# wrapper around the Azure CLI which captures your credentials during the deployment process.\nIf you\u0026rsquo;re looking to stay within F# and e.g. respond to outcomes from the deployment such as using deployment outputs, this is an excellent option because Farmer is just a dotnet application and the deployment call is a simple function call.\nAnother benefit of this is because Farmer is a simple .NET Standard library, you can use it natively within .NET build tools such as FAKE or CAKE.\nCombined Resource and Application Deployment Farmer can also optionally do more for you by handling the entire deployment process, including deployment of your application artifacts.\ngraph LR subgraph Azure Resource Group D(Azure App Service) end subgraph JSON C(ARM Template) -- REST API or Azure CLI -- D end subgraph .NET A(Farmer)-- resources emitted to -- C A -. your application deployed via ZIP Deploy.- D end  Watch this short video to see more!\n  Option 2: \u0026ldquo;I already have an ARM deployment strategy\u0026rdquo; If you already use ARM templates, you\u0026rsquo;ll probably already have a strategy for working with templates and deploying them to Azure, such as PowerShell, the Azure CLI or a build system such as Azure DevOps or Octopus Deploy. In such a case, you may want to use Farmer to generate, but not deploy, your ARM templates.\nOption 3: \u0026ldquo;I want to hand-craft my ARM templates\u0026rdquo; If you want to retain fine-grained control over ARM templates, you can use Farmer to create a one-off task to rapidly generate an ARM template which you then take ownership of. In this case, Farmer itself won\u0026rsquo;t be a part of your build / deploy chain, which will remain the same as today - you\u0026rsquo;ll use Farmer just as an edit-time task to create an ARM template itself which you will then manually modify.\nThe choice is yours.\nHow do I create a Service Principal? If you\u0026rsquo;re trying to deploy to Azure in an automated fashion, you may need to create a Service Principal account that has permissions in Azure to deploy ARM templates on your behalf.\nThe Azure CLI provides a simple way to create one using the az ad sp command:\naz ad sp create-for-rbac --name farmer-deploy This will provide output similar to the following:\n{ \u0026#34;appId\u0026#34;: \u0026#34;1181c21b-78f3-42b3-a26d-03ba75c7b674\u0026#34;, \u0026#34;displayName\u0026#34;: \u0026#34;farmer-deploy\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;http://farmer-deploy\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;4aa3b120-f2b2-4ea9-941b-5891fef0ef11\u0026#34;, \u0026#34;tenant\u0026#34;: \u0026#34;aa7f7453-15af-4ab0-5d41-aeb4a25293bc\u0026#34; } The mapping from these fields to the credentials used in Farmer\u0026rsquo;s authenticate function are:\n   Azure CLI Farmer     appId appId   password secret   tenant tenantId    You should store these credentials in a secure store, such as your CI/CD service or e.g. Azure KeyVault and should avoid committing them into source control.\n"},{"uri":"https://compositionalit.github.io/farmer/support/","title":"Commercial Support","tags":[],"description":"","content":"The creators of Farmer, Compositional IT, offer a professional fully managed support package which we strongly recommend for any organisations using Farmer on a commercial basis. It includes:\n Prioritised resolution of any bugs. If you find a bug that\u0026rsquo;s blocking you, we\u0026rsquo;ll prioritise it and release a hot fix as soon as it\u0026rsquo;s ready. Prioritised resolution and escalation of issues. If there\u0026rsquo;s a possible issue or question, we\u0026rsquo;ll prioritise dealing with it. Prioritised feature requests: Get new features that are important to you added first. Personalised support and guidance via email, telephone or video. Speak to one of our team for advice and best practices on how to best manage deployments. Discounts on our F# and Azure training and coaching services  Please contact us to find out more! "},{"uri":"https://compositionalit.github.io/farmer/testimonials/","title":"Testimonials","tags":[],"description":"","content":"Please submit a pull request here with details of your success stories of using Farmer!  \u0026ldquo;We\u0026rsquo;ve been using Farmer to help rapidly onboard our customers onto Azure with repeatable processes, particularly with the SAFE Stack. It\u0026rsquo;s helping our team adopt best practices without passing on expense to our customers.\u0026rdquo;\nIsaac Abraham, Director, Compositional IT\n  \u0026ldquo;Farmer quickly became an essential tool for Continuous Deployment at our F# projects. Clean DSL, great documentation, growing support of various Azure services and PR-friendly approach made Farmer to be one of the best open source projects in these days.\u0026rdquo;\nRoman Provaznk, F# Lead Developer, CN Group\n  \u0026ldquo;Holy moly, this was a breeze!! I\u0026rsquo;m SO going to use this more often, even if it\u0026rsquo;s just to get a baseline for a customer. Saves tons of time!\nJan De Vries, Microsoft MVP\n  \u0026ldquo;Hey @isaac_abraham, #Farmer is kind of awesome. A few lines and my fav env is created. #ILike\u0026rdquo;\nJan(ek) Fellien, Microsoft MVP\n  \u0026ldquo;Finally took a look at farmer just now\u0026hellip;. I should have looked months ago. I mean, I can actually read a farmer template. And it makes sense?!\u0026rdquo;\nArjen Smits\n  \u0026ldquo;With Farmer we were finally able to organize our Azure infrastructure. No messy names of storageaccounts anymore. Thanks for this great tool!\u0026rdquo;\nTim Forkmann, Head of EnergyData at Danpower\n  \u0026ldquo;Farmer allows us to keep our infrastructure easy to deploy and maintain. If we use Azure, we use it with Farmer! Thanks for creating it!\nStefan Hausotte, CEO of Bitfalter\n "},{"uri":"https://compositionalit.github.io/farmer/links/","title":"Links","tags":[],"description":"","content":"In this page, you can find blog posts, videos and tweets on Farmer that will give you a better sense of the scenery and the dialogue around it.\nBlog Posts  Compositional IT articles on Farmer Azure SQL Database deployment with Farmer, DbUp and GitHub Actions Introduction to Farmer - IaC with Azure Farmer: Simpler ARM deployments with Octopus Deploy  Videos  Learn how to deploy complete .NET Web Apps to Azure in less than 5 minutes! Working with raw JSON ARM resources with Farmer Authoring ARM templates the easy way with Farmer Making Infrastructure as Code Easier in Azure Introduction to Farmer and Stepping up the game with ARM templates  "},{"uri":"https://compositionalit.github.io/farmer/contributing/","title":"Contributing","tags":[],"description":"","content":"Thanks for thinking about contributing! Azure is a giant beast and help supporting more use-cases is always appreciated. To make it easier to contribute, we put together this little guide. Please take a few minutes to read through before starting work on a pull request (PR) to Farmer.\nThe process (don\u0026rsquo;t worry\u0026hellip; this is not waterfall)  Open an issue, or comment on an existing open issue covering the resource you would like to work on. Basically, a PR from you should not come as a surprise. Implement the 20% of features that cover 80% of the use cases. PR against the master branch from your fork. Add/update tests as required. Create a new *.md file with the name of your resource in the folder /content/api-overview/resources/. Eg. container-registry.md Add a description, keywords, and an example to the docs page. PRs need to pass build/test against both Linux \u0026amp; Windows build, and a review, before being merged in.  TODO There\u0026rsquo;s still more to document!\n Validation best practices Multiple resource builders Linking resources (one-to-many relationships) Post-deploy tasks  "},{"uri":"https://compositionalit.github.io/farmer/faq/","title":"FAQs","tags":[],"description":"","content":"How can I help? Try out Farmer and see what you think.\n Create as many issues as you can for both bugs, discussions and features Create suggestions for features and the most important elements you would like to see added  I have an Azure subscription, but I\u0026rsquo;m not an expert. I like the look of this - how do I \u0026ldquo;use\u0026rdquo; it?  Create an ARM template using the Farmer sample app. Follow the steps here to deploy the generated template into Azure. Log any issues or ideas that you find here.  How do I get Farmer to work from a continuous deployment (CD) process?  Look at some of the alternative strategies outlined here. Read up on ARM deployment strategies e.g. Azure Devops have guides here.  The Farmer .NET Template also has support for creating a Azure Devops-ready application from scratch.\nI don\u0026rsquo;t know F#. Would you consider writing a C# version of this? I\u0026rsquo;m afraid not. F# isn\u0026rsquo;t hard to learn (especially for simple DSLs such as this), and you can easily integrate F# applications as part of a dotnet solution, since F# is a first-class citizen of the dotnet core ecosystem. You can even create new resources in C# since the core abstractions of Farmer are two simple .NET interfaces.\nAre you trying to replace ARM templates? No, we\u0026rsquo;re not. Farmer generates ARM templates that can be used just as normal; Farmer can also be used simplify to make the process of getting started much simpler, or incorporated into your build pipeline as a way to avoid managing difficult-to-manage ARM templates and instead use them as the final part of your build / release pipeline.\nAre you trying to compete with Pulumi? No, we\u0026rsquo;re not. Farmer has (at least currently) a specific goal in mind, which is to lower the barrier to entry for creating and working with ARM templates. We\u0026rsquo;re not looking to create a cross-platform DSL to also support things like Terraform etc. or provide a stateful service store that Pulumi offers. Instead, Farmer is a simple way to continue to use ARM templates today but benefit from a more rapid authoring and maintenance process.\nThere\u0026rsquo;s no support for variables or parameters! Farmer intentionally has limited support for ARM parameters and variables. Read here to find out the alternatives.\nCan I add resources that are not supported by Farmer? Yes. You can use some adapters that Farmer provides to generate resources using basic .NET objects, or even paste ARM template JSON directly into Farmer and have that embedded inside. See the following links from the Contributing section:\n Using raw JSON with Resource.ofJSON Using anonymous records or objects with Resource.ofObj Using the IArmResource interface.  The resource I need isn\u0026rsquo;t included! Create an issue on our github repository, ideally with a sample ARM template and a link to the official Microsoft documentation on the resource. We can\u0026rsquo;t promise we\u0026rsquo;ll look at it immediately, but raising the issue is an important first step to getting more resources supported.\nBut our organisation really needs that resource enhancement today! Drop us an email explaining what you need; we\u0026rsquo;re happy to discuss a commercial support arrangement to provide you with features that you need in a more timely fashion.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/iot-hub/","title":"IOT Hub","tags":[],"description":"","content":"Overview The IOT Hub builder creates IOT Hub and linked Provision Services.\n IOT Hubs (Microsoft.Devices/IotHubs) Provisioning Services (Microsoft.Devices/provisioningServices)  Builder Keywords    Keyword Purpose     name Specifies the name of the IOT Hub   sku Sets the SKU of the IOT Hub   capacity Sets the name of the capacity for the IOT Hub instance   partition_count Sets the name of the SKU/Tier for the IOT Hub instance   retention_days Sets the name of the SKU/Tier for the IOT Hub instance   enable_device_provisioning Sets the name of the SKU/Tier for the IOT Hub instance    Configuration Members    Member Purpose     GetKey Returns an ARM expression to retrieve the IOT Hub key for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.   GetConnectionString Returns an ARM expression to generate an IOT Hub connection string for a specific policy e.g IotHubOwner or RegistryReadWrite. Useful for e.g. supplying the key to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let hub = iotHub { name \u0026#34;yourhubname\u0026#34; sku IotHub.B1 capacity 2 partition_count 2 retention_days 3 enable_device_provisioning } let deployment = arm { location Location.NorthEurope add_resource hub output \u0026#34;iot_key\u0026#34; (hub.GetKey IotHub.IotHubOwner) output \u0026#34;iot_connection\u0026#34; (hub.GetConnectionString IotHub.RegistryReadWrite) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/gallery/","title":"Gallery","tags":[],"description":"","content":"Overview The gallery builder is used to create Galleries for sharing VM images. These can be used to create virtual machines or virtual machine scale sets that can expand or contract to scale capacity as needed.\n Galleries (Microsoft.Compute/galleries) Gallery Image (Microsoft.Compute/galleries/images)  Builder Keywords    Applies To Keyword Purpose     gallery name Name of the gallery resource, up to 80 characters, alphanumerics and periods.   gallery description Description for the gallery.   gallery sharing_profile Sharing profile that must be set to share with the community or groups.   gallery soft_delete Indicate soft deletion of images should be enabled or disabled (default disabled).   gallery add_tags Add tags to the gallery resource.   gallery depends_on Add explicit dependencies for the gallery resource.   galleryImage name Name of the image in the gallery.   galleryImage gallery_name Name of the gallery where the image is created.   galleryImage gallery Specify the gallery in the same deployment. The image will depend on the gallery.   galleryImage architecture Indicates x64 or ARM 64 images - defaults to x64 if not set.   galleryImage description Optional description for the image in the gallery.   galleryImage eula Optional End User License Agreement for using the image.   galleryImage hyperv_generation The Hyper-V generation for the image. This should be set to match the Hyper-V generation of the source image that was used to create this image.   galleryImage gallery_image_identifier The publisher, offer, and sku for the image in the gallery.   galleryImage os_state Indicate if the VM is Generalized or Specialized. A generalized image allows OS configuration options, such as setting the username and password, whereas this is typically set already in a specialized image.   galleryImage os_type OS type for the image - Windows or Linux   galleryImage privacy_statement_uri URI where the privacy statement for the use of the image can be found.   galleryImage purchase_plan A purchase plan name, publisher, and product for the image, for use in a community gallery or marketplace images.   galleryImage recommended_configuration Recommended range of vCPUs and memory for VMs created from this image.   galleryImage recommended_memory A recommended range of memory for VMs created from this image. Default is 1 Gb to 32 Gb.   igalleryImagemage recommended_vcpu A recommended range of vCPUs for VMs created from this image. Default is 1 to 16.   galleryImage release_notes_uri URI where release notes can be found for the image.   galleryImage add_tags Add tags to the image resource.   galleryImage depends_on Add explicit dependencies for the image resource.    Example open Farmer open Farmer.Arm.Gallery open Farmer.Builders let myGallery = gallery { name \u0026#34;mygallery\u0026#34; description \u0026#34;Example Community Image Gallery\u0026#34; sharing_profile ( Community { Eula = \u0026#34;End User License Agreement goes here\u0026#34; PublicNamePrefix = \u0026#34;farmages\u0026#34; PublisherContact = \u0026#34;farmer.gallery@example.com\u0026#34; PublisherUri = System.Uri \u0026#34;https://compositionalit.github.io/farmer\u0026#34; } ) } let myImage = galleryImage { name \u0026#34;my-server-image\u0026#34; gallery myGallery gallery_image_identifier ( { Offer = \u0026#34;my-server\u0026#34; Publisher = \u0026#34;farmages\u0026#34; Sku = \u0026#34;my-server-2023\u0026#34; } ) hyperv_generation Image.HyperVGeneration.V2 os_state Image.OsState.Generalized os_type OS.Linux } arm { add_resources [ myGallery myImage ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/image-template/","title":"Image Template","tags":[],"description":"","content":"Overview The Image Template builder is used to create Image Templates for generating VM images. An image template starts with a source image, runs several customizations, and then can finally distribute the image to one or more destinations, including an Azure Image Gallery, a managed image, or a VHD file.\n Image Templates (Microsoft.VirtualMachineImages/imageTemplates)  Builder Keywords    Applies To Keyword Purpose     imageTemplate name Sets the name of the App Insights instance.   imageTemplate add_identity Adds a managed identity to the the imageTemplate that it uses to access resources when building the image and to publish images to a gallery.   imageTemplate build_timeout Timeout for the image builder, after which it will fail. Default is 4 hours.   imageTemplate source_platform_image Specify the source image to be customized from the Azure Gallery.   imageTemplate source_managed_image Specify the source as an existing managed image.   imageTemplate source_shared_image_version Specify the source image to be customized from a shared image gallery.   imageTemplate add_customizers Add customizers to make changes to the image being built.   imageTemplate add_distributors Specify one or more output distributions for the newly built image.   imageTemplate add_tags Add tags to the image template resource.   imageTemplate depends_on Add explicit dependencies for the imageTemplate resource.   fileCustomizer name Name for the file customizer as shown in logs.   fileCustomizer source_uri Location to download the file.   fileCustomizer destination Location to save the downloaded file - needs to be under /tmp on Linux or an existing location on Windows.   fileCustomizer checksum The SHA 256 checksum to validate the file.   shellCustomizer name The name of the customizer as shown in logs.   shellCustomizer inline_statements A list of shell commands to run.   shellScriptCustomizer name The name of the customizer as shown in logs.   shellScriptCustomizer script_uri A script to download and run.   shellScriptCustomizer checksum The SHA 256 checksum to validate the file.   powerShellCustomizer name The name of the customizer as shown in logs.   powerShellCustomizer inline_statements A list of PowerShell commands to run.   powerShellCustomizer run_as_elevated Run the commands in an elevated PowerShell session.   powerShellCustomizer run_as_system Run the commands that need to execute as the System.   powerShellCustomizer valid_exit_codes A list of exit codes to treat as successful.   powerShellScriptCustomizer name The name of the customizer as shown in logs.   powerShellScriptCustomizer script_uri A PowerShell script to download and run.   powerShellScriptCustomizer checksum The SHA 256 checksum to validate the file.   powerShellScriptCustomizer run_as_elevated Run the commands in an elevated PowerShell session.   powerShellScriptCustomizer run_as_system Run the commands that need to execute as the System.   powerShellScriptCustomizer valid_exit_codes A list of exit codes to treat as successful.   windowsRestartCustomizer restart_command Command to execute the restart (optional). The default is \u0026lsquo;shutdown /r /f /t 0 /c \u0026quot;packer restart\u0026quot;\u0026rsquo;   windowsRestartCustomizer restart_check_command Command to check if restart succeeded (optional).   windowsRestartCustomizer restart_timeout Restart timeout specified as a string of magnitude and unit. For example, 5m (5 minutes) or 2h (2 hours). The default is: 5m.   windowsUpdateCustomizer search_criteria Optional, defines which type of updates are installed (like Recommended or Important), BrowseOnly=0 and IsInstalled=0 (Recommended) is the default.   windowsUpdateCustomizer filters Optional, allows you to specify a filter to include or exclude updates.   windowsUpdateCustomizer update_limit Optional, defines how many updates can be installed, default 1000.   managedImageDistributor image_id Target image ID of the image to build. The resource group should exist and be accessible. Either \u0026lsquo;image_id\u0026rsquo; or \u0026lsquo;image_name\u0026rsquo; must be set.   managedImageDistributor image_name Target image name of the image to build in the same resource group. Either \u0026lsquo;image_id\u0026rsquo; or \u0026lsquo;image_name\u0026rsquo; must be set.   managedImageDistributor location Azure region where the managed image should be created (required).   managedImageDistributor run_output_name A label for the run, shown in logs and in the portal.   managedImageDistributor add_tags An optional list of tags that will be added on the image.   sharedImageDistributor gallery_image_id Target ID for the gallery image to create. It can reference the image itself or a specific version to create.   sharedImageDistributor add_replication_regions Azure regions where the managed image should be replicated. First in the list should be the location of the image gallery.   sharedImageDistributor exclude_from_latest Option to ensure the image will not be the \u0026ldquo;latest\u0026rdquo; version so it will always be pulled by version number.   sharedImageDistributor run_output_name A label for the run, shown in logs and in the portal.   sharedImageDistributor add_tags An optional list of tags that will be added on the gallery image.   vhdDistributor run_output_name A label for the run, shown in logs and in the portal.   vhdDistributor add_tags An optional list of tags that will be added on the virtual hard disk.    Example open Farmer open Farmer.Builders imageTemplate { name \u0026#34;Ubuntu2004WithJava\u0026#34; add_identity msi source_platform_image Vm.UbuntuServer_2004LTS add_customizers [ shellCustomizer { name \u0026#34;install-jdk\u0026#34; inline_statements [ \u0026#34;set -eux\u0026#34; \u0026#34;sudo apt-get update\u0026#34; \u0026#34;sudo apt-get -y upgrade\u0026#34; \u0026#34;sudo apt-get -y install openjdk-17-jre-headless\u0026#34; ] } ] add_distributors [ sharedImageDistributor { gallery_image_id (ResourceType(\u0026#34;Microsoft.Compute/galleries/images\u0026#34;, \u0026#34;2020-09-30\u0026#34;) .resourceId ( ResourceName \u0026#34;my-image-gallery\u0026#34;, ResourceName \u0026#34;java-server-os\u0026#34; ) ) add_replication_regions [ Location.EastUS ] add_tags [ \u0026#34;image-type\u0026#34;, \u0026#34;java\u0026#34; ] } ] } "},{"uri":"https://compositionalit.github.io/farmer/contributing/adding-resources/","title":"Supporting a new ARM Resource","tags":[],"description":"","content":"This set of guided exercises shows the different steps required to design new ARM resources that can be consumed in Farmer. This tutorial will show you the steps to take create a resource that can hook into the Farmer pipeline, by adding support to Farmer for the ContainerRegistry Azure resource. This will involve:\n Defining an type that implements IArmResource that maps directly to the ARM template output. Defining any domain types required to capture details on the resource. Defining a type that implements IBuilder and an associated computation expression that will be easier for users to consume than an F# record.  This will end up allowing us to define a resource that looks like this:\nlet myRegistry = containerRegistry { name \u0026#34;devonRegistry\u0026#34; sku ContainerRegistrySku.Basic enable_admin_user } let deployment = arm { location Location.WestCentralUS add_resource myRegistry } which generates JSON looking something like this:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#\u0026#34;, \u0026#34;contentVersion\u0026#34;: \u0026#34;1.0.0.0\u0026#34;, \u0026#34;outputs\u0026#34;: {}, \u0026#34;parameters\u0026#34;: {}, \u0026#34;resources\u0026#34;: [ { \u0026#34;apiVersion\u0026#34;: \u0026#34;2019-05-01\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;westcentralus\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;my-registry\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;adminUserEnabled\u0026#34;: true }, \u0026#34;sku\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Basic\u0026#34; }, \u0026#34;type\u0026#34;: \u0026#34;Microsoft.ContainerRegistry/registries\u0026#34; } ] } Useful terminology  Resource: A resource is a single Azure service provided by ARM; in Farmer these resource models are created by implementing the IArmResource interface. Template: Represents an ARM template with parameters, outputs and zero, one or many resources. Location: An Azure Region where a service exists. Deployment: Represents the deployment of an ARM template to a specific Location and Resource Group name. Builder: In Farmer, an IBuilder provides the capability of creating a smart type that helps model a resource or a collection of resources into associated IArmResource objects required for constructing the ARM template. For example, Farmer\u0026rsquo;s WebApp builder provides a logical abstraction on top of several ARM resources: Web App, Server Farm and Application Insights.  Requirements  Minimum version is 2.5.0 of Azure CLI Azure account to test against  "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/","title":"Resources","tags":[],"description":"","content":"Resources Farmer currently has support for the most popular resources in Azure, such as Storage, App Service and Functions. You can find out more about each resource in detail in the menu.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/keyvault/","title":"Key Vault","tags":[],"description":"","content":"Overview The KeyVault package contains four builders, for the different components used by KeyVault: One for access policies, one for secrets, one for the overall keyvault container, and one for adding access policies to an existing key vault.\n Keys (Microsoft.KeyVault/vaults/keys) KeyVault (Microsoft.KeyVault/vaults) Secrets (Microsoft.KeyVault/vaults/secrets) AccessPolicies (Microsoft.KeyVault/vaults/accessPolicies)  Key Builder The key builder allows you to generate RSA and elliptical curve keys in the key vault.\n   Keyword Purpose     name Sets the name of the key to generate.   key_operations Sets the operations that they generated key can be used to perform.   key_type Sets the type of key. Helpers are defined for many typical types: RSA_2048, RSA_3072, RSA_4096, EC_P256, EC_P384, EC_P521, EC_P256K   status Enables or disables the key (defaults to \u0026lsquo;Enabled\u0026rsquo;).   activation_date Sets the activation date of the key.   expiration_date Sets the expiration date of the key.   link_to_unmanaged_keyvault Links this key to an existing keyvault and allows the key to be deployed standalone   depends_on Sets the dependencies of the key vault.   add_tag Adds a tag to the secret.   add_tags Adds multiple tags to the secret.    Secret Builder The secret builder allows you to store secrets into key vault. Values for a secret are passed by Secure String parameters.\n   Keyword Purpose     name Sets the name of the secret.   value Sets the name of the secure string parameter that will contain the value of the secret.   content_type Sets the content type of the secret.   status Enables or disables the secret (defaults to \u0026lsquo;Enabled\u0026rsquo;).   activation_date Sets the activation date of the secret.   expiration_date Sets the expiration date of the secret.   link_to_unmanaged_keyvault Links this secret to an existing keyvault and allows the secret to be deployed standalone   depends_on Sets the dependencies of the key vault.   add_tag Adds a tag to the secret.   add_tags Adds multiple tags to the secret.    Access Policy Builder The accessPolicy builder allows you to create access policies for key vault.\n   Keyword Purpose     object_id Sets the Object ID of the permission set.   application_id Sets the Application ID of the permission set.   key_permissions Sets the Key permissions of the permission set.   storage_permissions Sets the Storage permissions of the permission set.   secret_permissions Sets the Secret permissions of the permission set.   certificate_permissions Sets the Certificate permissions of the permission set.    Key Vault Builder The keyVault builder contains access policies, secrets, and configuration information to create a full key vault account.\n   Keyword Purpose     name Sets the name of the vault.   sku Sets the sku of the vault.   tenant_id Sets the Tenant ID of the vault.   enable_vm_access Allows VM access to the vault.   disable_vm_access Disallows VM access to the vault.   enable_resource_manager_access Allows Resource Manager access to the vault.   disable_resource_manager_access Disallows Resource Manager access to the vault.   enable_disk_encryption_access Allows Azure Disk Encyption service access to the vault.   disable_disk_encryption_access Disallows Azure Disk Encyption service access to the vault.   enable_rbac Enables Azure role based access control for data access.   disable_rbac Disables Azure role based access control for data access.   enable_soft_delete Enables VM access to the vault.   enable_soft_delete_with_purge_protection Disables VM access to the vault.   uri Sets the URI of the vault.   enable_recovery_mode Sets the Creation Mode to Recovery.   disable_recovery_mode Sets the Creation Mode to Default.   add_access_policy Adds an access policy to the vault.   add_access_policies Adds access policies to the vault.   enable_azure_services_bypass Allows Azure traffic can bypass network rules.   disable_azure_services_bypass Disallows Azure traffic can bypass network rules.   allow_default_traffic Allow traffic if no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   deny_default_traffic Deny traffic when no rule from ipRules and virtualNetworkRules match. This is only used after the bypass property has been evaluated.   add_ip_rule Adds an IP address rule. This can be an IPv4 address range in CIDR notation, such as \u0026lsquo;124.56.78.91\u0026rsquo; (simple IP address) or \u0026lsquo;124.56.78.0/24\u0026rsquo; (all addresses that start with 124.56.78).   add_vnet_rule Adds a virtual network rule. This is the full resource id of a vnet subnet, such as \u0026lsquo;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026rsquo;.   add_secret Adds a secret to the vault. This can either be a \u0026ldquo;full\u0026rdquo; secret config created using the Secret Builder, a string literal value which represents the parameter name, or a string literal with a resource and an expression based on that resource e.g. a storage account and the Key member.   add_secrets Adds multiple secrets to the vault. This can either be \u0026ldquo;full\u0026rdquo; secret configs created using the Secret Builder, string literal values which represents the parameter name.   disable_public_network_access Disables public network access to the vault.   add_tag Adds a tag to the key vault.   add_tags Adds multiple tags to the key vault.    Key Vault Add Access Policy Builder (keyVaultAddPolicies) As applications grow, more components often need access to a key vault. The keyVaultAddPolicies builder is used to add new access policies to an existing key vault without the need to redeploy the full key vault, potentially changing existing access.\n   Keyword Purpose     key_vault Sets the resource Id or a builder for the existing key vault where the policies should be added.   add_access_policies A list of policies to add to the key vault.   tenant_id Used if granting access to users or service principals from another tenant.    Configuration Members    Member Purpose     VaultUri Gets the ARM expression path to the key vault\u0026rsquo;s URI.    Utilities  The KeyVault module comes with a set of utility functions to quickly create access policies if you do not wish to use the AccessPolicy builder, in the Farmer.KeyVault.AccessPolicy module which enable creating an access policy for a PrincipalId or an ObjectId which will have the GET Secret permission. In addition, the AccessPolicy module also contains helpers to search for users or groups in active directory (requires Azure CLI installed), as well as their Object IDs. These can be used to rapidly create Access Policies for specific users.  Example open Farmer open Farmer.Builders open Farmer.KeyVault open System let policy = accessPolicy { object_id Guid.Empty application_id Guid.Empty certificate_permissions [ KeyVault.Certificate.List ] secret_permissions KeyVault.Secret.All key_permissions [ KeyVault.Key.List ] } let complexSecret = secret { name \u0026#34;myComplexSecret\u0026#34; content_type \u0026#34;application/text\u0026#34; status Enabled activation_date (DateTime.Today.AddDays -1.) expiration_date (DateTime.Today.AddDays 1.) } let vault = keyVault { name \u0026#34;MyVault\u0026#34; sku KeyVault.Sku.Standard tenant_id Guid.Empty enable_disk_encryption_access enable_resource_manager_access enable_soft_delete_with_purge_protection disable_vm_access enable_recovery_mode add_access_policy policy enable_azure_services_bypass add_ip_rule \u0026#34;127.0.0.1\u0026#34; add_vnet_rule \u0026#34;/subscriptions/subid/resourceGroups/rg1/providers/Microsoft.Network/virtualNetworks/test-vnet/subnets/subnet1\u0026#34; allow_default_traffic add_secret complexSecret add_secret \u0026#34;simpleSecret\u0026#34; add_secrets [ \u0026#34;firstSecret\u0026#34;; \u0026#34;secondSecret\u0026#34;] add_keys [ key { name \u0026#34;myRsaKey\u0026#34; key_type KeyType.RSA_4096 } key { name \u0026#34;myRllipticalCurveKey\u0026#34; key_type KeyType.EC_P256 } ] } arm { add_resource vault output \u0026#34;vault-uri\u0026#34; vault.VaultUri } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/private-endpoint/","title":"Private Endpoint","tags":[],"description":"","content":"Overview The Private Endpoint builder (privateEndpoint) creates a private endpoint for accessing Azure resources or a private link service without traversing the Internet.\n Private Endpoint (Microsoft.Network/privateEndpoints)  Builder Keywords    Applies To Keyword Purpose     privateEndpoint name Specifies the name of the private endpoint.   privateEndpoint subnet_reference Attaches the private endpoint to a referenced subnet.   privateEndpoint link_to_subnet Attaches the private endpoint to a subnet deployed in the same deployment.   privateEndpoint link_to_unmanaged_subnet Attaches the private endpoint to an existing subnet.   privateEndpoint resource Specifies the ARM resource ID of the service it is connecting to.   privateEndpoint custom_nic_name Optionally specify the name for the NIC generated for the private endpoint.   privateEndpoint add_group_ids Specify one or more group IDs the private link service provides.    Configuration Members    Member Purpose     CustomNicEndpointIP  If the custom_nic_name is set, this gets an ARM Expression to get the private endpoint IP address by 0-based index.   CustomNicFirstEndpointIP If the custom_nic_name is set, this gets an ARM Expression to get the first private endpoint IP address.    Example open Farmer open Farmer.Builders let myPrivateEndpoint = privateEndpoint { name \u0026#34;private-endpoint\u0026#34; custom_nic_name \u0026#34;private-endpoint-nic\u0026#34; link_to_subnet (subnets.resourceId (ResourceName \u0026#34;my-net\u0026#34;, ResourceName \u0026#34;priv-endpoints\u0026#34; )) resource (Unmanaged existingPrivateLinkId) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/private-link-service/","title":"Private Link Service","tags":[],"description":"","content":"Overview The Private Link Service builder (privateLink) creates a private link service to access resources behind a load balancer privately from a private endpoint instead of traversing the internet.\n Private Link Services (Microsoft.Network/privateLinkServices)  Builder Keywords    Applies To Keyword Purpose     privateLink name Specifies the name of the private link service   privateLink depends_on Specify any dependencies that must be deployed before this.   privateLink add_auto_approved_subscriptions To auto-approve private endpoints, the subscription for those must be added here.   privateLink add_visible_to_subscriptions To allow subscription to request access for their private endpoints, they must be added here.   privateLink add_load_balancer_frontend_ids Adds the resource ID for the load balancer frontend IP configurations that are accessible through this private link service.   privateLink add_ip_configs Adds the subnet where the private endpoints will connect to this service.   privateLinkIpConfig name Optionally name the IP config   privateLinkIpConfig private_ip_allocation Specifies static or dynamic allocation within the subnet - defaults to Dyanmic   privateLinkIpConfig private_ip_address_version Specifies IPv4 or IPv6 - defaults to IPv4.   privateLinkIpConfig primary Specify this is the primary IP config if connecting to multiple subnets - defaults to false   privateLinkIpConfig link_to_subnet Required - the resource ID of the subnet where private link endpoints will be connected to this service.    Example open Farmer open Farmer.Builders let vnet = vnet { name \u0026#34;private-net\u0026#34; add_address_spaces [ \u0026#34;10.100.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;default\u0026#34; prefix \u0026#34;10.100.0.0/24\u0026#34; } subnet { name \u0026#34;backend-services\u0026#34; prefix \u0026#34;10.100.1.0/24\u0026#34; } subnet { name \u0026#34;private-endpoints\u0026#34; prefix \u0026#34;10.100.255.0/24\u0026#34; private_link_service_network_policies Disabled } ] } let lb = loadBalancer { name \u0026#34;lb\u0026#34; sku LoadBalancer.Sku.Standard depends_on vnet add_frontends [ frontend { name \u0026#34;lb-frontend\u0026#34; private_ip_allocation_method AllocationMethod.DynamicPrivateIp link_to_subnet (ResourceId.create(Farmer.Arm.Network.subnets, vnet.Name, ResourceName \u0026#34;default\u0026#34;)) } ] add_backend_pools [ backendAddressPool { name \u0026#34;lb-backend\u0026#34; } ] add_probes [ loadBalancerProbe { name \u0026#34;httpGet\u0026#34; protocol Farmer.LoadBalancer.LoadBalancerProbeProtocol.HTTP port 80 request_path \u0026#34;/\u0026#34; } ] add_rules [ loadBalancingRule { name \u0026#34;rule1\u0026#34; frontend_ip_config \u0026#34;lb-frontend\u0026#34; backend_address_pool \u0026#34;lb-backend\u0026#34; frontend_port 80 backend_port 80 protocol TransmissionProtocol.TCP probe \u0026#34;httpGet\u0026#34; } ] } privateLink { name \u0026#34;pls\u0026#34; depends_on lb add_auto_approved_subscriptions [ System.Guid.NewGuid() ] add_load_balancer_frontend_ids [ ResourceId.create(Farmer.Arm.LoadBalancer.loadBalancerFrontendIPConfigurations, lb.Name, ResourceName \u0026#34;lb-frontend\u0026#34;) ] add_ip_configs [ privateLinkIpConfig { link_to_subnet (ResourceId.create(Farmer.Arm.Network.subnets, vnet.Name, ResourceName \u0026#34;private-endpoints\u0026#34;)) } ] } arm { add_resources [ vnet lb pls ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/logic-apps/","title":"Logic Apps","tags":[],"description":"","content":"Overview The Logic App builder is used to create Azure Logic App Workflows.\n Workflows (Microsoft.Logic/workflows)  Builder keywords    Keyword Purpose     name Sets the name of the workflow.   definition Sets the file path (via FileDefinition path) or the definition directly (via ValueDefinition value)   add_tags Adds tags to the script runtime resource.   add_tag Adds a tag to the script runtime resource.    Example open Farmer open Farmer.Builders let emptyLogicApp = \u0026#34;\u0026#34;\u0026#34; { \u0026#34;definition\u0026#34;: { \u0026#34;$schema\u0026#34;: \u0026#34;https://schema.management.azure.com/providers/Microsoft.Logic/schemas/2016-06-01/workflowdefinition.json#\u0026#34;, \u0026#34;actions\u0026#34;: {}, \u0026#34;contentVersion\u0026#34;: \u0026#34;1.0.0.0\u0026#34;, \u0026#34;outputs\u0026#34;: {}, \u0026#34;parameters\u0026#34;: {}, \u0026#34;triggers\u0026#34;: {} }, \u0026#34;parameters\u0026#34;: {} } \u0026#34;\u0026#34;\u0026#34; let myValueLogicApp = logicApp { name \u0026#34;value-test-logic-app\u0026#34; definition (ValueDefinition emptyLogicApp) add_tags [(\u0026#34;created-by\u0026#34;, \u0026#34;farmer\u0026#34;)] } let filepath = \u0026#34;./logicAppDefinition.json\u0026#34; let myFileLogicApp = logicApp { name \u0026#34;file-test-logic-app\u0026#34; definition (FileDefinition filepath) add_tags [(\u0026#34;created-by\u0026#34;, \u0026#34;farmer\u0026#34;)] } let deployment = arm { location Location.NorthCentralUS add_resource myValueLogicApp add_resource myFileLogicApp } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/load-balancer/","title":"Load Balancer","tags":[],"description":"","content":"Overview The Load Balancer builder (loadBalancer) creates load balancers that can distribute load amongst healthy services in a backend pool on public or private networks.\n Load balancers (Microsoft.Network/loadBalancers) Load balancer frontend IP configurations (Microsoft.Network/loadBalancers/frontendIPConfigurations) Load balancer backend address pools (Microsoft.Network/loadBalancers/backendAddressPools) Load balancer health probes (Microsoft.Network/loadBalancers/probes)  Builder Keywords    Applies To Keyword Purpose     loadBalancer name Specifies the name of the load balancer   loadBalancer sku Specifies the SKU of the load balancer - default is \u0026lsquo;Basic\u0026rsquo;.   loadBalancer tier Specifies the tier of the load balancer - default is \u0026lsquo;Regional\u0026rsquo;.   loadBalancer add_frontends Adds frontend IP configurations as defined by the frontend builder.   loadBalancer add_backend_pools Adds backend address pool configurations as defined by the backendAddressPool builder.   loadBalancer add_rules Adds load balancing rules as defined by the loadBalancingRule builder.   loadBalancer add_probes Adds probes for the address pool as defined by the loadBalancerProbe builder.   loadBalancer add_dependencies Adds the resource ID\u0026rsquo;s of additional dependencies that must be provisioned before the load balancer.   frontend name Name of the frontend IP configuration.   frontend private_ip_allocation_method Specifies how the private IP is assigned on an internal load balancer.   frontend public_ip Specifies the name of a public IP to generate. It will be generated with the same SKU as the load balancer.   frontend link_to_public_ip The name of an existing public IP to link to.   backendAddressPool name The name of the backend address pool.   backendAddressPool load_balancer The name of a load balancer these should be added to (used when adding to a pool for an existing load balancer).   backendAddressPool vnet Specifies a virtual network in the same deployment where the backend services are connected.   backendAddressPool link_to_vnet Specifies an existing virtual network where the backend services are connected.   backendAddressPool add_ip_addresses Adds IP addresses to the backend pool.   loadBalancerProbe name The name of the load balancer probe.   loadBalancerProbe protocol The protocol to use for the probe - default is TCP.   loadBalancerProbe port The port to probe on the backend service.   loadBalancerProbe request_path For HTTP(S) probes, the request path that returns a 200 when healthy.   loadBalancerProbe interval The interval between 4 and 30 seconds to probe the health of the services in the pool.   loadBalancerProbe number_of_probes The number of probe attempts before considering the service unhealthy.   loadBalancingRule name The name of the load balancing rule.   loadBalancingRule frontend_ip_config The name of the frontend IP configuration to which this rule applies.   loadBalancingRule backend_address_pool The name of the backend address pool to which this rule applies.   loadBalancingRule probe The name of the probe to use to check the health of services in the backend pool.   loadBalancingRule frontend_port The port on the frontend to forward to a backend service.   loadBalancingRule backend_port The target port on the backend service.   loadBalancingRule protocol The protocol to forward, defaults to \u0026lsquo;All\u0026rsquo;.   loadBalancingRule idle_timeout_minutes The time in minutes before a TCP connection is considered idle and disconnected.   loadBalancingRule load_distribution_policy The load distribution policy - \u0026lsquo;Default\u0026rsquo; where a request can go to any backend, \u0026lsquo;SourceIP\u0026rsquo; which is mapped on client IP, or \u0026lsquo;SourceIPProtocol\u0026rsquo; which is mapped on client IP and protocol.   loadBalancingRule enable_tcp_reset After an idle timeout, the TCP connection is reset - defaults to \u0026lsquo;disabled\u0026rsquo;.   loadBalancingRule enable_outbound_snat Allows backend services to use this load balancer for outbound connections - defaults to \u0026lsquo;disabled\u0026rsquo;.    Example open Farmer open Farmer.Builders open Farmer.LoadBalancer arm { add_resources [ vnet { name \u0026#34;my-vnet\u0026#34; add_address_spaces [ \u0026#34;10.0.1.0/24\u0026#34; ] add_subnets [ subnet { name \u0026#34;my-services\u0026#34; prefix \u0026#34;10.0.1.0/24\u0026#34; add_delegations [ SubnetDelegationService.ContainerGroups ] } ] } loadBalancer { name \u0026#34;lb\u0026#34; sku Sku.Standard add_frontends [ frontend { name \u0026#34;lb-frontend\u0026#34; public_ip \u0026#34;lb-pip\u0026#34; } ] add_backend_pools [ backendAddressPool { name \u0026#34;lb-backend\u0026#34; vnet \u0026#34;my-vnet\u0026#34; add_ip_addresses [ \u0026#34;10.0.1.4\u0026#34; \u0026#34;10.0.1.5\u0026#34; ] } ] add_probes [ loadBalancerProbe { name \u0026#34;httpGet\u0026#34; protocol LoadBalancerProbeProtocol.HTTP port 8080 request_path \u0026#34;/\u0026#34; } ] add_rules [ loadBalancingRule { name \u0026#34;rule1\u0026#34; frontend_ip_config \u0026#34;lb-frontend\u0026#34; backend_address_pool \u0026#34;lb-backend\u0026#34; frontend_port 80 backend_port 8080 protocol TransmissionProtocol.TCP probe \u0026#34;httpGet\u0026#34; } ] } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/loganalytics/","title":"Log Analytics","tags":[],"description":"","content":"Overview The Log Analytics builder is used to create Work space instances.\n Log Analytics (Microsoft.OperationalInsights/workspaces)  Builder Keywords    Keyword Purpose     name Sets the name of the log analytics instance.   retention_period Sets the retention period for logs in days.   enable_ingestion Enables ingestion network traffic.   enable_query Enables query network traffic.   daily_cap Specifies an upper limit on the amount of data to ingest daily.   add_tags Adds a set of tags to the resource   add_tag Adds a tag to the resource    Configuration Members    Member Purpose     CustomerID Gets the ARM expression path to the customer ID of this LogAnalytics instance.   CustomerID Gets the ARM expression path to the primary shared key of this LogAnalytics instance.    Example open Farmer open Farmer.Builders let myAnalytics = logAnalytics { name \u0026#34;myloganalytics\u0026#34; retention_period 30\u0026lt;Days\u0026gt; enable_ingestion enable_query daily_cap 5\u0026lt;Gb\u0026gt; add_tag \u0026#34;tag1\u0026#34; \u0026#34;myTestResourceFarmer\u0026#34; } let deployment = arm { location Location.WestEurope add_resource myAnalytics } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/managed-identity/","title":"Managed Identity","tags":[],"description":"","content":"Overview Managed Identity is used to create an identity that resources can run under automatically. This is similar to a service principal except that there is no credential to manage and the authorization token is retrieved through a secure internal handshake between the resource and the identity service in Azure.\n User Assigned Identity (Microsoft.ManagedIdentity/userAssignedIdentities)  Using a managed identity as opposed to e.g. connection strings brings several benefits:\n There is no client secret or certificate to configure and rotate because this is handled implicitly by Azure infrastructure. The identity is tied to one or more specific resources, so cannot be used by anything else, like a user. Many services allow more granular permissions than e.g. a connection string. You can grant and revoke access completely independently of the application attempting to gain access to the resource.  Once created, the managed identity resource can be referenced by other resources both in order to:\n Enable a resource to run as that identity Enable a resource to grant permissions to that identity  For example, you may wish to run a Virtual Machine or an Web App under a identity that you create, and then to grant permissions to that identity to allow reading from a storage account. You can define the permissions completely independently of the Virtual Machine or Web App.\ngraph LR A(identity) B(virtual machine)-. runs as .-A D(web app)-. runs as .-A C(storage account)-. grants permissions .-A A -. request made in this identiy .-C   See here and here for the official documentation on the Microsoft Azure docs website.\n Identity Types in Azure Identities come in two flavours in Azure: System and User assigned.\n System Identities are available whenever you create a resource, such as a VM. Each resource has its own system identity, and they cannot be shared across resources. User Identities are created by you; they exist idependently of any resources and thus can be shared across them. In Farmer, the userAssignedIdentity builder can be used for this. You also need to \u0026ldquo;link\u0026rdquo; a user identity to the resource that you wish to be able to \u0026ldquo;run as\u0026rdquo; it.   User Assigned Identities are themselves ARM resources and need to be added to your Farmer arm {} blocks!\n graph LR A(user assigned identity) subgraph Web App B(system identity) end C(storage account) C -.grants permissions .- A C -.grants permissions .- B  User Assigned Identity Builder The userAssignedIdentity builder constructs user assigned managed identities which can be created and then assigned to one or more resources.\n   Keyword Purpose     name Sets the name of the user assigned identity.   add_tag Adds a tag to the user assigned identity resource.   add_tags Adds multiple tags to the user assigned identity resource.    Helper Methods Because the User Assigned Identity builder is so simple, we also provide a simple builder function to create identities as an alternative to using the standard builder syntax:\nopen Farmer.Builders let uai = createUserAssignedIdentity \u0026#34;mytestidentity\u0026#34; Example: System Identity In this example, a web app needs a secret from a key vault. By using the system identity on the web app, application code can be granted access to the key vault with no need to provide it a client secret.\nopen Farmer open Farmer.Builders let wa = webApp { name \u0026#34;myApp\u0026#34; system_identity // turn on the system identity of the web app } let vault = keyVault { name \u0026#34;my-vault\u0026#34; add_access_policies [ // grant access to the web app\u0026#39;s system identity to key vault.  // by default GET and LIST permissions are granted.  AccessPolicy.create wa.SystemIdentity ] } let template = arm { add_resources [ wa; vault ] } There is no need to add a specific identity resource to Farmer in this case because the System Identity is created along with the web app itself.\nExample: User Assigned Identity In this example, a web app needs access to a Storage Account with a specific role. By assigning an identity to the web app, the application code can be granted access to the storage account; we also provide the Client Id to the application as a public setting in order for the application to correctly impersonate as the identity within code.\nBy creating a user assigned identity, unlike a system identity, we can also apply this identity onto other resources so that they, too, can \u0026ldquo;share\u0026rdquo; the permissions and identity. In this example, we also apply the identity onto a container group.\n// Create a user assigned identity let sharedIdentity = userAssignedIdentity { name \u0026#34;container-group-identity\u0026#34; } // Apply it onto the web app let myWeb = webApp { name \u0026#34;myApp\u0026#34; // Add the identity to the web app  add_identity sharedIdentity // Provide the client id to the app for use in code  setting \u0026#34;ClientId\u0026#34; sharedIdentity.ClientId } let group = containerGroup { name \u0026#34;myapp-with-identity\u0026#34; add_instances [ containerInstance { name \u0026#34;my-app\u0026#34; image \u0026#34;myregistry.azurecr.io/myapp:latest\u0026#34; } ] // Also apply it here. All of the containers in this group share this managed identity.  add_identity sharedIdentity } let data = storageAccount { name \u0026#34;dataidentity\u0026#34; // Allow the shared identity blob data reader access to storage.  grant_access sharedIdentity Roles.StorageBlobDataReader } let deployment = arm { add_resources [ sharedIdentity myWeb group data ] } In this example, notice that we explicitly add the sharedIdentity resource to the arm {} block.\n"},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/maps/","title":"Maps","tags":[],"description":"","content":"Overview The Maps builder creates Azure Maps accounts.\n Maps (Microsoft.Maps/accounts)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Maps account.   sku Sets the sku of the Azure Maps account.    Example open Farmer open Farmer.Builders let myMaps = maps { name \u0026#34;mymaps\u0026#34; sku Maps.S0 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/nsg/","title":"Network Security Group","tags":[],"description":"","content":"Overview The Network Security Group builder creates network security groups with rules for securing network access to resources.\n Network Security Groups (Microsoft.Network/networkSecurityGroups) Security Rules (Microsoft.Network/networkSecurityGroups/securityRules)  Builder Keywords    Applies To Keyword Purpose     nsg name Specifies the name of the network security group   nsg add_rules Adds security rules to the network security group   nsg initial_rule_priority The priority of the first rule, after which each rule gets an incrementally higher value. Default 100.   nsg priority_incr This sets how much priority is increased per each rule. Default 100.   securityRule name The name of the security rule   securityRule description The description of the security rule   securityRule services The services port(s) and protocol(s) protected by this security rule   securityRule add_source Specify access from any source protocol, address, and port   securityRule add_source_any Specify access from any address and any port   securityRule add_source_address Specify access from a specific address and any port   securityRule add_source_network Specify access from a specific network and any port   securityRule add_source_tag Specify access from a tagged source such as \u0026ldquo;Internet\u0026rdquo;, \u0026ldquo;VirtualNetwork\u0026rdquo;, or \u0026ldquo;AzureLoadBalancer\u0026rdquo;   securityRule add_destination Specify access to any source protocol, address, and port   securityRule add_destination_any Specify access to any address and any port   securityRule add_destination_address Specify access to a specific address and any port   securityRule add_destination_network Specify access from a specific network and any port   securityRule add_destination_tag Specify access to a tagged destination such as \u0026ldquo;Internet\u0026rdquo;, \u0026ldquo;VirtualNetwork\u0026rdquo;, or \u0026ldquo;AzureLoadBalancer\u0026rdquo;   securityRule allow Allows this traffic (the default)   securityRule deny Denies this traffic   securityRule direction Specify the direction of traffic controlled by the rule - inbound (the default) or outbound.   securityRule priority Explicitly specify the priority of a security rule.   securityRule link_to_network_security_group Specify the nsg when creating a security rule for an existing security group.    Basic Example open Farmer open Farmer.Builders open Farmer.NetworkSecurity // Create a rule for https services accessible from the internet let httpsAccess = securityRule { name \u0026#34;web-servers\u0026#34; services [ NetworkService (\u0026#34;https\u0026#34;, Port 443us) ] add_source_tag TCP \u0026#34;Internet\u0026#34; add_destination_any } // Create an NSG and add the rule to it. let myNsg = nsg { name \u0026#34;my-nsg\u0026#34; add_rules [ httpsAccess ] } Multiple Tier Private Network Example open Farmer open Farmer.Builders open Farmer.NetworkSecurity // Many services have a few ports, such as web services that are often on 80 and 443. // Some services only have a single port // Different tiers may reside on different network segments let corporateNet = \u0026#34;172.24.0.0/20\u0026#34; let webNet = \u0026#34;10.100.30.0/24\u0026#34; let appNet = \u0026#34;10.100.31.0/24\u0026#34; let dbNet = \u0026#34;10.100.32.0/24\u0026#34; // Create a rule for web servers - the \u0026#39;web\u0026#39; service, accessible from the corporate network let webAccess = securityRule { name \u0026#34;web-servers\u0026#34; description \u0026#34;Public web server access\u0026#34; services [ NetworkService (\u0026#34;http\u0026#34;, Port 80us) NetworkService (\u0026#34;https\u0026#34;, Port 443us) ] add_source_network TCP corporateNet add_destination_network webNet } // Create another rule for app servers - accessible only from network with the web servers let appAccess= securityRule { name \u0026#34;app-servers\u0026#34; description \u0026#34;Internal app server access\u0026#34; services [ NetworkService (\u0026#34;http\u0026#34;, Port 8080us) ] add_source_network TCP webNet add_destination_network appNet } // Create another rule for DB servers - accessible only from network with the app servers let dbAccess = securityRule { name \u0026#34;db-servers\u0026#34; description \u0026#34;Internal database server access\u0026#34; services [ NetworkService (\u0026#34;postgres\u0026#34;, Port 5432us)] add_source_network TCP appNet add_destination_network dbNet } // Create an NSG and add all 3 rules to it. let myNsg = nsg { name \u0026#34;my-nsg\u0026#34; add_rules [ webAccess appAccess dbAccess ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/operations-management/","title":"Operations Management","tags":[],"description":"","content":"Overview The Operations Management builder is used to create Solutions for a Log Analytics Workspace.\nBuilder Keywords    Builder Keyword Purpose     omsPlan name The name of the plan, which can match the name of the overall Solution.   omsPlan publisher The publisher of the solution, usually \u0026ldquo;Microsoft\u0026rdquo; (the default value).   omsPlan product The specific solution being created, such as OMGSGallery/SecurityInsights.   omsProperties workspace The Log Analytics workspace this solution uses.   omsProperties add_contained_resource Adds a resource contained by this solution.   omsProperties add_contained_resources Adds multiple resources contained by this solution.   omsProperties add_referenced_resource Adds a resource referenced by this solution.   omsProperties add_referenced_resources Adds multiple resources referenced by this solution.   oms name The name of the solution.   oms plan The OMSPlan for the solution.   oms properties The OMSProperties for the solution.   oms add_tag Add a tag to the solution.   oms add_tags Add one or more tags to the solution.    Example This example creates an Azure Sentinel solution on an Log Analytics Workspace.\nopen Farmer open Farmer.Builders let sentinelWorkspace = logAnalytics { name \u0026#34;my-sentinel-workspace\u0026#34; retention_period 30\u0026lt;Days\u0026gt; enable_query daily_cap 5\u0026lt;Gb\u0026gt; } let solutionName = $\u0026#34;SecurityInsights({sentinelWorkspace.Name.Value})\u0026#34; let sentinelSolution = oms { name solutionName plan (omsPlan { name solutionName publisher \u0026#34;Microsoft\u0026#34; product \u0026#34;OMSGallery/SecurityInsights\u0026#34; }) properties(omsProperties { workspace sentinelWorkspace }) } let deployment = arm { location Location.NorthCentralUS add_resource sentinelWorkspace add_resource sentinelSolution } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/postgresql/","title":"PostgreSQL","tags":[],"description":"","content":"Overview The PostgreSQL module contains two builders - postgreSQL, used to create PostgreSQL Azure servers, and postgreSQLDb, used to create individual databases. It supports features such as firewall, autogrow and version selection. Every PostgreSQL Azure server you create will automatically create a SecureString parameter for the admin account password.\n PostgreSQL server (Microsoft.DBforPostgreSQL/servers)  PostgreSQL Builder keywords    Applies To Keyword Purpose     Server name (string) Sets the name of the PostgreSQL server.   Server admin_username (string) Sets the admin username of the server.   Server geo_redundant_backup (bool) Enables/disables geo-redundant backup   Server enable_geo_redundant_backup Enables geo-redundant backup   Server disable_geo_redundant_backup Disables geo-redundant backup   Server storage_autogrow (bool) Enables/disables auto-grow storage   Server enable_storage_autogrow Enables auto-grow storage   Server disable_storage_autogrow Disables auto-grow storage   Server storage_size (int\u0026lt;Gb\u0026gt;) Sets the initial size of the storage available   Server backup_retention (int\u0026lt;Days\u0026gt;) Sets the number of days to keep backups   Server server_version (Version) Selects the PostgreSQL version of the server   Server capacity (int\u0026lt;VCores\u0026gt;) Sets the number of cores for the server   Server tier (Sku) Sets the service tier of the server   Server add_database (database:Database) Adds a database from the result of a postgreSQLDb builder expression   Server add_database (name:string) Adds a database with name of name   Server enable_azure_firewall Enables firewall access to all Azure services   Server add_firewall_rule (name:string, start ip:string, end ip:string) Adds a firewall rule to the server   Server add_firewall_rules (rules:(stringstringsting)list) As add_firewall_rule but a list of rules   Server add_vnet_rule (name:string, virtualNetworkSubnetId:ResourceId) Adds a vnet rule to the server   Server add_vnet_rules (rules:(string*ResourceId)list) As add_vnet_rule but a list of rules    Configuration Members    Member Purpose     FullyQualifiedDomainName The fully qualified domain name for the server endpoint.    PostgreSQLDb Builder keywords    Applies To Keyword Purpose     Database name (string) Sets the name of the PostgreSQL database   Database collation (string) Sets the collation of the postgreSQL database   Database charset (string) Sets the charset of the postgreSQL database    Example open Farmer open Farmer.Builders open Farmer.PostgreSQL let myPostgres = postgreSQL { admin_username \u0026#34;adminallthethings\u0026#34; name \u0026#34;aserverformultitudes42\u0026#34; capacity 4\u0026lt;VCores\u0026gt; storage_size 50\u0026lt;Gb\u0026gt; tier GeneralPurpose add_database \u0026#34;my_db\u0026#34; enable_azure_firewall } let template = arm { location Location.NorthEurope add_resource myPostgres output \u0026#34;fqdn\u0026#34; myPostgres.FullyQualifiedDomainName } // WARNING: // since there is currently no free tier for PostgreSQL, actually deploying this // *will* incur spending on your subscription. template |\u0026gt; Write.quickWrite \u0026#34;postgres-example\u0026#34; "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/redis/","title":"Redis Cache","tags":[],"description":"","content":"Overview The Redis builder creates managed Redis Cache accounts.\n Redis (Microsoft.Cache/redis)  Builder Keywords    Keyword Purpose     name Sets the name of the Redis cache instance.   sku Sets the sku of the Redis cache instance.   capacity Sets the capacity level of the Redis cache instance, should be between 1-6 - see here.   enable_non_ssl_port Enabled access to the cache over the non-SSL port.   setting Allows you to set a Redis-cache specific setting at deployment-time    Configuration Members    Member Purpose     Key Gets an ARM expression for the primary key of the Redis cache instance.    Example open Farmer open Farmer.Builders.Redis let myCache = redis { name \u0026#34;myredis\u0026#34; sku Redis.Standard capacity 1 enable_non_ssl_port setting \u0026#34;maxclients\u0026#34; 256 setting \u0026#34;maxmemory-reserved\u0026#34; 2 setting \u0026#34;maxfragmentationmemory-reserved\u0026#34; 12 setting \u0026#34;maxmemory-delta\u0026#34; 2 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/resource-group/","title":"Resource Group","tags":[],"description":"","content":"Overview The Resource Group builder is always the top-level element of your deployment. It contains the manifest of all Farmer resources that you create.\nBuilder Keywords    Keyword Purpose     location Sets the default location of all resources.   add_resource Adds a resource to the template.   add_resources Adds a collection of resources to the template.   add_arm_resources Adds a collection of lower-level IArmResources to the template.   add_parameter_values Adds a collection of parameter values to pass to the nested deployment\u0026rsquo;s parameters.   add_secret_references Adds a collection of key vault secret references to pass to the nested deployment\u0026rsquo;s parameters.   output Creates an output value that will be returned by the ARM template. Since Farmer does not require variables, and the only parameters supported are secure strings, these will typically be an ARM expressions that are generated at deployment-time, such as the publishing password of a web app or the fully-qualified domain name of a SQL instance etc.   outputs Create multiple outputs.   add_tag Add a tag to the resource group for top-level instances or to the deployment for nested resource groups   add_tags Add multiple tags to the resource group for top-level instances or to the deployment for nested resource groups   name the name of the resource group (only used for nested resource group deployments)   subscription_id On nested resource group deployments, specify the target subscription.   deployment_name allows manual customisation of the deployment name. By default this will be generated for you. (only used for nested resource group deployments)    Utilities  The createResourceGroup function is used to define a resource group deployment resource by name and location, useful when deploying to a subscription.  Example let deployment = arm { // All resources will share this location  location Location.NorthEurope // Assume myStorageAccount and myWebApp have been defined...  add_resource myStorageAccount add_resource myWebApp // Assuming the role assignments have been defined....  add_arm_resources [ roleAssignment1; roleAssignment2 ] add_resource (resourceGroup { name \u0026#34;nestedResourceGroup\u0026#34; add_resource myOtherStorage }) output \u0026#34;webAppName\u0026#34; myWebApp.Name output \u0026#34;webAppPassword\u0026#34; myWebApp.PublishingPassword add_tag \u0026#34;deployed-by\u0026#34; \u0026#34;farmer\u0026#34; } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/signalr/","title":"SignalR","tags":[],"description":"","content":"Overview The SignalR builder creates SignalR services.\n SignalR Service (Microsoft.SignalRService/signalR)  Builder Keywords    Keyword Purpose     name Sets the name of the SignalR service.   sku Sets the sku of the SignalR service.   capacity Sets the capacity of the SignalR service. (optional)   service_mode Sets the service mode of the SignalR service. (optional)   allowed_origins Sets the allowed origins of the SignalR service. (optional)    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the primary Key of the service. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.   ConnectionString Returns an ARM expression to retrieve the primary Connection String of the service. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.    Example open Farmer open Farmer.Builders let mySignalR = signalR { name \u0026#34;mysignalr\u0026#34; sku SignalR.Standard capacity 10 service_mode ServiceMode.Default allowed_origins [ \u0026#34;https://github.com\u0026#34; ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/search/","title":"Search","tags":[],"description":"","content":"Overview The Search builder creates storage accounts and their associated containers.\n Search (Microsoft.Search/searchServices)  Builder Keywords    Keyword Purpose     name Sets the name of the Azure Search instance.   sku Sets the sku of the Azure Search instance.   replicas Sets the replica count of the Azure Search instance.   partitions Sets the number of partitions of the Azure Search instance.    Configuration Members    Member Purpose     AdminKey Gets an ARM expression for the admin key of the search instance.   QueryKey Gets an ARM expression for the query key of the search instance.    Example open Farmer open Farmer.Builders let mySearch = search { name \u0026#34;isaacsSearch\u0026#34; sku Search.Basic } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/service-bus/","title":"Service Bus","tags":[],"description":"","content":"Overview The Service Bus builder creates service bus namespaces and their associated queues.\n Service Bus Namespaces (Microsoft.ServiceBus/namespaces)  Builder Keywords    Applies To Keyword Purpose     Queue name The name of the queue.   Queue lock_duration_minutes The length of time that a lock can be held on a message.   Queue max_delivery_count The maximum number of times a message can be delivered before dead lettering.   Queue duplicate_detection Whether to enable duplicate detection, and if so, how long to check for.   Queue duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for in minutes.   Queue enable_session Enables session support.   Queue enable_dead_letter_on_message_expiration Enables dead lettering of messages that expire.   Queue enable_partition Enables partition support on the queue.   Queue link_to_unmanaged_namespace Link this queue to an existing namespace instead of creating a new one.   Queue max_queue_size Maximum size for the queue in Megabytes e.g. 1024\u0026lt;Mb\u0026gt;.   Queue message_ttl Time To Live (TTL) value for messages expressed as a TimeSpan or a TimeSpan string, such as \u0026lsquo;01:30:00\u0026rsquo; 1 hour, 30 minutes.   Queue message_ttl_days Time To Live (TTL) value for messages in days.   Queue add_authorization_rule Adds an authorization rule to the queue.   Subscription name The name of the subscription.   Subscription lock_duration_minutes The length of time that a lock can be held on a message.   Subscription max_delivery_count The maximum number of times a message can be delivered before dead lettering.   Subscription duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for.   Subscription enable_session Enables session support.   Subscription enable_dead_letter_on_message_expiration Enables dead lettering of messages that expire.   Subscription enable_partition Enables partition support on the queue.   Subscription forward_to Specifies a queue or topic to automatically forward messages delivered to this subscription.   Subscription link_to_unmanaged_namespace Link this queue to an existing namespace instead of creating a new one.   Subscription message_ttl Time To Live (TTL) value for messages expressed as a TimeSpan or a TimeSpan string, such as \u0026lsquo;01:30:00\u0026rsquo; 1 hour, 30 minutes.   Subscription add_filters Adds multiple filters to a subscription   Subscription add_sql_filter Adds a filter to a subscription using SQL syntax.   Subscription add_correlation_filter Adds a filter to a subscription using header value correlation.   Topic name The name of the topic.   Topic duplicate_detection Whether to enable duplicate detection, and if so, how long to check for.   Topic duplicate_detection_minutes Whether to enable duplicate detection, and if so, how long to check for in minutes.   Topic enable_partition Enables partition support on the topic.   Topic max_topic_size Maximum size for the topic in Megabytes e.g. 1024\u0026lt;Mb\u0026gt;.   Topic message_ttl Time To Live (TTL) value for messages expressed as a TimeSpan or a TimeSpan string, such as \u0026lsquo;01:30:00\u0026rsquo; 1 hour, 30 minutes, or as an integer days e.g. 4\u0026lt;Days\u0026gt;.   Topic link_to_unmanaged_namespace Instead of creating or modifying a namespace, configure this topic to point to another unmanaged namespace instance.   Namespace sku The ServiceBusNamespaceSku e.g. Standard   Namespace namespace_name The name of the namespace that holds the queue.   Namespace depends_on Sets dependencies on the service bus namespace.   Namespace enable_zone_redundancy Enables zone redundancy.   Namespace disable_public_network_access Disables public network access to the namespace.   Namespace min_tls_version Set the minimum TLS version for clients connecting to the namespace.    Configuration Members    Member Purpose     NamespaceDefaultConnectionString Returns an ARM expression to retrieve the Primary Connection String of the service bus.   DefaultSharedAccessPolicyPrimaryKey Returns an ARM expression to retrieve the Primary Key of the service bus.    Example open Farmer open Farmer.Builders open Farmer.ServiceBus let myServiceBus = serviceBus { name \u0026#34;my-namespace\u0026#34; sku Standard add_queues [ queue { name \u0026#34;queueA\u0026#34; } queue { name \u0026#34;queueB\u0026#34; } ] add_topics [ topic { name \u0026#34;topicA\u0026#34; } topic { name \u0026#34;topicB\u0026#34; } ] } let deployment = arm { location Location.NorthEurope add_resource myServiceBus output \u0026#34;connectionString\u0026#34; myServiceBus.NamespaceDefaultConnectionString output \u0026#34;defaultSharedAccessPolicyPrimaryKey\u0026#34; myServiceBus.DefaultSharedAccessPolicyPrimaryKey } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/sql/","title":"SQL Azure","tags":[],"description":"","content":"Overview The SQL Azure module contains two builders - sqlServer, used to create SQL Azure servers, and sqlDb, used to create individual databases. It supports features such as encryption, firewalls and automatic pool creation. Every SQL Azure server you create will automatically create a SecureString parameter for the admin account password.\n SQL Azure server (Microsoft.Sql/servers)  SQL Server Builder Keywords    Keyword Purpose     name Sets the name of the SQL server.   active_directory_admin Sets Active Directory admin of the server   add_firewall_rule Adds a custom firewall rule given a name, start and end IP address range.   add_firewall_rules As add_firewall_rule but a list of rules   enable_azure_firewall Adds a firewall rule that enables access to other Azure services.   admin_username Sets the admin username of the server.   elastic_pool_name Sets the name of the elastic pool, if required. If not set, Farmer will generate a name for you.   elastic_pool_sku Sets the sku of the elastic pool, if required. If not set, Farmer will default to Basic 50.   elastic_pool_database_min_max Sets the optional minimum and maximum DTUs for the elastic pool for each database.   elastic_pool_capacity Sets the optional disk size in MB for the elastic pool for each database.   min_tls_version Sets the minium TLS version for the SQL server   geo_replicate Geo-replicate all the databases in this server to another location, having NameSuffix after original server and database names.    ActiveDirectoryAdminSettings Members    Member Purpose     Login Display name of AD admin   Sid AD object id of AD admin (user or group)   PrincipalType ActiveDirectoryPrincipalType User or Group   AdOnlyAuth Disables SQL authentication. False value required admin_username to be set    SQL Server Configuration Members    Member Purpose     ConnectionString Gets a literal .NET connection string using the administrator username / password, given a database or database name. The password will be evaluated based on the contents of the password parameter supplied to the template at deploy time.   PasswordParameter Gets a string that represents the parameter password required for deployment on the sql instance by Farmer e.g. \u0026ldquo;password-for-mysqlserver\u0026rdquo;.    SQL Database Builder Keywords    Keyword Purpose     name Sets the name of the database.   sku Sets the sku of the database. If not set, the database is assumed to be part of an elastic pool which will be automatically created.   hybrid_benefit If a VCore-style SKU is selected, this allows you to use Azure Hybrid Benefit licensing.   db_size Sets the maximum database size.   collation Sets the collation of the database.   use_encryption Enables transparent data encryption of the database.    Example AD auth not set open Farmer open Farmer.Builders open Sql let myDatabases = sqlServer { name \u0026#34;my_server\u0026#34; admin_username \u0026#34;admin_username\u0026#34; enable_azure_firewall elastic_pool_name \u0026#34;mypool\u0026#34; elastic_pool_sku PoolSku.Basic100 add_databases [ sqlDb { name \u0026#34;poolDb1\u0026#34; } sqlDb { name \u0026#34;poolDb2\u0026#34; } sqlDb { name \u0026#34;dtuDb\u0026#34;; sku Basic } sqlDb { name \u0026#34;memoryDb\u0026#34;; sku M_8 } sqlDb { name \u0026#34;cpuDb\u0026#34;; sku Fsv2_8 } sqlDb { name \u0026#34;businessCriticalDb\u0026#34;; sku (BusinessCritical Gen5_2) } sqlDb { name \u0026#34;hyperscaleDb\u0026#34;; sku (Hyperscale Gen5_2) } sqlDb { name \u0026#34;generalPurposeDb\u0026#34; sku (GeneralPurpose Gen5_8) db_size (1024\u0026lt;Mb\u0026gt; * 128) hybrid_benefit } ] } let template = arm { location Location.NorthEurope add_resource myDatabases } template |\u0026gt; Writer.quickWrite \u0026#34;sql-example\u0026#34; template |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ \u0026#34;password-for-my_server\u0026#34;, \u0026#34;*****\u0026#34; ] AD auth set open Farmer open Farmer.Builders open Sql open Farmer.Arm.Sql let activeDirectoryAdmin: ActiveDirectoryAdminSettings = { Login = \u0026#34;adadmin\u0026#34; Sid = \u0026#34;F9D49C34-01BA-4897-B7E2-3694BF3DE2CF\u0026#34; PrincipalType = ActiveDirectoryPrincipalType.User AdOnlyAuth = false // when false, admin_username is required  // when true admin_username is ignored  } let myDatabases = sqlServer { name \u0026#34;my_server\u0026#34; active_directory_admin (Some(activeDirectoryAdmin)) admin_username \u0026#34;admin_username\u0026#34; enable_azure_firewall elastic_pool_name \u0026#34;mypool\u0026#34; elastic_pool_sku PoolSku.Basic100 add_databases [ sqlDb { name \u0026#34;poolDb1\u0026#34; } sqlDb { name \u0026#34;poolDb2\u0026#34; } sqlDb { name \u0026#34;dtuDb\u0026#34;; sku Basic } sqlDb { name \u0026#34;memoryDb\u0026#34;; sku M_8 } sqlDb { name \u0026#34;cpuDb\u0026#34;; sku Fsv2_8 } sqlDb { name \u0026#34;businessCriticalDb\u0026#34;; sku (BusinessCritical Gen5_2) } sqlDb { name \u0026#34;hyperscaleDb\u0026#34;; sku (Hyperscale Gen5_2) } sqlDb { name \u0026#34;generalPurposeDb\u0026#34; sku (GeneralPurpose Gen5_8) db_size (1024\u0026lt;Mb\u0026gt; * 128) hybrid_benefit } ] } let template = arm { location Location.NorthEurope add_resource myDatabases } template |\u0026gt; Writer.quickWrite \u0026#34;sql-example\u0026#34; template |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ \u0026#34;password-for-my_server\u0026#34;, \u0026#34;*****\u0026#34; ] "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/static-web-app/","title":"Static Web Apps","tags":[],"description":"","content":"Overview The Static Web App builder is used to create Static Web Apps. The Static Web App service is modern web app service that offers streamlined full-stack development from source code to global high availability. You can use it to host static web applications and Azure Functions in a single resource, using GitHub native workflows to build and deploy your application.\n Static Site (Microsoft.Web/staticSites)   At the time of writing, Static Web Apps are in public preview. Not all Azure locations support them.\n Static Web App Builder Keywords    Keyword Purpose     name Sets the name of the static web app.   repository The URI of the github repository containing your static web app.   artifact_location The folder where the built web app is copied to e.g. build (optional)   api_location The path containing your Azure Functions (optional)   app_location The path containing your application code (optional)   branch The branch that you which to use for the static web app (optional, defaults to \u0026lsquo;master\u0026rsquo;)   app_settings Accepts a list of tuple strings representing key/value pairs for the app setting of the static web app    Configuration Members    Name Purpose     RepositoryParameter Provides the generated name for the repository token parameter name.    Parameters    Name Purpose     repositorytoken-for-name Provides the Github Personal Access Token (PAT) required to authenticate and create the appropriate Github Action.    Example open Farmer open Farmer.Builders let myApp = staticWebApp { name \u0026#34;isaacsstatic\u0026#34; repository \u0026#34;https://github.com/isaacabraham/staticwebreact\u0026#34; artifact_location \u0026#34;build\u0026#34; api_location \u0026#34;api\u0026#34; app_settings [ \u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34; \u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34; ] } let deployment = arm { location Location.WestEurope add_resource myApp } deployment |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ myApp.RepositoryParameter, \u0026#34;Github personal access token goes here...\u0026#34; ] "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/storage-account/","title":"Storage Account","tags":[],"description":"","content":"Overview The Storage Account builder creates storage accounts and their associated containers.\n Storage Accounts (Microsoft.Storage/storageAccounts) Storage Containers (blobServices/containers) File Shares (fileServices/shares) Queues (Microsoft.Storage/storageAccounts/queueServices/queues) Tables (Microsoft.Storage/storageAccounts/tableServices/tables)  Builder Keywords    Keyword Purpose     name Specifies the name of the storage account   sku Sets the SKU of the storage account. A set of predefined SKU values are available as members in Storage.Sku, but you can create the full range of combinations of Kind and SKU as needed.   default_blob_access_tier Sets the default access tier for blob containers   add_public_container Adds a general-purpose public storage container   add_private_container Adds a general-purpose private storage container   add_blob_container Adds a general-purpose private blob container   add_file_share Adds a file share to storage account   add_file_share_with_quota Adds a file share to storage account with a share quota in Gb   add_queue Adds a queue to the storage account   add_queues Adds a list of queues to the storage account   add_table Adds a table to the storage account   add_tables Adds a list of tables to the storage account   add_cors_rules Adds a list of CORS rules to the different storage services   add_policies Adds a list of Policies to the different storage services   enable_versioning Enabled versioning for different storage services   restrict_to_ip Restrict access to a given ip address   restrict_to_subnet Restrict access to a given virtual network subnet   restrict_to_azure_services Restrict access to a given set of Azure Services. (Used when access to the storage account already controlled by private endpoint)   disable_public_network_access Disables public network access to the storage account   use_static_website Activates static website host, and uploads the provided local content as a post-deployment task to the storage with the specified index page   static_website_error_page Specifies the 404 page to display for static website hosting   enable_data_lake Enables Azure Data Lake Gen2 support on the storage account   add_lifecycle_policy Given a rule name, a list of PolicyActions and a list of string filters, creates a lifecycle policy for the storage account   grant_access Given a managed identity (can be either user- or system- assigned), and a specific RoleId from the Roles module, grants access to the identity for the provided role.   min_tls_version Sets the minimum TLS version for the storage account   disable_blob_public_access Disables public (anonymous) access to blobs for the entire storage account   disable_shared_key_access Disables shared key access for the storage account   default_to_oauth_authentication Defaults to OAuth (AAD) authentication for requests to blobs, queues and containers in the Azure portal   use_azure_dns_zone Change the DNS Endpoint type from Standard to AzureDnsZone    Configuration Members    Member Purpose     Key Returns an ARM expression to retrieve the storage account\u0026rsquo;s primary connection string. Useful for e.g. supplying the connection string to another resource e.g. KeyVault or an app setting in the App Service.   WebsitePrimaryEndpoint Returns an ARM Expression for the Primary endpoint for static website (if enabled).   WebsitePrimaryEndpointHost Returns an ARM Expression for the Host of the Primary endpoint for static website (if enabled). Use this for e.g. Azure CDN integration.    Helpers The StorageAccount type contains helper methods to quickly create ARM expressions for Storage Account connection strings.\nExample open Farmer open Farmer.Builders open Farmer.Storage let storage = storageAccount { name \u0026#34;isaacssuperstorage\u0026#34; sku Storage.Sku.Premium_LRS restrict_to_ip \u0026#34;11.22.33.44\u0026#34; restrict_to_ip \u0026#34;12.23.45.78\u0026#34; restrict_to_subnet \u0026#34;myvnet\u0026#34; \u0026#34;mysubnet\u0026#34; add_public_container \u0026#34;mypubliccontainer\u0026#34; add_private_container \u0026#34;myprivatecontainer\u0026#34; add_blob_container \u0026#34;myblobcontainer\u0026#34; add_file_share \u0026#34;share1\u0026#34; add_file_share_with_quota \u0026#34;share2\u0026#34; 1024\u0026lt;Gb\u0026gt; add_queue \u0026#34;myqueue\u0026#34; add_queue (storageQueue { name \u0026#34;queue1\u0026#34; metadata [ \u0026#34;environment\u0026#34;, \u0026#34;dev\u0026#34; \u0026#34;project\u0026#34;, \u0026#34;farmer\u0026#34; ] }) add_queues [ storageQueue { name \u0026#34;queue1\u0026#34; metadata [ \u0026#34;environment\u0026#34;, \u0026#34;dev\u0026#34; \u0026#34;project\u0026#34;, \u0026#34;farmer\u0026#34; ] } storageQueue { name \u0026#34;queue2\u0026#34; metadata [ \u0026#34;environment\u0026#34;, \u0026#34;test\u0026#34; \u0026#34;project\u0026#34;, \u0026#34;barnyard\u0026#34; ] } ] add_queues [ storageQueue { name \u0026#34;queue1\u0026#34; } storageQueue { name \u0026#34;queue\u0026#34; } ] [ \u0026#34;environment\u0026#34;, \u0026#34;dev\u0026#34; \u0026#34;project\u0026#34;, \u0026#34;farmer\u0026#34; ] add_table \u0026#34;mytable\u0026#34; use_static_website \u0026#34;local/path/to/folder/content\u0026#34; \u0026#34;index.html\u0026#34; static_website_error_page \u0026#34;error.html\u0026#34; enable_data_lake true add_lifecycle_rule \u0026#34;moveToCool\u0026#34; [ Storage.CoolAfter 30\u0026lt;Days\u0026gt;; Storage.ArchiveAfter 90\u0026lt;Days\u0026gt; ] Storage.NoRuleFilters add_lifecycle_rule \u0026#34;cleanup\u0026#34; [ Storage.DeleteAfter 7\u0026lt;Days\u0026gt; ] [ \u0026#34;data/recyclebin\u0026#34; ] grant_access myWebApp.SystemIdentity Roles.StorageBlobDataReader add_cors_rules [ StorageService.Blobs, CorsRule.AllowAll StorageService.Tables, CorsRule.create [ \u0026#34;https://compositional-it.com\u0026#34; ] StorageService.Files, { CorsRule.AllowAll with MaxAgeInSeconds = 10 } StorageService.Queues, CorsRule.create ([ \u0026#34;https://compositional-it.com\u0026#34; ], [ GET ]) ] add_policies [ StorageService.Blobs, [ Policy.Restore { Enabled = true; Days = 5 } Policy.DeleteRetention { Enabled = true; Days = 10 } Policy.LastAccessTimeTracking { Enabled = true; TrackingGranularityInDays = 12 } Policy.ContainerDeleteRetention { Enabled = true; Days = 11 } Policy.ChangeFeed { Enabled = true; RetentionInDays = 30 } ] ] enable_versioning [ StorageService.Blobs, true ] min_tls_version Tls12 } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/traffic-manager/","title":"Traffic Manager","tags":[],"description":"","content":"Overview The Traffic Manager builder (trafficManager) creates traffic manager profiles and their associated endpoints.\n Traffic Manager Profiles (Microsoft.Network/trafficManagerProfiles) Traffic Manager Azure Endpoints (Microsoft.Network/trafficManagerProfiles/azureEndpoints) Traffic Manager External Endpoints (Microsoft.Network/trafficManagerProfiles/externalEndpoints)  Builder Keywords    Builder Keyword Purpose     trafficManager name Sets the name of the Traffic Manager profile.   trafficManager dns_ttl Sets the DNS TTL of the Traffic Manager profile, in seconds (default 30).   trafficManager disable_profile Disables the Traffic Manager profile.   trafficManager enable_profile Enables the Traffic Manager profile.   trafficManager routing_method Sets the routing method of the Traffic Manager profile (default Performance).   trafficManager enable_traffic_view Enables the Traffic View of the Traffic Manager profile.   trafficManager disable_traffic_view Disables the Traffic View of the Traffic Manager profile.   trafficManager monitor_protocol Sets the monitoring protocol of the Traffic Manager profile (default Https).   trafficManager monitor_port Sets the monitoring port of the Traffic Manager profile (default 443).   trafficManager monitor_path Sets the monitoring path of the Traffic Manager profile (default /).   trafficManager monitor_interval Sets the monitoring interval, in seconds, of the Traffic Manager profile (default 30).   trafficManager monitor_timeout Sets the monitoring timeout, in seconds, of the Traffic Manager profile (default 10).   trafficManager monitor_tolerated_failures Sets the monitoring tolerated number of failures, of the Traffic Manager profile (default 3).   trafficManager add_endpoints Adds Endpoints to the Traffic Manager profile.   endpoint name Sets the name of the Endpoint.   endpoint weight Sets the weight of the Endpoint.   endpoint priority Sets the priority of the Endpoint.   endpoint enable_endpoint Enables the Endpoint.   endpoint disable_endpoint Disables the Endpoint.   endpoint target_webapp Sets the target of the Endpoint to a web app.   endpoint target_external Sets the target of the Endpoint to an external domain/IP and location.    Example open Farmer open Farmer.Builders open Farmer.TrafficManager let myTrafficManager = trafficManager { name \u0026#34;my-trafficmanager-profile\u0026#34; routing_method RoutingMethod.Performance add_endpoints [ endpoint { name \u0026#34;my-external-endpoint\u0026#34; weight 1 priority 1 target_external \u0026#34;mydomain.com\u0026#34; Location.WestUS } endpoint { name \u0026#34;my-web-app-endpoint\u0026#34; weight 1 priority 2 target_webapp (ResourceName \u0026#34;my-web-app\u0026#34;) } ] monitor_path \u0026#34;/\u0026#34; monitor_port 443 monitor_protocol Https monitor_interval 30\u0026lt;Seconds\u0026gt; monitor_timeout 5\u0026lt;Seconds\u0026gt; monitor_tolerated_failures 4 enable_traffic_view dns_ttl 30\u0026lt;Seconds\u0026gt; } arm { location Location.EastUS add_resource myTrafficManager } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/virtual-machine/","title":"Virtual Machine","tags":[],"description":"","content":"Overview The Virtual Machine builder creates a fully configured virtual machine and all its required child resources.\n Virtual Machines (Microsoft.Compute/virtualMachines) Virtual Networks (Microsoft.Network/virtualNetworks) IP Addresses (Microsoft.Network/publicIPAddresses) Network Interfaces (Microsoft.Network/networkInterfaces) Storage Accounts (Microsoft.Storage/storageAccounts)  In addition, every VM you create will add a SecureString parameter to the ARM template, whose name follows the pattern password-for-[virtual machine name].\nBuilder Keywords    Keyword Purpose     name Sets the name of the VM.   diagnostics_support Turns on diagnostics support using an automatically created storage account.   diagnostics_support_managed Turns on diagnostics support using an Azure-managed storage account.   diagnostics_support_external Turns on diagnostics support using an existing storage account.   vm_size Sets the size of the VM.   priority Sets the VM Priority. Only one spot_instance or priority setting is allowed per VM. No priority is set by default.   spot_instance Makes the VM a spot instance. Shorthand for priority (Spot (\u0026lt;EvictionPolicy\u0026gt;, \u0026lt;maxPrice\u0026gt;). Only one spot_instance or priority setting is allowed per VM.   username Sets the admin username of the VM (note: the password is supplied as a securestring parameter to the generated ARM template).   password_parameter Sets the name of the parameter which contains the admin password for this VM. defaults to \u0026ldquo;password-for-\u0026rdquo;   add_availability_zone Sets the availability zone for the VM.   operating_system Sets the operating system of the VM. A set of samples is provided in the CommonImages module.   os_disk Sets the size and type of the OS disk for the VM. Note: The default is non-SSD.   add_disk Adds a data disk to the VM with a specific size and type.   add_ssd_disk Adds a SSD data disk to the VM with a specific size.   add_slow_disk Adds a conventional (non-SSD) data disk to the VM with a specific size.   attach_os_disk Attaches an newly imported managed disk to the VM as the OS disk. The OS (Windows or Linux) for the image must be specified. When attaching an OS disk, the OS settings such as username, password, and configData cannot be set.   attach_existing_os_disk Attaches an existing managed disk to the VM as the OS disk.   attach_data_disk Attaches an newly imported managed disk to the VM as a data disk.   attach_existing_data_disk Attaches an existing managed disk to the VM as a data disk.   no_data_disk Excludes a data disk (only an OS disk) - common when mounting cloud storage.   domain_name_prefix Sets the prefix for the domain name of the VM.   address_prefix Sets the IP address prefix of the VM.   subnet_prefix Sets the subnet prefix of the VM.   custom_script Executes the supplied inline custom script on the VM. Supports only one command. Alternatively you can connect VM e.g. with Powershell Invoke-AzVMRunCommand.   custom_script_files Uploads the supplied set of files, specified by URI, to the VM on creation.   aad_ssh_login Adds the AADSSHLoginForLinux extension on Linux VM\u0026rsquo;s (requires system_identity).   custom_data Sets the custom data field for the VM.   disable_password_authentication Disables password authentication on the VM. Must include at least one key if true   add_authorized_key adds one authorized key   add_authorized_keys adds a list of authorized keys   add_identity Adds a managed identity to the Virtual Machine.   system_identity Activates the system identity of the Virtual Machine.   public_ip Specifies or removes the public IP for this VM   ip_allocation Sets the public IP as Dynamic or Static. Default is dynamic.   private_ip_allocation Sets the private IP as Dynamic or Static. Default is dynamic.   ip_forwarding Enable or disable IP forwarding on the primary network interface. Secondary NICs will leave it undefined.   accelerated_networking Enable or disable accelerated networking on all network interfaces generated for the VM.   add_ip_configuration Add ipConfig definitions to add additional IP addresses or connect to multiple subnets. Connecting to additional subnets will generate a NIC for each subnet.   network_security_group Sets the Network Security Group (NSG) for VM/NIC. Enables you to create and share firewall rule sets.   link_to_network_security_group Specify an existing Network Security Group (NSG) for VM/NIC.   link_to_vnet Attaches the VM NIC to a vnet that is deployed in this same template   link_to_unmanaged_vnet Attaches the VM NIC to a vnet that is already deployed   link_to_backend_address_pool Adds the VM network interface to a load balancer backend address pool that is deployed with this VM.   link_to_unmanaged_backend_address_pool Adds the VM network interface to an existing load balancer backend address pool.    Configuration Members    Member Purpose     NicName Provides the resource name of the Network Interface Card (NIC)   VnetName Provides the resource name of the Virtual Network (VNet)   SubnetName Provides the resource name of the subnet   IpName Provides the resource name of the IP Address   PublicIpAddress Returns an ARM expression to retrieve public IP address of the virtual machine.   Hostname Returns an ARM expression to retrieve the fully-qualified domain name from the virtual machine\u0026rsquo;s DNS settings.\u0026rdquo;    Example open Farmer open Farmer.Builders let myVm = vm { name \u0026#34;myFarmerVm\u0026#34; username \u0026#34;yourUsername\u0026#34; vm_size Vm.Standard_A2 operating_system Vm.WindowsServer_2012Datacenter os_disk 128 Vm.StandardSSD_LRS add_ssd_disk 128 add_slow_disk 512 custom_script \u0026#34;powershell setup-vm.ps1\u0026#34; // you have to actually *call* the script  custom_script_files [ \u0026#34;https://foo.bar/foo/setup-vm.ps1\u0026#34; ] custom_data \u0026#34;customData\u0026#34; disable_password_authentication true add_authorized_key \u0026#34;fooPath\u0026#34; \u0026#34;fooKey\u0026#34; add_authorized_keys [(\u0026#34;fooPath\u0026#34;, \u0026#34;fooKey\u0026#34;);(\u0026#34;fooPath1\u0026#34;, \u0026#34;fooKey1\u0026#34;)] private_ip_allocation (PrivateIpAddress.StaticPrivateIp (Net.IPAddress.Parse(\u0026#34;10.0.0.10\u0026#34;))) } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/virtual-hub/","title":"Virtual Hub","tags":[],"description":"","content":"Overview The Virtual WAN builder (vhub) is used to create Azure Virtual Hub instances.\n Virtual Hub (Microsoft.Network/virtualHubs)  Builder Keywords    Resource Keyword Purpose     vhub name Sets the name of the virtual hub   vhub sku Sets the sku of the virtual hub   vhub address_prefix Sets the address prefix of the virtual hub   vhub link_to_vwan Sets the virtual wan deployed by farmer to which the virtual hub belongs   vhub link_to_unmanaged_vwan Sets the existing virtual wan to which the virtual hub belongs    Example open Farmer open Farmer.Builders let vhub = vhub { name \u0026#34;my-vhub\u0026#34; address_prefix (IPAddressCidr.parse \u0026#34;10.0.0.0/24\u0026#34;) } let deployment = arm { location Location.NorthEurope add_resource vhub } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/vnet/","title":"Virtual Network","tags":[],"description":"","content":"Overview The virtual network builder is used to deploy virtual networks and their subnets.\n Virtual Network (Microsoft.Network/virtualNetworks) Subnets (Microsoft.Network/virtualNetworks/subnets)  The Virtual Network module contains four builders\n The vnet builder is used to create Azure Virtual Network instances. The subnet builder is used within the vnet builder to define subnets. The addressSpace builder can be used to automatically generate subnets based on the sizes of networks needed within the address space. The subnetSpec builder is used to define the automatically generated subnets, with the primary different from the subnet builder being that you define the size for the prefix, and not the address.  Builder Keywords Virtual Network: vnet    Keyword Purpose     name Sets the name of the virtual network.   add_address_spaces Adds address spaces to the virtual network.   add_subnets Adds subnets to the virtual network.   build_address_spaces Automatically builds address spaces for subnet names and sizes.   add_tags Adds a set of tags to the resource   add_tag Adds a tag to the resource   add_peer Adds VNet peering between this and another VNet (one/two-way)   add_peers Adds VNet peering between this and other VNets (one/two-way)    Subnet: subnet    Keyword Purpose     name Name of the subnet resource   prefix Subnet prefix in CIDR notation (e.g. 192.168.100.0/24)   nat_gateway Specify the NAT gateway for the subnet from the same deployment.   link_to_nat_gateway Specify an existing NAT gateway for the subnet.   network_security_group Specify the network security group from the same deployment.   link_to_network_security_group Specify an existing network security group for this subnet.   link_to_vnet Link a standalone subnet to a vnet in the same template.   link_to_unmanaged_vnet Link a standalone subnet to an existing vnet that is already deployed.   add_delegations Adds one or more delegations to this subnet.   add_service_endpoints Adds one or more service endpoints to this subnet.   associate_service_endpoint_policies Associates a subnet with an existing service policy.   allow_private_endpoints Enable or disable support for private endpoints, default is Disabled   private_link_service_network_policies Enable or disable support for private link service network polices, default is Disabled    Automatically build out an address space: addressSpace    Keyword Purpose     space When using build_address_space this specifies the address space.   subnets Specifies the subnets to build automatically.    Specify subnets in automatic address space: subnetSpec    Keyword Purpose     name Specifies the name of the subnet to build.   size Specifies the size of the subnet to build, default is /24.   nat_gateway Specify the NAT gateway for the subnet from the same deployment.   link_to_nat_gateway Specify an existing NAT gateway for the subnet.   network_security_group Specify the network security group from the same deployment.   link_to_network_security_group Specify an existing network security group for the subnet.   add_delegations Adds service delegations for the subnet.   add_service_endpoints Adds service endpoints for the subnet.   add_service_endpoint_policies Associates the service endpoint policies with the subnet.   allow_private_endpoints Enable or disable support for private endpoints, default is Disabled   private_link_service_network_policies Enable or disable support for private link service network polices, default is Disabled    Configuration Members    Member Purpose     SubnetIds Gets a map of subnet ResourceIds by subnet name    Example - Manual Subnets A virtual network is defined with the vnet builder. Address spaces and subnets should be added, taking care to ensure the subnets are contained within an address space on the virtual network.\nopen Farmer open Farmer.Builders let myVnet = vnet { name \u0026#34;my-vnet\u0026#34; add_address_spaces [ \u0026#34;192.168.200.0/22\u0026#34; ] add_subnets [ subnet { name \u0026#34;vms\u0026#34; prefix \u0026#34;192.168.200.0/24\u0026#34; } subnet { name \u0026#34;containers\u0026#34; prefix \u0026#34;192.168.201.0/24\u0026#34; add_delegations [ SubnetDelegationService.ContainerGroups ] add_service_endpoints [ EndpointServiceType.Storage, [Location.NorthEurope; Location.WestEurope] ] } subnet { name \u0026#34;databases\u0026#34; prefix \u0026#34;192.168.202.0/24\u0026#34; add_delegations [ SubnetDelegationService.SqlManagedInstances ] } ] } let deployment = arm { location Location.NorthEurope add_resource myVnet } Example - Automatically Build Subnets Address spaces and subnets can be built out automatically to ensure the subnets are contained within the address spaces. This reduces the need for \u0026ldquo;IP math\u0026rdquo; to determine the start addresses for contiguous networks of different sizes.\nopen Farmer open Farmer.Builders let myVnet = vnet { name \u0026#34;my-vnet\u0026#34; build_address_spaces [ addressSpace { space \u0026#34;10.28.0.0/16\u0026#34; subnets [ subnetSpec { name \u0026#34;vms\u0026#34; size 26 } subnetSpec { name \u0026#34;services\u0026#34; size 24 } subnetSpec { name \u0026#34;corporate-west\u0026#34; size 18 } subnetSpec { name \u0026#34;corporate-east\u0026#34; size 18 } subnetSpec { name \u0026#34;corporate-east\u0026#34; size 18 } subnetSpec { name \u0026#34;GatewaySubnet\u0026#34; size 28 } subnetSpec { name \u0026#34;containers\u0026#34; size 27 add_delegations [SubnetDelegationService.ContainerGroups] add_service_endpoints [ EndpointServiceType.Storage, [ Location.NorthEurope Location.WestEurope ] ] } ] } addressSpace { space \u0026#34;10.30.0.0/16\u0026#34; subnets [ subnetSpec { name \u0026#34;remote-office\u0026#34; size 23 } subnetSpec { name \u0026#34;applications\u0026#34; size 24 add_service_endpoints [ EndpointServiceType.Storage, [ Location.NorthEurope Location.WestEurope ] ] } subnetSpec { name \u0026#34;reserved\u0026#34; size 24 } subnetSpec { name \u0026#34;GatewaySubnet\u0026#34; size 28 } ] } ] } let deployment = arm { location Location.NorthEurope add_resource myVnet } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/virtual-wan/","title":"Virtual WAN","tags":[],"description":"","content":"Overview The Virtual WAN builder (vwan) is used to create Azure Virtual WAN instances.\n Virtual WAN (Microsoft.Network/virtualWans)  Builder Keywords    Resource Keyword Purpose     vwan name Sets the name of the virtual wan   vwan standard_vwan Sets the virtual wan type to \u0026ldquo;standard\u0026rdquo; instead of the default \u0026ldquo;basic\u0026rdquo;   vwan allow_branch_to_branch_traffic Specifies branch to branch traffic is allowed   vwan disable_vpn_encryption Specifies Vpn encryption is disabled   vwan office_365_local_breakout_category Sets the office local breakout category    Example open Farmer open Farmer.Builders let myVwan = vwan { name \u0026#34;my-vwan\u0026#34; disable_vpn_encryption allow_branch_to_branch_traffic office_365_local_breakout_category Office365LocalBreakoutCategory.None standard_vwan } let deployment = arm { location Location.NorthEurope add_resource myVwan } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/vnet-gateway/","title":"Virtual Network Gateway","tags":[],"description":"","content":"Overview The Virtual Network Gateway builder creates virtual network gateways for ExpressRoute or VPN connections to a virtual network.\n Virtual Network Gateways (Microsoft.Network/virtualNetworkGatways) Connections (Microsoft.Network/connections)  Builder Keywords    Applies To Keyword Purpose     Gateway name Specifies the name of the virtual network gateway   Gateway vnet The name of the virtual network to which the gateway connects   Gateway er_gateway_sku SKU for an ExpressRoute gateway   Gateway vpn_gateway_sku SKU for a VPN gateway   Gateway vpn_type Sets the VPN type to route-based (default) or policy-based.   Gateway gateway_ip_config Specifies the gateway public and private IP addresses   Gateway active_active_ip_config Specifies the second public and private IP configuration for a redundant gateway   Gateway disable_bgp BGP is enabled by default, but this can disable it   Gateway vpn_client Specifies the VPN client configuration using the vpnclient builder (optional)   VPNClient add_address_pool The reference of the address space resource which represents Address space for P2S VpnClient   VPNClient add_root_certificate Adds the name and the public data of a root certificate to validate client certificates used for VPN Client connexion. This can be either just the data of the base64 content of the certificate or a multiline string starting with \u0026mdash;\u0026ndash;BEGIN CERTIFICATE\u0026mdash;\u0026ndash; and ending with \u0026mdash;\u0026ndash;END CERTIFICATE\u0026mdash;\u0026ndash;   VPNClient add_revoked_certificate Adds the name and the thumbprint of a revoked client certificate   VPNClient protocols Sets the protocols for the VPN client. SSTP (default), IkeV2 or OpenVPN   Connection name Specifies the name of the connection   Connection vnet_gateway1 Name of the first vnet gateway this is connecting   Connection vnet_gateway2 Name of the second vnet gateway this is connecting, for use when connecting two vnets   Connection local_gateway Name of the local gateway connection for a VPN   Connection peer_id Id of the peer, typically an ExpressRoute circuit Id   Connection auth_key Authorization key used when peering across subscriptions    Example open Farmer open Farmer.Builders open Farmer.VirtualNetworkGateway let gw = gateway { name \u0026#34;er-gateway\u0026#34; vnet \u0026#34;my-vnet\u0026#34; // Must contain a subnet named \u0026#39;GatewaySubnet\u0026#39;  er_gateway_sku ErGatewaySku.Standard vpn_client (vpnclient { add_address_pool \u0026#34;10.31.0.0/16\u0026#34; add_root_certificate \u0026#34;rootcert\u0026#34; \u0026#34;\u0026#34; }) } let privateNet = vnet { name \u0026#34;my-vnet\u0026#34; add_address_spaces [ \u0026#34;10.30.0.0/16\u0026#34; ] add_subnets [ subnet { name \u0026#34;GatewaySubnet\u0026#34; prefix \u0026#34;10.30.254.0/28\u0026#34; } ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/disk/","title":"Disk","tags":[],"description":"","content":"Overview The disk builder creates managed disks that may be attached to a virtual machine. With managed disks, the storage account backing the disk is handled by Azure. Disks can be created as empty disks or by importing a virtual hard disk from an existing storage account.\n Disks (Microsoft.Compute/disks)  Builder Keywords    Keyword Purpose     name Sets the name of the managed disk.   sku Sets the type of disk, such as Standard_LRS, StandardSSD_LRS, Premium_LRS, or UltraSSD_LRS.   add_availability_zone When a disk will be attached to a VM in an availability zone, the same availability zone should be set here.   os_type Sets the OS for the managed disk - Windows or Linux.   create_empty Creates an empty disk of the given size.   import Imports a disk from an existing virtual hard drive (.vhd) file.    Example open Farmer open Farmer.Builders let emptyDisk = disk { name \u0026#34;empty-disk\u0026#34; os_type Linux create_empty 128\u0026lt;Gb\u0026gt; } let importedDisk = disk { name \u0026#34;imported-disk-image\u0026#34; sku Vm.DiskType.Premium_LRS os_type Linux // Provide the URI for the disk image and the ARM resource Id for the storage account.  import (System.Uri \u0026#34;https://mystorageaccount.blob.core.windows.net/vhds/MyVirtualHardDisk.vhd\u0026#34;) (Arm.Storage.storageAccounts.resourceId \u0026#34;mystorageaccount\u0026#34;) } Multiple disks can be created and then attached to a virtual machine:\nlet disk0 = disk { name \u0026#34;disk-0\u0026#34; sku Vm.DiskType.Premium_LRS os_type Linux create_empty 1024\u0026lt;Gb\u0026gt; add_availability_zone \u0026#34;1\u0026#34; } let disk1 = disk { name \u0026#34;disk-1\u0026#34; sku Vm.DiskType.Standard_LRS os_type Linux import (System.Uri \u0026#34;https://mystorageaccount.blob.core.windows.net/vhds/MyVirtualHardDisk.vhd\u0026#34;) (Arm.Storage.storageAccounts.resourceId \u0026#34;mystorageaccount\u0026#34;) add_availability_zone \u0026#34;1\u0026#34; } let vmWithAttachedDisks = vm { name \u0026#34;vm-with-attached-disks\u0026#34; vm_size Standard_B1ms operating_system UbuntuServer_2204LTS username \u0026#34;azureuser\u0026#34; add_availability_zone \u0026#34;1\u0026#34; attach_data_disk disk0 attach_data_disk disk1 } let deployment = arm { add_resources [ disk0 disk1 vmWithAttachedDisks ] } "},{"uri":"https://compositionalit.github.io/farmer/api-overview/resources/web-app/","title":"Web App","tags":[],"description":"","content":"Overview The Web App builder is used to create Azure App Service accounts. It abstracts the Service Plan into the same component, and will also create and configure a linked App Insights resource. If you wish to create a website that connects to an existing service plan or Web App, use the link_to_service_plan keyword and provide the resource name of the service plan or Web App to connect to.\n Web Site (Microsoft.Web/sites) Server Farms (Microsoft.Web/serverfarms) Source Controls (Microsoft.Web/sites/sourcecontrols) Application Insights (Microsoft.Insights/components)  Web App Builder Keywords    Applies To Keyword Purpose     Web App name Sets the name of the web app.   Web App link_to_service_plan Instructs Farmer to link this webapp to a Farmer service plan configuration defined elsewhere in your application, rather than creating a new one.   Web App link_to_unmanaged_service_plan Instructs Farmer to link this webapp to an existing service plan that is externally managed, rather than creating a new one.   Web App app_insights_name Sets the name of the automatically-created app insights instance.   Web App app_insights_off Removes any automatic app insights creation, configuration and settings for this webapp.   Web App link_to_app_insights Instructs Farmer to link this webapp to a Farmer App Insights configuration defined elsewhere in your application, rather than creating a new one.   Web App link_to_unmanaged_app_insights Instructs Farmer to link this webapp to an existing app insights instance that is externally managed, rather than creating a new one.   Web App run_from_package Sets the web app to use \u0026ldquo;run from package\u0026rdquo; deployment capabilities.   Web App website_node_default_version Sets the node version of the web app.   Web App setting Sets an app setting of the web app in the form \u0026ldquo;key\u0026rdquo; \u0026ldquo;value\u0026rdquo;.   Web App secret_setting Sets a \u0026ldquo;secret\u0026rdquo; app setting of the web app. You must supply the \u0026ldquo;key\u0026rdquo;, whilst the value will be supplied as a secure parameter.   Web App settings Sets a list of app setting of the web app as tuples in the form of (\u0026ldquo;key\u0026rdquo;, \u0026ldquo;value\u0026rdquo;).   Web App connection_string Creates a connection string whose value is supplied as secret parameter, or as an ARM expression in the tupled form of (\u0026ldquo;key\u0026rdquo;, expr), or with the connection string type (\u0026ldquo;key\u0026rdquo;, expr, SQLAzure).   Web App connection_strings Creates a set of connection strings of the web app whose values will be supplied as secret parameters.   Web App ftp_state Allows to enable or disable FTP and FTPS.   Web App https_only Disables http for this webapp so that only HTTPS is used.   Web App enable_http2 Configures the webapp to allow clients to connect over http2.0.   Web App disable_client_affinity Stops the webapp from sending client affinity cookies.   Web App enable_websockets Configures the webapp to allow clients to connect via websockets.   Web App depends_on Sets dependencies for the web app.   Web App docker_image Sets the docker image to be pulled down from Docker Hub, and the command to execute as a second argument. Automatically sets the OS to Linux.   Web App docker_ci Turns on continuous integration of the web app from the Docker source repository using a webhook.   Web App docker_use_azure_registry Uses the supplied Azure Container Registry name as the source of the Docker image, instead of Docker Hub. You do not need to specify the full url, but just the name of the registry itself.   Web App add_identity Adds a managed identity to the the Web App. Farmer will automatically set the AZURE_CLIENT_ID application setting to the Client Id of the supplied identity.   Web App keyvault_identity Adds a managed identity to the the Web App and sets this identity to be used for KeyVault References. Farmer will automatically set the AZURE_CLIENT_ID application setting to the Client Id of the supplied identity.   Web App system_identity Activates the system identity of the Web App.   Web App enable_cors Enables CORS support for the app. Either specify WebApp.AllOrigins or a list of valid URIs as strings.   Web App enable_cors_credentials Allows CORS requests with credentials.   Web App source_control Given a github repository URI and branch name, configures the web app to automatically deploy those files to the web app   Web App disable_source_control_ci Disables continuous integration from source control on push   Web App enable_source_control_ci Enables continuous integration from source control on push   Web App add_extension Adds the named extension to the Web App   Web App automatic_logging_extension Enables or disables automatically adding the ASP .NET logging extension for netcore apps (defaults to on unless docker_image is set).   Web App worker_process Specifies whether to set the web app to 32 or 64 Bitness.   Web App always_on Sets the \u0026ldquo;Always On\u0026rdquo; flag.   Web App add_private_endpoint Adds a private endpoint for this Webapp to a given subnet   Web App add_private_endpoints Adds private endpoints for this Webapp to the given subnets   Web App add_slot Adds a deployment slot to the app   Web App add_slots Adds multiple deployment slots to the app   Web App health_check_path Sets the path to your functions health check endpoint, which Azure load balancers will ping to determine which instances are healthy.   Web App custom_domain Adds a custom domain to the app. By default this will produce an AppService-managed SSL certificate for your domain as well. Through the overloads of this operator, you can provide a custom certificate thumbprint or choose not to use SSL. You can use this operator multiple times to add multiple custom domains.   Web App add_allowed_ip_restriction Adds an \u0026lsquo;allow\u0026rsquo; rule for an ip   Web App add_denied_ip_restriction Adds an \u0026lsquo;deny\u0026rsquo; rule for an ip   Web App docker_port Adds WEBSITES_PORT setting to map custom docker port to app service port 80   Web App link_to_vnet Enable the VNET integration feature in azure where all outbound traffic from the web app with be sent via the specified subnet. Use this operator when the given VNET is in the same deployment   Web App link_to_unmanaged_vnet Enable the VNET integration feature in azure where all outbound traffic from the web app with be sent via the specified subnet. Use this operator when the given VNET is not in the same deployment   Web App add_virtual_applications Adds list of virtualApplication definitions to the webapp   Web App startup_command Adds a startup command to be run post-deployment. This is useful on Linux-based web app deployments, where your application is \u0026ldquo;implicitly\u0026rdquo; converted into a docker image and may need to be told what to do on startup.   App Slot name Sets the name for the slot   App Slot add_identity Sets the user managed identity for the slot.   App Slot system_identity Sets the system identity to be enabled for the slot.   App Slot keyvault_identity Sets the identity for accessing key vault.   App Slot setting Set an arbitrary setting for the slot.   App Slot settings Sets multiple settings for the slot.   App Slot connection_string Adds a connection string setting for the slot   App Slot docker_image Sets the docker image to be pulled down from Docker Hub, and the command to execute as a second argument. This enabled a new container to be staged in a slot.   App Slot add_allowed_ip_restriction Allows access from this IP when the slot is in production.   App Slot add_denied_ip_restriction Denies access from this IP when the slot is in production.   Service Plan service_plan_name Sets the name of the service plan. If not set, uses the name of the web app postfixed with \u0026ldquo;-plan\u0026rdquo;.   Service Plan runtime_stack Sets the runtime stack.   Service Plan operating_system Sets the operating system. If Linux, App Insights configuration settings will be omitted as they are not supported by Azure App Service.   Service Plan sku Sets the sku of the service plan.   Service Plan worker_size Sets the size of the service plan worker.   Service Plan number_of_workers Sets the number of instances on the service plan.   Service Plan zone_redundant Enables ZoneRedundant on the service plan.     Farmer also comes with a dedicated Service Plan builder that contains all of the above keywords that apply to a Service Plan.\nUse this builder if you wish to have an explicit and clear separation between your web app and service plan. Otherwise, it is recommended to use the service plan keywords that exist directly in the web app builder, and let Farmer handle the connections between them.\n Post-deployment Builder Keywords The Web App builder contains special commands that are executed after the ARM deployment is completed.\n   Keyword Purpose     zip_deploy Supplying a folder or zip file will instruct Farmer to upload the contents directly to the App Service once the ARM deployment is complete.   zip_deploy_slot Supplying a folder or zip file will instruct Farmer to upload the contents directly to the named slot of the App Service once the ARM deployment is complete.    Configuration Members    Member Purpose     PublishingPassword Gets the ARM expression path to the publishing password of this web app.   ServicePlan Gets the Resource Name of the service plan for this web app.   AppInsights Gets the Resource Name of the service plan for the AI resource linked to this web app.   SystemIdentity Gets the system-created managed principal for the web app. It must have been enabled using the system_identity keyword.    Key Vault integration The Web App builder comes with special integration into KeyVault. By activating KeyVault integration, the web app builder can automatically link to, or even create, a full KeyVault instance. All Secret or ARM Expression-based Settings (e.g. a setting that links to the Key of a Storage Account) will automatically be redirected to KeyVault. The value will be stored in KeyVault and the system identity will be activated and provided into the KeyVault with GET permissions. Lastly, Web App app settings will remain in place, using the Azure App Service built-in KeyVault redirection capabilities.\nThe following keywords exist on the web app:\n   Member Purpose     use_keyvault Tells the web app to create a brand new KeyVault for this App Service\u0026rsquo;s secrets.   link_to_keyvault Tells the web app to use an existing Farmer-managed KeyVault which you have defined elsewhere. All secret settings will automatically be mapped into KeyVault.   link_to_unmanaged_keyvault Tells the web app to use an existing non-Farmer managed KeyVault which you have defined elsewhere. All secret settings will automatically be mapped into KeyVault.    Virtual Applications virtualApplication Virtual applications can be defined for a webapp which allows you to specify alternative directories for the application executables or enable a single web app to host multiple applications at once. By default, the following virtualApplication is provided for you:\nvirtualApplication { virtual_path \u0026#34;/\u0026#34; physical_path \u0026#34;wwwroot\u0026#34; }    Keyword Purpose     virtual_path Provides the virtual path mapping   physical_path Specifies the physical directory used (relative to the \u0026ldquo;site\u0026rdquo; directory)   preloaded Enables the \u0026ldquo;preload\u0026rdquo; feature of the virtual application    Examples A basic web application.\nopen Farmer open Farmer.Builders open Farmer.WebApp let myWebApp = webApp { name \u0026#34;myWebApp\u0026#34; service_plan_name \u0026#34;myServicePlan\u0026#34; setting \u0026#34;myKey\u0026#34; \u0026#34;aValue\u0026#34; sku WebApp.Sku.B1 always_on app_insights_off worker_size Medium number_of_workers 3 run_from_package system_identity } Using a managed Key Vault instance with automatic secret mapping.\nopen Farmer open Farmer.Builders // Create a basic storage account let data = storageAccount { name \u0026#34;mystorage\u0026#34; } // Create a web application with a sensitive setting of storage key and an explicit \u0026#34;secret\u0026#34; setting // which will be passed through by ARM parameter. let wa = webApp { name \u0026#34;isaac\u0026#34; setting \u0026#34;key\u0026#34; \u0026#34;value\u0026#34; setting \u0026#34;storagekey\u0026#34; data.Key link_to_keyvault (ResourceName \u0026#34;isaacvault\u0026#34;) } // Create a key vault instance and explicitly grant the web application access to it. let v = keyVault { name \u0026#34;isaacvault\u0026#34; add_access_policy (AccessPolicy.create (wa.SystemIdentity.PrincipalId, [ KeyVault.Secret.Get; KeyVault.Secret.List ])) } Serving two applications simultaneously (a frontend and a backend) from one web app using virtual applications.\nopen Farmer open Farmer.Builders let wa = webApp { name \u0026#34;my-site-with-api\u0026#34; always_on add_virtual_applications [ virtualApplication { virtual_path \u0026#34;/\u0026#34; physical_path \u0026#34;frontend\u0026#34; } virtualApplication { virtual_path \u0026#34;/api\u0026#34; physical_path \u0026#34;backend\u0026#34; preloaded } ] } "},{"uri":"https://compositionalit.github.io/farmer/tutorials/custom-output/","title":"Custom Output with ARM Expressions","tags":[],"description":"","content":"Introduction Many resources have properties that are only set once the resource is created, such as a public IP\u0026rsquo;s address or an ExpressRoute\u0026rsquo;s circuit service key. It is often helpful to have these as output from the deployment so they are available to any downstream automation tasks.\nIn this tutorial, you will deploy an ExpressRoute circuit, create a reference to the serviceKey property on the newly deployed circuit, and provide that as the ARM deployment output.\nDefine the ExpressRoute circuit to deploy An ExpressRoute circuit provides direct connectivity into Azure over a telecommunication provider\u0026rsquo;s network rather than traversing the Internet or a VPN. Once the circuit is created, the typical flow is to take the circuit\u0026rsquo;s service key to the telecommunications provider so they can enable it for your business connecivity.\nopen Farmer open Farmer.Builders let er = expressRoute { name \u0026#34;my-test-circuit\u0026#34; service_provider \u0026#34;Equinix\u0026#34; peering_location \u0026#34;Frankfurt\u0026#34; } Reference the serviceKey Property ARM templates support expressions that are evaluated when the template is executed by ARM. These have many different capabilities, but in this case, we want to reference a newly deployed resource - the ExpressRoute circuit.\nFirst, you can use the type and name of the resource to create a ResourceId. Then, that ResourceId can be used to build a reference expression and retrieve a property of the resource.\n// Build an ARM resourceId type for the circuit. let erId = ResourceId.create(Arm.Network.expressRouteCircuits, er.Name) // Use that ID to build a reference expression and get a property of the referenced resource. let serviceKeyRef = ArmExpression.create ($\u0026#34;reference({erId.ArmExpression.Value}).serviceKey\u0026#34;) Adding the Deployment Output One or more outputs can be added to an arm computation expression to generate outputs from the deployment. An output is created using the name for the output an an ArmExpression, such as serviceKeyRef created above.\narm { location Location.WestEurope add_resource er output \u0026#34;er-service-key\u0026#34; serviceKeyRef } |\u0026gt; Writer.quickWrite \u0026#34;custom-output\u0026#34; This results in a template with an output named \u0026ldquo;er-service-key\u0026rdquo; that will contain the value of the serviceKey property on the newly deployed ExpressRoute circuit.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/keyvault-certs/","title":"Declarative Steps in an ARM Deployment","tags":[],"description":"","content":"Introduction An ARM deployment typically represents the infrastructure you want deployed as a result of it, referred to as the \u0026ldquo;goal state\u0026rdquo;. For instance, you may want to have a web application with a database, so you\u0026rsquo;ll define your goal state that includes database and web application resources. However, it\u0026rsquo;s not always that simple - there are various reasons that some of the steps of a deployment cannot be represented by the goal state resource model.\n Creating a backup of a database before a deployment. Interacting with API\u0026rsquo;s that aren\u0026rsquo;t represented in ARM itself (Kubernetes control plane, networking devices, or the API\u0026rsquo;s of the application you\u0026rsquo;re deploying). Performing ARM operations such as creating a certificate.  In any of these scenarios, there is some imperative logic that needs to be included in the ARM deployment. To keep the ARM deployment itself repeatable, it\u0026rsquo;s often best to ensure this imperative logic is idempotent - that is, it can run repeatedly without incurring side effects.\nIn this tutorial, we will handle the third case, running an ARM operation to create a certificate in a key vault. We\u0026rsquo;ll create a deploymentScript resource for this, which creates a temporary ARM resource for the purposes of executing this imperative logic.\n Create a user assigned identity. Create a storage account for making the certificate available to the web app. Create a key vault for generating the certificate. Run an imperative script to create a certificate in the key vault and copy it to the storage account. Create a web application in a container group that attaches to the storage account to uses the certificate.    Full code available here\n  Create a user assigned identity A deployment script runs in a temporary container group and needs an identity, as does the container group. This identity will be a contributor over the resources in the resource group where this deployment runs so that it has permissions to upload the certificate to the storage account.\nlet appIdentity = userAssignedIdentity { name \u0026#34;my-app-user\u0026#34; } Create the Certificate Storage Account Depending on the type of compute resource used, you may be able to retrieve the certificate directly from the key vault on startup. However, for a container group, a good solution is to have a file share on a storage account. After creating the certificate, we will download it from the key vault and upload it to this storage account file share to make it available to the container group.\nlet certStorage = storageAccount { name \u0026#34;myappcertstorage123\u0026#34; sku Storage.Sku.Standard_LRS add_file_share \u0026#34;certs\u0026#34; } Create the Key Vault We need to create a key vault to generate the certificate. When a certificate is created in a key vault, the public key is stored as a certificate and the full certificate with private and public key is stored as a secret of the same name. To enable this access, we will need to define an accessPolicy on the key vault that allows our appIdentity to create and retrieve certificates and secrets.\nlet kv = keyVault { name \u0026#34;myappcertificates\u0026#34; add_access_policies [ accessPolicy { object_id appIdentity.PrincipalId secret_permissions [ KeyVault.Secret.Set; KeyVault.Secret.Get ] certificate_permissions [ KeyVault.Certificate.Create; KeyVault.Certificate.Get ] } ] } The Imperative Part: Creating the Certificate Creating a certificate is an imperative operation because this is a multiple step process where a key pair is created, then a certificate signing request is created from the key pair and signed by a certificate authority. Certificates can also be \u0026ldquo;self-signed\u0026rdquo;, meaning they have no certificate authority and must be individually trusted. This whole process means you cannot simply repeat it without side effects, so it is represented in ARM as an operation rather than a resource.\nCreating a certificate in an Azure key vault requires that you provide a policy for the certificate which defines the various settings such as the key size, issuer, and subject name (what identifies the host when presenting the certificate).\nYou can use the default policy directly, but this doesn\u0026rsquo;t let you set the subject name, so instead, we will build our own policy. To get a reference on what a valid policy contains, use the following Azure CLI command to \u0026ldquo;scaffold\u0026rdquo; a policy:\naz keyvault certificate get-default-policy --scaffold\nWe want a policy.json that roughly matches this, with a few adjustments for our scenario. F# anonymous records are very handy for creating JSON directly, so we\u0026rsquo;ll use one here to create a policy JSON string similar to the scaffold. Because we need to embed this in our ARM template so it can run in the deployment script, we\u0026rsquo;ll convert it to base64 and avoid any issues with trying to embed JSON in another JSON file.\nlet policy = {| keyProperties = {| exportable = true keyType = \u0026#34;RSA\u0026#34; keySize = 2048 reuseKey = false |} secretProperties = {| contentType = \u0026#34;application/x-pkcs12\u0026#34; |} x509CertificateProperties = {| subject = \u0026#34;CN=my-web-app.eastus.azurecontainer.io\u0026#34; subjectAlternativeNames = {| dnsNames = [ \u0026#34;my-web-app.eastus.azurecontainer.io\u0026#34; ] |} |} issuerParameters = {| name = \u0026#34;Self\u0026#34; |} |} let policyJsonB64 = policy |\u0026gt; System.Text.Json.JsonSerializer.Serialize // serialize to JSON  |\u0026gt; System.Text.Encoding.UTF8.GetBytes // and then encode it for easy embedding  |\u0026gt; System.Convert.ToBase64String Now for the deployment script itself. This will run the Azure CLI within a temporary container. It needs to perform the following steps:\n Take the embedded base64 policy.json string and write it to the file system where the deployment script runs. Create a certificate, using that policy.json file. Download the secret containing the public and private key pair in a .pfx file. Upload the .pfx file to the storage account file share to make it available to the container group.  The string interpolation in F# 5.0 is very handy for embedding F# values in the bash script statements.\nlet script = [ \u0026#34;set -e\u0026#34; // Write the encoded policy to a file in the deployment script resource.  $\u0026#34;echo {policyJsonB64} | base64 -d \u0026gt; policy.json\u0026#34; // Run imperative az CLI commands to create the certificate.  $\u0026#34;az keyvault certificate create --vault-name {kv.Name.Value} -n my-app-cert -p @policy.json\u0026#34; // Download the cert  $\u0026#34;az keyvault certificate download --file cert.pem --vault-name {kv.Name.Value} -n my-app-cert\u0026#34; // Download the pfx with cert and private key  $\u0026#34;az keyvault secret show --vault-name {kv.Name.Value} -n my-app-cert | jq .value -r | base64 -d \u0026gt; key.pfx\u0026#34; // Upload to storage file  $\u0026#34;az storage file upload --account-name {certStorage.Name.ResourceName.Value} --share-name certs --source key.pfx\u0026#34; ] |\u0026gt; String.concat \u0026#34;;\\n\u0026#34; With the hard part out of the way, we can define the deploymentScript resource, which is a temporary ARM resource that represents running these imperative steps. Because we don\u0026rsquo;t want this to run until the key vault and storage account are available, we need to use depends_on and reference these two resources. Also, notice this uses the appIdentity that was granted access to the key vault secrets and certificates.\ndeploymentScript { name \u0026#34;create-certificate\u0026#34; identity appIdentity depends_on kv depends_on certStorage force_update cleanup_on_success retention_interval 1\u0026lt;Hours\u0026gt; script_content script } Creating the Web Application Our web application will be a simple \u0026ldquo;hello world\u0026rdquo; service, as the interesting part is that it listens on HTTPS. Doing this requires the key pair be loaded by the service when it creates the binding to an HTTPS port. Here is the script content. Notice we need to add the certificate to the X509Store. This avoids some SSL warnings within the service itself due to using a self-signed certificate. If you are using a trusted third party CA, this may not be necessary.\n#r \u0026#34;nuget: Suave, Version=2.6.0\u0026#34; open Suave open System.Security.Cryptography.X509Certificates let certWithKey = new X509Certificate2(\u0026#34;/certs/key.pfx\u0026#34;, \u0026#34;\u0026#34;) let store = new X509Store(StoreName.Root, StoreLocation.CurrentUser) store.Open(OpenFlags.ReadWrite) store.Add(certWithKey) store.Close() let config = { defaultConfig with bindings = [ HttpBinding.createSimple (HTTPS certWithKey) \u0026#34;0.0.0.0\u0026#34; 443 ] } startWebServer config (Successful.OK \u0026#34;Hello Secure Farmers!\u0026#34;) We will read this short script into a string that we can pass to our container group. In real life, you probably have a full application published in a container image, but for illustrative purposes, we are just embedding the script.\nlet webAppMain = System.IO.File.ReadAllText \u0026#34;keyvault-certs-app.fsx\u0026#34; Now we create the container group. It uses a .NET 5.0 SDK image to run the script and has two volume mounts. One is for the embedded script itself, and the other is for the volume mount from the Azure storage account file share where the certificate itself is stored.\nlet webApp = containerGroup { name \u0026#34;my-web-app\u0026#34; add_identity appIdentity add_instances [ containerInstance { name \u0026#34;fsi\u0026#34; image \u0026#34;mcr.microsoft.com/dotnet/sdk:5.0\u0026#34; command_line (\u0026#34;dotnet fsi /src/main.fsx\u0026#34;.Split null |\u0026gt; List.ofArray) add_volume_mount \u0026#34;script-source\u0026#34; \u0026#34;/src\u0026#34; add_volume_mount \u0026#34;cert-volume\u0026#34; \u0026#34;/certs\u0026#34; add_public_ports [ 443us ] cpu_cores 0.2 memory 0.5\u0026lt;Gb\u0026gt; } ] public_dns \u0026#34;my-web-app\u0026#34; [ TCP, 443us ] add_volumes [ volume_mount.secret_string \u0026#34;script-source\u0026#34; \u0026#34;main.fsx\u0026#34; webAppMain volume_mount.azureFile \u0026#34;cert-volume\u0026#34; \u0026#34;certs\u0026#34; certStorage.Name.ResourceName.Value ] } The ARM Template With all of these resources, we can create an ARM template. It contains four declarative resources: the user assigned identity, a key vault, a storage account, and a container group. It also contains a deployment script resource for the imperative logic.\narm { location Location.EastUS add_resources [ appIdentity kv certStorage createCertificate webApp ] } |\u0026gt; Writer.quickWrite \u0026#34;keyvault-certs\u0026#34; Deploying the resulting template through ARM will result in ARM attempting to reach the goal state with as much concurrency as dependencies allow. It will deploy the user assigned identity first, then both the key vault and the storage account at the same time, and then finally it will run the deployment script and deploy the container group.\nThe end result is a container group running an HTTPS service using a certificate that was created in the newly provisioned key vault.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/minecraft-server-aci/","title":"Create your own Minecraft Server","tags":[],"description":"","content":"Introduction In this tutorial, you\u0026rsquo;ll use dotnet framework features and F# language techniques when building a template to create a fully functional Minecraft Server running on an Azure Container Instance with its world data stored in an Azure Storage Account. Because Farmer is a domain specific language embedded within F#, you are able to utilize the rich dotnet ecosystem and a static type system to \u0026ldquo;craft\u0026rdquo; an advanced deployment.\n Programmatically build our Minecraft configuration files. Create a storage account for the world data. Define a deployment script that will download the Minecraft Server .jar file and upload it to the storage account, along with the configuration files. Create a container group for running the service;.  A few dependencies We will need a few dependencies here, so first let\u0026rsquo;s reference the packages and open the namespaces:\n Farmer - for building that Azure resources and deployment template. MinecraftConfig - for building the server configuration files. FSharp.Data - for scraping the server download page for the current version of the server .jar file.  #r \u0026#34;nuget: Farmer\u0026#34; #r \u0026#34;nuget: MinecraftConfig\u0026#34; #r \u0026#34;nuget: FSharp.Data\u0026#34; open System open Farmer open Farmer.Builders open FSharp.Data open MinecraftConfig Building the Minecraft server configuration files Deploying infrastructure often also means building configuration files, and Minecraft is no different. There are four critical files for a server:\n ops.json - this includes the list of operators that can manage the server. whitelist.json - this includes a list of gamers who are allowed to use the server. eula.txt - this indicates that you\u0026rsquo;ve accepted the End User License Agreement for running a Minecraft Server, and you should read this since downloading and using the game implies you agree with it. server.properties - the server is a Java application, and this is the configuration for the application itself.  First we build a list of users that we will allow on our server. We\u0026rsquo;ll use this list to build both the ops.json (operators) and whitelist.json (allowed gamers), so we will indicate which ones are operators.\nlet operator = true /// Our list of minecraft users - their username, uuid, and whether or not they are an operator. let minecrafters = [ \u0026#34;McUser1\u0026#34;, \u0026#34;a6a66bfb-6ff7-46e3-981e-518e6a3f0e71\u0026#34;, operator \u0026#34;McUser2\u0026#34;, \u0026#34;d3f2e456-d6a4-47ac-a7f0-41a4dc8ed156\u0026#34;, not operator \u0026#34;McUser3\u0026#34;, \u0026#34;ceb50330-681a-4d9d-8e84-f76133d0fd28\u0026#34;, not operator ] Now we build the whitelist.json and ops.json files - the MinecraftConfig application handles formatting the configuration file, we just need to map from our list of minecrafters to the lists of the records for the whitelist and the operator. whitelist holds the contents of our whitelist.json file, and ops hosts the contents of the ops.json file. We will write use those later.\n/// Let\u0026#39;s allow our list of minecrafters on the whitelist. let whitelist = minecrafters |\u0026gt; List.map (fun (name, uuid, _) -\u0026gt; { Name=name; Uuid=uuid }) |\u0026gt; Whitelist.format /// Filter the minecrafters that aren\u0026#39;t operators. let ops = minecrafters |\u0026gt; List.filter (fun (_, _, op) -\u0026gt; op) // Filter anyone that isn\u0026#39;t an operator  |\u0026gt; List.map (fun (name, uuid, _) -\u0026gt; { Name=name; Level=OperatorLevel.Level4; Uuid=uuid }) |\u0026gt; Ops.format And we can generate an accepted EULA, storing this content in eula.\n/// And accept the EULA. let eula = Eula.format true Now we need a few properties that are used both for the server.properties and for the resulting infrastructure. The worldName tells Minecraft where to store the world data. Since this will be mounted to an Azure Storage File share, we create a binding for it to make sure the name we use in the server.properties file matches what we use in the storage account.\nSame for the serverPort, which is both used in the server.properties file and must be exposed publicly on the Azure Container Group.\nThe name of the storage account is used in three places: the storage account itself, in the deployment script that will upload files to the storage account, and in the container group that will mount a volume from it. The storageAccountName can be referenced in all three uses.\n/// Add bindings for fields that are referenced in a few places /// Name of the share for the world. let worldName = \u0026#34;world1\u0026#34; /// Port for this world let serverPort = 25565 /// Storage account name let storageAccountName = \u0026#34;mcworlddata\u0026#34; And now we create the server.properties file, storing it in serverProperties. With that, we completed generating all of the configuration files for the server and can move on to defining and deploying the infrastructure.\n/// Write the customized server properties. let serverProperties = [ ServerPort serverPort RconPort (serverPort + 10) EnforceWhitelist true WhiteList true Motd \u0026#34;Azure Minecraft Server\u0026#34; LevelName worldName Gamemode \u0026#34;survival\u0026#34; ] |\u0026gt; ServerProperties.format Creating the Storage Account A Minecraft server stores some data for the world that is generated and people play in. That data, along with the configuration files, is stored in a directory that must be accessible to the server. Azure Container Groups are able to attach an Azure Storage Account File share as a volume, so we will create a storage account with a file share.\n/// A storage account, with a file share for the server config and world data. let serverStorage = storageAccount { name storageAccountName sku Storage.Sku.Standard_LRS add_file_share_with_quota worldName 5\u0026lt;Gb\u0026gt; } Defining the Deployment Script There are some deployment orchestration tasks that cannot be fully represented by Azure resources, but we need ARM to carry them out for us. We can use deploymentScripts as an Azure resource to represent script execution. This allows us to specify orchestration properties, such as that ARM should execute this deployment script after the storage account is deployed.\nThe script itself runs in a temporary container that has the Azure CLI ready and authenticated with a user that has the \u0026ldquo;Contributor\u0026rdquo; role over everything in this deployment. This is helpful because it means our script runs as a user that can access the storage account to upload content.\nWe need this deployment script to do three things:\n Copy the configuration files to the storage account. Download the current server.jar to the script container\u0026rsquo;s temporary storage. Upload the server.jar to the storage account.  Embedding Configuration Files First we will tackle the configuration files. We are going use F# to generate the CLI script, so we can actually embed these in the deployment script itself. To avoid any trouble with escaping characters for our script, we will encode all of the configuration files as base64 strings when we build the script and then the script will decode the base64 data and write files out to the container file system where the Azure CLI can upload them.\n Convert each configuration file to base64. Embed in shell script run by deployment. When the deployment script runs, it will decode and save as files. And then it will use az storage file upload to transfer them to the storage account.  /// A deployment script to create the config in the file share. let deployConfig = // Helper function to base64 encode the files for embedding them in the  // deployment script.  let b64 (s:string) = s |\u0026gt; System.Text.Encoding.UTF8.GetBytes |\u0026gt; Convert.ToBase64String // Build a script that embeds the content of these files, writes to the  // deploymentScript instance and then copies  // to the storageAccount file share. We will include the contents of these  // files as base64 encoded strings so there is no need to worry about  // special characters in the embedded script.  let uploadConfig = [ whitelist, Whitelist.Filename ops, Ops.Filename eula, Eula.Filename serverProperties, ServerProperties.Filename ] |\u0026gt; List.map (fun (content, filename) -\u0026gt; $\u0026#34;echo {b64 content} | base64 -d \u0026gt; {filename} \u0026amp;\u0026amp; az storage file upload --account-name {storageAccountName} --share-name {worldName} --source {filename}\u0026#34;) That seemed a bit complicated, but using the best of both F# and the Azure CLI, the actual code to do this is minimal. The b64 function converts any string you give it to bytes and then base64 encodes those bytes into a string we can embed in the script.\nNext we have a list that contains the contents of each configuration file paired with the filename we need to write. We map each of those items to an interpolated string, which is where F# can execute little bits of code when building the string. Within the interpolated string, we call the b64 function to encode the contents of each file, which is what $\u0026quot;echo {b64 content}\u0026quot; does. When the script executes, it will pass that string into base64 -d which decides the base64 back into bytes that are written to a file. After each file is written, it\u0026rsquo;s uploaded with az storage file upload which again uses interpolated string values to get the storageAccountName, worldName, and filename values.\nDeploying the Server Software Having embedded the configuration files, now we need to add a line to the script to download the Minecraft server.jar and upload it as well. Whenever a new Minecraft Server is released, they update this page with a link that is named for the server version.\nWithout F#, we would probably stop here and just use the link for whatever version is out today. But F# has nice toys for reading and exploring data, like FSharp.Data which can parse HTML files, so we\u0026rsquo;re only a few lines away from scraping the download page for the link to the current version.\nWhen this F# code is executed to build the ARM template, it will load the Download page, find the link starting with minecraft_server, and copy the URL from the href on that link. We will embed that URL into our deployment script as a parameter to a curl call which will download the file before calling az storage file upload to copy the file to the storage account.\n/// The script will also need to download the server.jar and upload it.  let uploadServerJar = let results = HtmlDocument.Load \u0026#34;https://www.minecraft.net/en-us/download/server\u0026#34; // Scrape for anchor tags from this download page.  results.Descendants [\u0026#34;a\u0026#34;] // where the inner text contains \u0026#34;minecraft_server\u0026#34; since that\u0026#39;s what is  // displayed on that link  |\u0026gt; Seq.filter (fun (x:HtmlNode) -\u0026gt; x.InnerText().StartsWith \u0026#34;minecraft_server\u0026#34;) // And choose the \u0026#34;href\u0026#34; attribute if present  |\u0026gt; Seq.choose(fun (x:HtmlNode) -\u0026gt; x.TryGetAttribute(\u0026#34;href\u0026#34;) |\u0026gt; Option.map(fun (a:HtmlAttribute) -\u0026gt; a.Value())) |\u0026gt; Seq.head // If it wasn\u0026#39;t found, we\u0026#39;ll get an error here.  |\u0026gt; (fun url -\u0026gt; $\u0026#34;curl -O {url} \u0026amp;\u0026amp; az storage file upload --account-name {storageAccountName} --share-name {worldName} --source server.jar\u0026#34;) Now we have two lists:\n uploadConfig is a list of the four lines of bash that will decode and then upload the configuration files to the storage account. uploadServerJar is a line of bash to download the server software and upload it to the storage account.  We concat those lines together with a semicolon ;  to break up our commands, and we have a full script we can run. The deploymentScript resource itself is fairly simple, and we use depends_on serverStorage to make sure this only runs after our storage account is deployed.\nlet scriptSource = uploadServerJar :: uploadConfig |\u0026gt; List.rev // do the server upload last so it won\u0026#39;t start until the configs are in place.  |\u0026gt; String.concat \u0026#34;; \u0026#34; deploymentScript { name \u0026#34;deployMinecraftConfig\u0026#34; // Depend on the storage account so this won\u0026#39;t run until it\u0026#39;s there.  depends_on serverStorage script_content scriptSource force_update } Creating the Container Instance The container instance runs a Java Runtime Environmennt, giving it enough CPU and memory for a small server with a few players. It has a volume mounted to the Azure Storage Account File share where the configuration files and server.jar are uploaded.\nThe containerGroup has a dependency on the storageAccount so it won\u0026rsquo;t be deployed until the storageAccount is deployed. There is a bit of a race condition since the container group could be deployed and start before the deploymentScript uploads the server.jar and configuration files. To prevent this issue the container runs a while loop in bash until the server starts successfully.\nlet serverContainer = containerGroup { name \u0026#34;minecraft-server\u0026#34; public_dns \u0026#34;azmcworld1\u0026#34; [ TCP, uint16 serverPort ] add_instances [ containerInstance { name \u0026#34;minecraftserver\u0026#34; image \u0026#34;mcr.microsoft.com/java/jre-headless:8-zulu-alpine\u0026#34; // The command line needs to change to the directory for the file share  // and then start the server.  // It needs a little more memory than the defaults, -Xmx3G gives it 3 GiB  // of memory.  command_line [ \u0026#34;/bin/sh\u0026#34; \u0026#34;-c\u0026#34; // We will need to do a retry loop since we can\u0026#39;t have a depends_on  // for the deploymentScript to finish.  $\u0026#34;cd /data/{worldName}; while true; do java -Djava.net.preferIPv4Stack=true -Xms1G -Xmx3G -jar server.jar nogui \u0026amp;\u0026amp; break; sleep 30; done\u0026#34; ] // If we chose a custom port in the settings, it should go here.  add_public_ports [ uint16 serverPort ] // It needs a couple cores or the world may lag with a few players  cpu_cores 2 // Give it enough memory for the JVM  memory 3.5\u0026lt;Gb\u0026gt; // Mount the path to the Azure Storage File share in the container  add_volume_mount worldName $\u0026#34;/data/{worldName}\u0026#34; } ] // Add the file share for the world data and server configuration.  add_volumes [ volume_mount.azureFile worldName worldName serverStorage.Name.ResourceName.Value ] } Here we will build the template. The deployConfig deployment script is especially interesting as it contains the embedded configuration files and the curl command with the link to the current server.jar from scraping the download page.\n/// Build the deployment with storage, deployment script, and container group. let deployment = arm { location Location.EastUS add_resources [ serverStorage deployConfig serverContainer ] } deployment |\u0026gt; Writer.quickWrite \u0026#34;minecraft-server\u0026#34; After running this deployment, view the container group in the Azure Portal or with az container logs to watch the server start up and generate a world. Once the world is generated, it\u0026rsquo;s ready to connect from your Minecraft Java Edition client by entering the DNS name for the container group!\nIf you need to change the configuration you could connect to the terminal of the container instance. But in the spirit of mature configuration management and immutable infrastructure, you should rebuild the config, stop the container group, and redeploy. The existing state - the minecraft world data - is left intact in the storage account and the configuration is replaced with your updates. Once the update is deployed, you can restart the container group.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/aci-fsx/","title":"F# Script in a Container Group","tags":[],"description":"","content":"Introduction In this tutorial, you will deploy an F# script directly to an Azure Container Group. This is useful when you need to fill a gap in your solution with some quick application logic or to test scenarios on Azure before building a more complex application. We\u0026rsquo;ll cover the following steps:\n Create a brief F# script. Create a container instance. Include the script on a volume that will be attached to the container when started.  Create the F# Script Scripts are often useful for quick automation or very simple application logic. Our goal here is to create a small HTTP service - this could be used for a health check service or to bootstrap a larger application, but we\u0026rsquo;ll keep it very simple for illustrative purposes. Let\u0026rsquo;s name it main.fsx.\n#r \u0026#34;nuget: Suave, Version=2.6.0\u0026#34; open Suave let config = { defaultConfig with bindings = [ HttpBinding.createSimple HTTP \u0026#34;0.0.0.0\u0026#34; 8080 ] } startWebServer config (Successful.OK \u0026#34;Hello Farmers!\u0026#34;) Create the Container Group A container group consists of one or more containers that will run together. The container instances in the group can communicate with each other and share files over volume mounts.\nOur script relies on the dotnet 5 SDK to run the script with the dotnet fsi command, so we will run it on the dotnet/sdk:5.0 docker image which includes this SDK. Since our script creates a web listener on port 8080, we will add that as a public port and give it a DNS name so we can reach it.\nopen Farmer open Farmer.Builders let containers = containerGroup { name \u0026#34;my-app\u0026#34; add_instances [ containerInstance { name \u0026#34;fsi\u0026#34; image \u0026#34;mcr.microsoft.com/dotnet/sdk:5.0\u0026#34; add_public_ports [ 8080us ] } ] public_dns \u0026#34;my-fsi-app\u0026#34; [ TCP, 8080us ] } Include the script in the deployment The F# script will be embedded in the template as a secret_string. This creates a file in the container group that can be mounted into the file system on any of the container instances in the group. In our case, we will mount the F# script as a file named main.fsx in the container group and mount the directory containing that file as /src. With this in place we can also set the dotnet fsi command to run on container start, executing the script.\nlet containers = containerGroup { name \u0026#34;my-app\u0026#34; add_instances [ containerInstance { name \u0026#34;fsi\u0026#34; image \u0026#34;mcr.microsoft.com/dotnet/sdk:5.0\u0026#34; add_public_ports [ 8080us ] // Add a volume mount with the script source.  add_volume_mount \u0026#34;script-source\u0026#34; \u0026#34;/src\u0026#34; // Set the command line to run \u0026#39;dotnet fsi /src/main.fsx\u0026#39; on startup  command_line (\u0026#34;dotnet fsi /src/main.fsx\u0026#34;.Split null |\u0026gt; List.ofArray) } ] public_dns \u0026#34;my-fsi-app\u0026#34; [ TCP, 8080us ] // Read our script source when building the ARM template and embed it into the template as a secret string volume mount to attach to the container group.  add_volumes [ volume_mount.secret_string \u0026#34;script-source\u0026#34; \u0026#34;main.fsx\u0026#34; (System.IO.File.ReadAllText \u0026#34;main.fsx\u0026#34;) ] } The resulting template contains the contents of the F# script embedded as base64 so we have a standalone template that can be deployed to ARM.\narm { location Location.EastUS add_resources [ containers ] } When the container group starts, it will execute the F# script, starting the service. This is very useful for gathering source and configuration from your local or internal environment and including it in a deployment. We are able to use this technique due to two unique features:\n Farmer is an \u0026ldquo;embedded\u0026rdquo; DSL - rather than simply a friendly version of the ARM template language, it brings the full feature set of .NET when building a template. This makes reading a script from the file system, converting to base64, and embedding in the template a simple process. ARM templates are not executed locally like Azure CLI scripts - they are a specification for ARM to deploy the infrastructure on your behalf. Once the F# script on your local machine is embedded into the template, ARM is able to pass it to your infrastructure securely over Azure\u0026rsquo;s control plane.  "},{"uri":"https://compositionalit.github.io/farmer/tutorials/cosmos-backed-webapp/","title":"Cosmos-backed Web App","tags":[],"description":"","content":"Introduction This tutorial walks you through creating a web application which is backed by a Cosmos DB database, and is fully configured with connection string settings for you to start developing against. We\u0026rsquo;ll cover the following steps:\n Creating a Cosmos DB account with a single database. Creating a web application with an automatically configured app insights instance. Configuring the web application to have the connection settings required to connect to the Cosmos DB instance.    Full code available here\n  Create the CosmosDB instance Create a CosmosDB instance using the cosmosDb builder:\nopen Farmer open Farmer.Builders open Farmer.CosmosDb let theDatabase = cosmosDb { name \u0026#34;Tasks\u0026#34; account_name \u0026#34;isaac-to-do-app-cosmos\u0026#34; consistency_policy Session } Create and configure a web app Create a web application, and provide settings that are derived from the Cosmos DB instance that you just created.\n The API of the functions builder is virtually identical to that of the Web App builder. You can replace webApp with functions below, removing the sku keyword, and you will get a working Azure Functions instance instead.\n let theApp = webApp { name \u0026#34;isaac-to-do-app\u0026#34; sku WebApp.Sku.B1 setting \u0026#34;CosmosDb:Account\u0026#34; theDatabase.Endpoint setting \u0026#34;CosmosDb:Key\u0026#34; theDatabase.PrimaryKey setting \u0026#34;CosmosDb:DatabaseName\u0026#34; theDatabase.DbName setting \u0026#34;CosmosDb:ContainerName\u0026#34; \u0026#34;Items\u0026#34; }  You don\u0026rsquo;t have to explicitly set a dependency between the two. Farmer will \u0026ldquo;pull out\u0026rdquo; the Cosmos DB details itself.\n You don\u0026rsquo;t have to be concerned about secrets of the CosmosDB instance leaking in your ARM template, because no secrets are supplied. Instead, your template will be populated with ARM expressions which will only be evaluated at runtime:\n{ \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:Account\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[reference(resourceId(\u0026#39;Microsoft.DocumentDb/databaseAccounts\u0026#39;, \u0026#39;isaac-to-do-app-cosmos\u0026#39;), \u0026#39;2020-03-01\u0026#39;).documentEndpoint]\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:ContainerName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Items\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:DatabaseName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Tasks\u0026#34; } { \u0026#34;name\u0026#34;: \u0026#34;CosmosDb:Key\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;[listKeys(resourceId(\u0026#39;Microsoft.DocumentDb/databaseAccounts\u0026#39;, \u0026#39;isaac-to-do-app-cosmos\u0026#39;), providers(\u0026#39;Microsoft.DocumentDb\u0026#39;,\u0026#39;databaseAccounts\u0026#39;).apiVersions[0]).primaryMasterKey]\u0026#34; } Add both resources to your ARM template let template = arm { location Location.WestEurope add_resources [ theDatabase theApp ] } You can now deploy the template and you\u0026rsquo;ll have a web application which has all required secrets to communicate with the Cosmos DB instance.\n"},{"uri":"https://compositionalit.github.io/farmer/tutorials/multiple-web-apps/","title":"Multiple web apps","tags":[],"description":"","content":"Introduction This tutorial walks you through creating multiple web applications that will share a common web server. We\u0026rsquo;ll cover the following steps:\n Creating a web app. Creating multiple web apps and \u0026ldquo;sharing\u0026rdquo; the first web app\u0026rsquo;s service plan and Application Insights instances. How to use F#\u0026lsquo;s list comprehensions to rapidly creating multiple websites.    Full code available here\n  Creating a single web app Create a standard web app as normal:\nlet primaryWebApp = webApp { name \u0026#34;primarywebapp\u0026#34; sku WebApp.Sku.F1 } Creating secondary web apps Create a second web app, but this time link to the service plan that is part of the first web app:\nlet secondaryWebApp = webApp { name \u0026#34;secondarywebapp\u0026#34; link_to_service_plan primaryWebApp.ServicePlanName link_to_app_insights primaryWebApp.AppInsightsName } You can now add both web apps to the arm { } block for deployment:\nlet template = arm { location Location.NorthEurope add_resource primaryWebApp add_resource secondaryWebApp } Creating dedicated Service Plan and App Insights instances Rather than \u0026ldquo;piggy back\u0026rdquo; on a \u0026ldquo;primary\u0026rdquo; web app, you can also opt to create dedicated service plan and app insights instances and configure all web apps to use them. This is a slightly more verbose option, but you may find it clearer, and as we\u0026rsquo;ll see shortly, it can sometimes be useful to declare these instances outside of the web app:\nlet plan = servicePlan { name \u0026#34;theFarm\u0026#34; sku WebApp.Sku.F1 } let ai = appInsights { name \u0026#34;insights\u0026#34; } let aWebApp = webApp { name \u0026#34;primarywebapp\u0026#34; link_to_service_plan plan link_to_app_insights ai } let anotherWebApp = webApp { name \u0026#34;secondarywebapp\u0026#34; link_to_service_plan plan link_to_app_insights ai }  As you are creating the plan and AI instances yourself, you also need to remember to add them to the arm { } block!\n Rapidly creating multiple web apps F# has excellent support for working with collections of data, including creating data. Let\u0026rsquo;s assume we wanted to create four web apps, each with a name \u0026ldquo;mywebapp-{index}\u0026rdquo; e.g. \u0026ldquo;mywebapp-1\u0026rdquo; etc. We can use F#\u0026lsquo;s list comprehensions to create four web apps quickly and easily.\nlet webApps : IBuilder list = [ for i in 1 .. 4 do webApp { name (\u0026#34;mywebapp-\u0026#34; + string i) link_to_service_plan plan link_to_app_insights ai } ] The key parts to note are:\n Use of [ ], which in F# signify a list of some data. Use of for .. in .. do syntax to iterate over numbers 1 to 4, assigning each value to i. Creating unique names for each web app using simple string concatentation. An explicit type annotation (: IBuilder list). Without getting into too much detail, this is needed because F# is somewhat stricter about implicit type conversions than other languages, particularly around list contra/covariance.  List comprehensions in F# are very powerful. You can use this approach with a specific set of names that are themselves a list as well e.g.\nlet planets = [ \u0026#34;jupiter\u0026#34;; \u0026#34;mars\u0026#34;; \u0026#34;pluto\u0026#34;; \u0026#34;venus\u0026#34; ] let webApps = [ for planet in planets do ... ] Adding multiple resources to the template Once you have created a list of web apps, you can add them all at once to the ARM builder using the add_resources keyword:\nlet template = arm { ... add_resources webApps } "},{"uri":"https://compositionalit.github.io/farmer/tutorials/serverless-etl/","title":"Serverless ETL","tags":[],"description":"","content":"Introduction This tutorial shows how to create the infrastructure required to implement a common pattern for code-first \u0026ldquo;extract-transform-load\u0026rdquo; (ETL) processes. In this tutorial, imagine you wish to react to data being created in a blob in Storage, then parse it, and finally insert the \u0026ldquo;parsed\u0026rdquo; data into SQL in a relational database for use by e.g. a web application. We\u0026rsquo;ll cover the following steps:\n Creating an Azure Functions instance, with automatically configured storage and app insights instances. Creating a SQL Azure database and server. Configuring the Functions instance to have connection settings required to connect to both Storage and SQL instances. Safely providing a SQL Server password to Farmer at deployment time.    Full code available here\n  Create the SQL instance Create a SQL Server and database using the sqlServer builder. This server would be used for processed data at the end of the ETL pipeline.\nopen Farmer open Farmer.Builders let transactionalDb = sqlServer { name \u0026#34;etlserver\u0026#34; admin_username \u0026#34;theadministrator\u0026#34; add_databases [ sqlDb { name \u0026#34;parseddata\u0026#34;; sku Sql.DtuSku.S1 } ] }  We explicitly set the SKU of the database. You don\u0026rsquo;t have to do this; if you elect not to, Farmer will create an elastic pool and assign the database into that.\n Create and configure a Functions instance Create a functions instance which would contain the application that monitors the storage account for blobs, process each blob and then insert data into SQL. Also, provide the connection string that is derived from the SQL instance that you just created.\nlet etlProcessor = functions { name \u0026#34;etlprocessor\u0026#34; storage_account_name \u0026#34;mydata\u0026#34; setting \u0026#34;sql-conn\u0026#34; (transactionalDb.ConnectionString \u0026#34;parseddata\u0026#34;) }  Functions instances require a storage account to operate, and will automatically create one for you. In this sample, we have explicitly provided the storage account name; you don\u0026rsquo;t have to do this - Farmer will derive one based on the function instance name. If you prefer to manage the storage account yourself, you can create a storage account and use the link_to_storage_account keyword instead.\nFarmer will also automatically configure the functions instance with connection string settings for both the AzureWebJobsStorage and AzureWebJobsDashboard settings. You can use these to also configure your functions app to read from.\n Adding extra type safety for sharing resources If the mistype the database name for the connection string, Farmer will automatically fail and let you know at runtime. However, a better approach is to use F# to enforce sharing the same database name across the Function instance and SQL server by referencing the database instance directly, instead of a raw string:\nlet database = sqlDb { name \u0026#34;isaacparseddata\u0026#34; sku Sql.DtuSku.S1 } let transactionalDb = sqlServer { ... add_databases [ database ] } let etlProcessor = functions { ... setting \u0026#34;sql-conn\u0026#34; (transactionalDb.ConnectionString database) }  In this case, you don\u0026rsquo;t need to add the database as a resource to the arm { } block; Farmer will do it automatically as part of the sqlServer builder.\n Add both resources to your ARM template let template = arm { location Location.WestEurope add_resource transactionalDb add_resource etlProcessor } Deploy the template When deploying the template, you\u0026rsquo;ll need to provide the password for the SQL Server instance. This is captured as a secure parameter to the template; this guarantees that the password will not be stored in the ARM template as plain text.\n{ \u0026#34;parameters\u0026#34;: { \u0026#34;password-for-isaacetlserver\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;securestring\u0026#34; } } } The parameter name is automatically generated based on the server name. A member on the sql configuration value can be used to quickly get to this and to set the password at deployment time:\ntemplate |\u0026gt; Deploy.execute \u0026#34;my-resource-group\u0026#34; [ transactionalDb.PasswordParameter, \u0026#34;SQL PASSWORD GOES HERE\u0026#34; ] |\u0026gt; printfn \u0026#34;%A\u0026#34;  You should never commit secrets into source control. Instead, set environment variables or command line parameters to your Farmer program to read in the password and pass it into the execute function. For CI/CD tools such as Octopus or Azure DevOps, you can set secrets that appear as environment variables.\n "},{"uri":"https://compositionalit.github.io/farmer/tutorials/web-storage-keyvault/","title":"Web App Secrets with KeyVault","tags":[],"description":"","content":"Introduction This tutorial shows how to create the infrastructure required to host a web app which can retrieve secrets from a secure store (Keyvault) using Azure identity. In this tutorial, we\u0026rsquo;ll store the key for a storage account in Keyvault, but it could be anything. We\u0026rsquo;ll cover the following steps:\n Creating a Web App, Storage Account and a KeyVault instance. Safely adding the Storage Account key into KeyVault. Granting a read-only trust between KeyVault and the Web App. Referencing the KeyVault setting from the Web App.    Full code available here\n  Create basic resources Start by creating the three main resources we need: a web app, storage account and key vault in the following ordwer:\nopen Farmer open Farmer.Builders let datastore = storageAccount { name \u0026#34;\u0026lt;storage name goes here\u0026gt;\u0026#34; } let webapplication = webApp { name \u0026#34;\u0026lt;web app name goes here\u0026gt;\u0026#34; } let secretsvault = keyVault { name \u0026#34;\u0026lt;key vault name goes here\u0026gt;\u0026#34; } Configure KeyVault with the Storage Key Let\u0026rsquo;s now add the storage account key to the key vault:\nlet secretsvault = keyVault { name \u0026#34;isaacsupersecret\u0026#34; add_secret (\u0026#34;storagekey\u0026#34;, datastore.Key) } Grant secret access to the web app Now we have KeyVault grant permission to the web app:\nlet webapplication = webApp { ... system_identity } let secretsvault = keyVault { ... add_access_policy (AccessPolicy.create webapplication.SystemIdentity) } The AccessPolicy.create builder method has several overloads; this one grants basic GET and LIST permissions to the web application\u0026rsquo;s built-in system identity, which we have just activated above. You can also supply other permissions as a secondary argument to the create method.\nConnect secret to the web app Now, we use Farmer\u0026rsquo;s Web App / Keyvault integration to seamlessly provide access to key vault secrets:\nlet webapplication = webApp { ... link_to_keyvault (ResourceName \u0026#34;\u0026lt;key vault name goes here\u0026gt;\u0026#34;) secret_setting \u0026#34;storagekey\u0026#34; } or\nlet kv = keyVault { name \u0026#34;keyvault\u0026#34; } let webapplication = webApp { ... link_to_keyvault kv secret_setting \u0026#34;storagekey\u0026#34; } The first keyword \u0026ldquo;links\u0026rdquo; the vault with the web app, and tells Farmer that all \u0026ldquo;secret\u0026rdquo; settings should now be read from this vault. We cannot reference the keyvault directly in this case because it\u0026rsquo;s declared after the web application, so we construct a ResourceId reference ourselves.\nThe second keyword actually adds the secret to the web app. If you hadn\u0026rsquo;t added the link_to_keyvault keyword, this would be rendered into ARM as a secret parameter, but in this case because we\u0026rsquo;ve linked the vault in, it gets redirected to point there instead.\nAdding extra type safety for sharing resources To prevent accidentally mistyping the secret or vault names, you should bind the magic strings into symbols at the top of the template and replace usages in the template.\nlet secretName = \u0026#34;storagekey\u0026#34; let vaultName = \u0026#34;\u0026lt;key vault name goes here\u0026gt;\u0026#34; Add all resources to your ARM template Add all the resources into an arm builder and then deploy the template as normal.\nlet template = arm { location Location.WestEurope add_resources [ secretsvault datastore webapplication ] } That\u0026rsquo;s it! You now have a web application that can read the secret from the vault without using any keyvault connection string. If you log into the portal, you\u0026rsquo;ll see that the secret setting is indeed in the Configuration section, but will have a green tick and a \u0026ldquo;Key vault reference\u0026rdquo; message next to it:\n  The value of the secret will look something like this:\n@Microsoft.KeyVault(SecretUri=https://\u0026lt;key vault name goes here\u0026gt;.vault.azure.net/secrets/storagekey) The App Service will transparently retrieve the secret from the vault for you when you try to access the setting.\n By default, even you will not be able to access the secret from key vault! If you want to grant yourself access to the secret in the vault, you can use the AccessPolicy.findUsers method in code to retrieve your principal and grant access to the secret through Farmer. Alternatively, you can manually grant yourself access through the Portal etc.\n "},{"uri":"https://compositionalit.github.io/farmer/","title":"Farmer","tags":[],"description":"","content":"  Making repeatable Azure deployments easy! Farmer is an easy-to-learn library for rapidly authoring and deploying entire Azure architectures.\n Infrastructure-as-code, done right. Simple code snippets allow you to rapidly construct complex topologies. Idempotent deployments. Safely provision a template repeatedly and know that only changes will be applied. Cross-platform. Runs on .NET Core on Windows, Mac or Linux. Built on trusted technologies. Farmer uses Microsoft\u0026rsquo;s Azure Resource Manager (ARM) technology for deployments to Azure. Commercial supported. Professional support plans for teams that wish to benefit from peace of mind and further improve the product. Easy to learn, easy to understand code through a simple, strongly-typed and pragmatic DSL.  Already using ARM templates? Farmer has you covered.\n Farmer is completely backwards compatible with ARM templates. Farmer generates standard ARM templates so you can continue to use existing deployment processes. Safely create dependencies between resources. Uses static typing to give confidence that your templates will work first time. Easily access common properties of resources. No more fighting to concatenate cryptic strings! Extensible API. Add new helpers and members as needed. Open source and free. Farmer is free to use and modify. We welcome contributions to the project!  Why not Azure Resource Manager? Azure Resource Manager is a service-side orchestrator, as such, Farmer does use ARM! It simply replaces the templating language with a statically-verifiable DSL to declare resources and comes with helper functions to perform common tasks. Farmer templates are around 5-8 times smaller than ARM templates, meaning they are quicker and easier to author, understand and maintain. Read more on the comparison page.\nCreating a web application with a configured application insights and a linked storage account Farmer Templates These 20 lines of simple, readable and type-safe code are translated into 141 lines of JSON ARM template!\n// Create a storage account with a container let myStorageAccount = storageAccount { name \u0026#34;myTestStorage\u0026#34; add_public_container \u0026#34;myContainer\u0026#34; } // Create a web app with application insights that\u0026#39;s connected to the storage account. let myWebApp = webApp { name \u0026#34;myTestWebApp\u0026#34; setting \u0026#34;storageKey\u0026#34; myStorageAccount.Key } // Create an ARM template let deployment = arm { location Location.NorthEurope add_resources [ myStorageAccount myWebApp ] } // Deploy it to Azure! deployment |\u0026gt; Writer.quickWrite \u0026#34;myResourceGroup\u0026#34; Want to try it out? Follow our quickstart guide now! "},{"uri":"https://compositionalit.github.io/farmer/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://compositionalit.github.io/farmer/tags/","title":"Tags","tags":[],"description":"","content":""}]